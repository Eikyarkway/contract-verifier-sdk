(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/esbuild-plugin-polyfill-node/polyfills/global.js
  var global;
  var init_global = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/global.js"() {
      global = globalThis;
    }
  });

  // node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js
  var init_dirname = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js"() {
    }
  });

  // node_modules/esbuild-plugin-polyfill-node/polyfills/__filename.js
  var init_filename = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/__filename.js"() {
    }
  });

  // node_modules/process-es6/browser.js
  var browser_exports = {};
  __export(browser_exports, {
    addListener: () => addListener,
    argv: () => argv,
    binding: () => binding,
    browser: () => browser,
    chdir: () => chdir,
    config: () => config,
    cwd: () => cwd,
    default: () => browser_default,
    emit: () => emit,
    env: () => env,
    hrtime: () => hrtime,
    nextTick: () => nextTick,
    off: () => off,
    on: () => on,
    once: () => once,
    platform: () => platform,
    release: () => release,
    removeAllListeners: () => removeAllListeners,
    removeListener: () => removeListener,
    title: () => title,
    umask: () => umask,
    uptime: () => uptime,
    version: () => version,
    versions: () => versions
  });
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e2) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e2) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  }
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function noop() {
  }
  function binding(name) {
    throw new Error("process.binding is not supported");
  }
  function cwd() {
    return "/";
  }
  function chdir(dir) {
    throw new Error("process.chdir is not supported");
  }
  function umask() {
    return 0;
  }
  function hrtime(previousTimestamp) {
    var clocktime = performanceNow.call(performance) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds, nanoseconds];
  }
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1e3;
  }
  var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener, once, off, removeListener, removeAllListeners, emit, performance, performanceNow, startTime, browser_default;
  var init_browser = __esm({
    "node_modules/process-es6/browser.js"() {
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      cachedSetTimeout = defaultSetTimout;
      cachedClearTimeout = defaultClearTimeout;
      if (typeof global.setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      }
      if (typeof global.clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      }
      queue = [];
      draining = false;
      queueIndex = -1;
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      title = "browser";
      platform = "browser";
      browser = true;
      env = {};
      argv = [];
      version = "";
      versions = {};
      release = {};
      config = {};
      on = noop;
      addListener = noop;
      once = noop;
      off = noop;
      removeListener = noop;
      removeAllListeners = noop;
      emit = noop;
      performance = global.performance || {};
      performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
        return new Date().getTime();
      };
      startTime = new Date();
      browser_default = {
        nextTick,
        title,
        browser,
        env,
        argv,
        version,
        versions,
        on,
        addListener,
        once,
        off,
        removeListener,
        removeAllListeners,
        emit,
        binding,
        cwd,
        chdir,
        umask,
        hrtime,
        platform,
        release,
        config,
        uptime
      };
    }
  });

  // node_modules/esbuild-plugin-polyfill-node/polyfills/process.js
  var init_process = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/process.js"() {
      init_browser();
    }
  });

  // node_modules/buffer-es6/base64.js
  function init() {
    inited = true;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
  }
  function toByteArray(b64) {
    if (!inited) {
      init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
    arr = new Arr(len * 3 / 4 - placeHolders);
    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;
    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = tmp >> 16 & 255;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[L++] = tmp & 255;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var output = "";
    var parts = [];
    var maxChunkLength = 16383;
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 63];
      output += "==";
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 63];
      output += lookup[tmp << 2 & 63];
      output += "=";
    }
    parts.push(output);
    return parts.join("");
  }
  var lookup, revLookup, Arr, inited;
  var init_base64 = __esm({
    "node_modules/buffer-es6/base64.js"() {
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      lookup = [];
      revLookup = [];
      Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      inited = false;
    }
  });

  // node_modules/buffer-es6/ieee754.js
  function read(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  }
  function write(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer[offset + i - d] |= s * 128;
  }
  var init_ieee754 = __esm({
    "node_modules/buffer-es6/ieee754.js"() {
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
    }
  });

  // node_modules/buffer-es6/isArray.js
  var toString, isArray_default;
  var init_isArray = __esm({
    "node_modules/buffer-es6/isArray.js"() {
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      toString = {}.toString;
      isArray_default = Array.isArray || function(arr) {
        return toString.call(arr) == "[object Array]";
      };
    }
  });

  // node_modules/buffer-es6/index.js
  function kMaxLength() {
    return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError("Invalid typed array length");
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length);
      that.__proto__ = Buffer2.prototype;
    } else {
      if (that === null) {
        that = new Buffer2(length);
      }
      that.length = length;
    }
    return that;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
      return new Buffer2(arg, encodingOrOffset, length);
    }
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new Error(
          "If encoding is specified then the first argument must be a string"
        );
      }
      return allocUnsafe(this, arg);
    }
    return from(this, arg, encodingOrOffset, length);
  }
  function from(that, value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }
    if (typeof value === "string") {
      return fromString(that, value, encodingOrOffset);
    }
    return fromObject(that, value);
  }
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }
  function alloc(that, size, fill2, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size);
    }
    if (fill2 !== void 0) {
      return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
    }
    return createBuffer(that, size);
  }
  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer2.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that;
  }
  function fromString(that, string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }
    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string, encoding);
    if (actual !== length) {
      that = that.slice(0, actual);
    }
    return that;
  }
  function fromArrayLike(that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array, byteOffset, length) {
    array.byteLength;
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError("'length' is out of bounds");
    }
    if (byteOffset === void 0 && length === void 0) {
      array = new Uint8Array(array);
    } else if (length === void 0) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      that = array;
      that.__proto__ = Buffer2.prototype;
    } else {
      that = fromArrayLike(that, array);
    }
    return that;
  }
  function fromObject(that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);
      if (that.length === 0) {
        return that;
      }
      obj.copy(that, 0, 0, len);
      return that;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan(obj.length)) {
          return createBuffer(that, 0);
        }
        return fromArrayLike(that, obj);
      }
      if (obj.type === "Buffer" && isArray_default(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
    }
    return length | 0;
  }
  function internalIsBuffer(b) {
    return !!(b != null && b._isBuffer);
  }
  function byteLength(string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      string = "" + string;
    }
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
        case void 0:
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string).length;
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    if (buffer.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (isNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (internalIsBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read2(arr, i + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new TypeError("Invalid hex string");
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed))
        return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf);
    } else {
      return fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = "";
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function checkInt(buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 65535 + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 4294967295 + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
    }
  }
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, "");
  }
  function toHex(n) {
    if (n < 16)
      return "0" + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length)
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isnan(val) {
    return val !== val;
  }
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
  }
  function isFastBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
  }
  var INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
  var init_buffer_es6 = __esm({
    "node_modules/buffer-es6/index.js"() {
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      init_base64();
      init_ieee754();
      init_isArray();
      INSPECT_MAX_BYTES = 50;
      Buffer2.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== void 0 ? global.TYPED_ARRAY_SUPPORT : true;
      _kMaxLength = kMaxLength();
      Buffer2.poolSize = 8192;
      Buffer2._augment = function(arr) {
        arr.__proto__ = Buffer2.prototype;
        return arr;
      };
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(null, value, encodingOrOffset, length);
      };
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        Buffer2.prototype.__proto__ = Uint8Array.prototype;
        Buffer2.__proto__ = Uint8Array;
        if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
        }
      }
      Buffer2.alloc = function(size, fill2, encoding) {
        return alloc(null, size, fill2, encoding);
      };
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer2.isBuffer = isBuffer;
      Buffer2.compare = function compare(a, b) {
        if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
          throw new TypeError("Arguments must be Buffers");
        }
        if (a === b)
          return 0;
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!isArray_default(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        var i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        var buffer = Buffer2.allocUnsafe(length);
        var pos = 0;
        for (i = 0; i < list.length; ++i) {
          var buf = list[i];
          if (!internalIsBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          buf.copy(buffer, pos);
          pos += buf.length;
        }
        return buffer;
      };
      Buffer2.byteLength = byteLength;
      Buffer2.prototype._isBuffer = true;
      Buffer2.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString2() {
        var length = this.length | 0;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.equals = function equals(b) {
        if (!internalIsBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        var str = "";
        var max = INSPECT_MAX_BYTES;
        if (this.length > 0) {
          str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
          if (this.length > max)
            str += " ... ";
        }
        return "<Buffer " + str + ">";
      };
      Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
        if (!internalIsBuffer(target)) {
          throw new TypeError("Argument must be a Buffer");
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        var x = thisEnd - thisStart;
        var y = end - start;
        var len = Math.min(x, y);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      Buffer2.prototype.write = function write2(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset | 0;
          if (isFinite(length)) {
            length = length | 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
              return asciiWrite(this, string, offset, length);
            case "latin1":
            case "binary":
              return latin1Write(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      MAX_ARGUMENTS_LENGTH = 4096;
      Buffer2.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer2.prototype;
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer2(sliceLen, void 0);
          for (var i = 0; i < sliceLen; ++i) {
            newBuf[i] = this[i + start];
          }
        }
        return newBuf;
      };
      Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        var val = this[offset + --byteLength2];
        var mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var i = byteLength2;
        var mul = 1;
        var val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return read(this, offset, false, 52, 8);
      };
      Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var mul = 1;
        var i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var i = byteLength2 - 1;
        var mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        if (!Buffer2.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset + 3] = value >>> 24;
          this[offset + 2] = value >>> 16;
          this[offset + 1] = value >>> 8;
          this[offset] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i = byteLength2 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (!Buffer2.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          this[offset + 2] = value >>> 16;
          this[offset + 3] = value >>> 24;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        var i;
        if (this === target && start < targetStart && targetStart < end) {
          for (i = len - 1; i >= 0; --i) {
            target[i + targetStart] = this[i + start];
          }
        } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
          for (i = 0; i < len; ++i) {
            target[i + targetStart] = this[i + start];
          }
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, start + len),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (code < 256) {
              val = code;
            }
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
        } else if (typeof val === "number") {
          val = val & 255;
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        var i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
          var len = bytes.length;
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
    }
  });

  // node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js
  var init_buffer = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js"() {
      init_buffer_es6();
    }
  });

  // node_modules/symbol.inspect/index.js
  var require_symbol = __commonJS({
    "node_modules/symbol.inspect/index.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var SymbolInspect = Symbol.for("nodejs.util.inspect.custom");
      module.exports = SymbolInspect;
    }
  });

  // node_modules/ton-core/dist/utils/crc16.js
  var require_crc16 = __commonJS({
    "node_modules/ton-core/dist/utils/crc16.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crc16 = void 0;
      function crc16(data) {
        const poly = 4129;
        let reg = 0;
        const message = Buffer2.alloc(data.length + 2);
        message.set(data);
        for (let byte of message) {
          let mask = 128;
          while (mask > 0) {
            reg <<= 1;
            if (byte & mask) {
              reg += 1;
            }
            mask >>= 1;
            if (reg > 65535) {
              reg &= 65535;
              reg ^= poly;
            }
          }
        }
        return Buffer2.from([Math.floor(reg / 256), reg % 256]);
      }
      exports.crc16 = crc16;
    }
  });

  // node_modules/ton-core/dist/address/Address.js
  var require_Address = __commonJS({
    "node_modules/ton-core/dist/address/Address.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __importDefault2 = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Address = void 0;
      var symbol_inspect_1 = __importDefault2(require_symbol());
      var crc16_1 = require_crc16();
      var bounceable_tag = 17;
      var non_bounceable_tag = 81;
      var test_flag = 128;
      function parseFriendlyAddress(src) {
        const data = Buffer2.isBuffer(src) ? src : Buffer2.from(src, "base64");
        if (data.length !== 36) {
          throw new Error("Unknown address type: byte length is not equal to 36");
        }
        const addr = data.subarray(0, 34);
        const crc = data.subarray(34, 36);
        const calcedCrc = (0, crc16_1.crc16)(addr);
        if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {
          throw new Error("Invalid checksum: " + src);
        }
        let tag = addr[0];
        let isTestOnly = false;
        let isBounceable = false;
        if (tag & test_flag) {
          isTestOnly = true;
          tag = tag ^ test_flag;
        }
        if (tag !== bounceable_tag && tag !== non_bounceable_tag)
          throw "Unknown address tag";
        isBounceable = tag === bounceable_tag;
        let workchain = null;
        if (addr[1] === 255) {
          workchain = -1;
        } else {
          workchain = addr[1];
        }
        const hashPart = addr.subarray(2, 34);
        return { isTestOnly, isBounceable, workchain, hashPart };
      }
      var Address2 = class {
        static isAddress(src) {
          return src instanceof Address2;
        }
        static isFriendly(source) {
          return source.indexOf(":") < 0;
        }
        static normalize(source) {
          if (typeof source === "string") {
            return Address2.parse(source).toString();
          } else {
            return source.toString();
          }
        }
        static parse(source) {
          if (Address2.isFriendly(source)) {
            return this.parseFriendly(source).address;
          } else {
            return this.parseRaw(source);
          }
        }
        static parseRaw(source) {
          let workChain = parseInt(source.split(":")[0]);
          let hash = Buffer2.from(source.split(":")[1], "hex");
          return new Address2(workChain, hash);
        }
        static parseFriendly(source) {
          if (Buffer2.isBuffer(source)) {
            let r = parseFriendlyAddress(source);
            return {
              isBounceable: r.isBounceable,
              isTestOnly: r.isTestOnly,
              address: new Address2(r.workchain, r.hashPart)
            };
          } else {
            let addr = source.replace(/\-/g, "+").replace(/_/g, "/");
            let r = parseFriendlyAddress(addr);
            return {
              isBounceable: r.isBounceable,
              isTestOnly: r.isTestOnly,
              address: new Address2(r.workchain, r.hashPart)
            };
          }
        }
        constructor(workChain, hash) {
          this.toRawString = () => {
            return this.workChain + ":" + this.hash.toString("hex");
          };
          this.toRaw = () => {
            const addressWithChecksum = Buffer2.alloc(36);
            addressWithChecksum.set(this.hash);
            addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);
            return addressWithChecksum;
          };
          this.toStringBuffer = (args) => {
            let testOnly = args && args.testOnly !== void 0 ? args.testOnly : false;
            let bounceable = args && args.bounceable !== void 0 ? args.bounceable : true;
            let tag = bounceable ? bounceable_tag : non_bounceable_tag;
            if (testOnly) {
              tag |= test_flag;
            }
            const addr = Buffer2.alloc(34);
            addr[0] = tag;
            addr[1] = this.workChain;
            addr.set(this.hash, 2);
            const addressWithChecksum = Buffer2.alloc(36);
            addressWithChecksum.set(addr);
            addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);
            return addressWithChecksum;
          };
          this.toString = (args) => {
            let urlSafe = args && args.urlSafe !== void 0 ? args.urlSafe : true;
            let buffer = this.toStringBuffer(args);
            if (urlSafe) {
              return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_");
            } else {
              return buffer.toString("base64");
            }
          };
          this[_a] = () => this.toString();
          this.workChain = workChain;
          this.hash = hash;
          Object.freeze(this);
        }
        equals(src) {
          if (src.workChain !== this.workChain) {
            return false;
          }
          return src.hash.equals(this.hash);
        }
      };
      exports.Address = Address2;
      _a = symbol_inspect_1.default;
    }
  });

  // node_modules/ton-core/dist/address/ExternalAddress.js
  var require_ExternalAddress = __commonJS({
    "node_modules/ton-core/dist/address/ExternalAddress.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __importDefault2 = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ExternalAddress = void 0;
      var symbol_inspect_1 = __importDefault2(require_symbol());
      var ExternalAddress = class {
        static isAddress(src) {
          return src instanceof ExternalAddress;
        }
        constructor(value, bits) {
          this[_a] = () => this.toString();
          this.value = value;
          this.bits = bits;
        }
        toString() {
          return `External<${this.bits}:${this.value}>`;
        }
      };
      exports.ExternalAddress = ExternalAddress;
      _a = symbol_inspect_1.default;
    }
  });

  // node_modules/ton-core/dist/utils/base32.js
  var require_base32 = __commonJS({
    "node_modules/ton-core/dist/utils/base32.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.base32Decode = exports.base32Encode = void 0;
      var alphabet = "abcdefghijklmnopqrstuvwxyz234567";
      function base32Encode(buffer) {
        const length = buffer.byteLength;
        let bits = 0;
        let value = 0;
        let output = "";
        for (let i = 0; i < length; i++) {
          value = value << 8 | buffer[i];
          bits += 8;
          while (bits >= 5) {
            output += alphabet[value >>> bits - 5 & 31];
            bits -= 5;
          }
        }
        if (bits > 0) {
          output += alphabet[value << 5 - bits & 31];
        }
        return output;
      }
      exports.base32Encode = base32Encode;
      function readChar(alphabet2, char) {
        const idx = alphabet2.indexOf(char);
        if (idx === -1) {
          throw new Error("Invalid character found: " + char);
        }
        return idx;
      }
      function base32Decode(input) {
        let cleanedInput;
        cleanedInput = input.toLowerCase();
        const { length } = cleanedInput;
        let bits = 0;
        let value = 0;
        let index = 0;
        const output = Buffer2.alloc(length * 5 / 8 | 0);
        for (let i = 0; i < length; i++) {
          value = value << 5 | readChar(alphabet, cleanedInput[i]);
          bits += 5;
          if (bits >= 8) {
            output[index++] = value >>> bits - 8 & 255;
            bits -= 8;
          }
        }
        return output;
      }
      exports.base32Decode = base32Decode;
    }
  });

  // node_modules/ton-core/dist/address/ADNLAddress.js
  var require_ADNLAddress = __commonJS({
    "node_modules/ton-core/dist/address/ADNLAddress.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __importDefault2 = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ADNLAddress = void 0;
      var symbol_inspect_1 = __importDefault2(require_symbol());
      var base32_1 = require_base32();
      var crc16_1 = require_crc16();
      var ADNLAddress = class {
        static parseFriendly(src) {
          if (src.length !== 55) {
            throw Error("Invalid address");
          }
          src = "f" + src;
          let decoded = (0, base32_1.base32Decode)(src);
          if (decoded[0] !== 45) {
            throw Error("Invalid address");
          }
          let gotHash = decoded.slice(33);
          let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));
          if (!hash.equals(gotHash)) {
            throw Error("Invalid address");
          }
          return new ADNLAddress(decoded.slice(1, 33));
        }
        static parseRaw(src) {
          const data = Buffer2.from(src, "base64");
          return new ADNLAddress(data);
        }
        constructor(address) {
          this.toRaw = () => {
            return this.address.toString("hex").toUpperCase();
          };
          this.toString = () => {
            let data = Buffer2.concat([Buffer2.from([45]), this.address]);
            let hash = (0, crc16_1.crc16)(data);
            data = Buffer2.concat([data, hash]);
            return (0, base32_1.base32Encode)(data).slice(1);
          };
          this[_a] = () => this.toString();
          if (address.length !== 32) {
            throw Error("Invalid address");
          }
          this.address = address;
        }
        equals(b) {
          return this.address.equals(b.address);
        }
      };
      exports.ADNLAddress = ADNLAddress;
      _a = symbol_inspect_1.default;
    }
  });

  // node_modules/ton-core/dist/boc/utils/paddedBits.js
  var require_paddedBits = __commonJS({
    "node_modules/ton-core/dist/boc/utils/paddedBits.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bitsToPaddedBuffer = void 0;
      var BitBuilder_1 = require_BitBuilder();
      function bitsToPaddedBuffer(bits) {
        let builder = new BitBuilder_1.BitBuilder(Math.ceil(bits.length / 8) * 8);
        builder.writeBits(bits);
        let padding = Math.ceil(bits.length / 8) * 8 - bits.length;
        for (let i = 0; i < padding; i++) {
          if (i === 0) {
            builder.writeBit(1);
          } else {
            builder.writeBit(0);
          }
        }
        return builder.buffer();
      }
      exports.bitsToPaddedBuffer = bitsToPaddedBuffer;
    }
  });

  // node_modules/ton-core/dist/boc/BitString.js
  var require_BitString = __commonJS({
    "node_modules/ton-core/dist/boc/BitString.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __importDefault2 = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BitString = void 0;
      var paddedBits_1 = require_paddedBits();
      var symbol_inspect_1 = __importDefault2(require_symbol());
      var BitString = class {
        /**
         * Constructing BitString from a buffer
         * @param data data that contains the bitstring data. NOTE: We are expecting this buffer to be NOT modified
         * @param offset offset in bits from the start of the buffer
         * @param length length of the bitstring in bits
         */
        constructor(data, offset, length) {
          this[_a] = () => this.toString();
          if (length < 0) {
            throw new Error(`Length ${length} is out of bounds`);
          }
          this._length = length;
          this._data = data;
          this._offset = offset;
        }
        /**
         * Returns the length of the bitstring
         */
        get length() {
          return this._length;
        }
        /**
         * Returns the bit at the specified index
         * @param index index of the bit
         * @throws Error if index is out of bounds
         * @returns true if the bit is set, false otherwise
         */
        at(index) {
          if (index >= this._length) {
            throw new Error(`Index ${index} > ${this._length} is out of bounds`);
          }
          if (index < 0) {
            throw new Error(`Index ${index} < 0 is out of bounds`);
          }
          let byteIndex = this._offset + index >> 3;
          let bitIndex = 7 - (this._offset + index) % 8;
          return (this._data[byteIndex] & 1 << bitIndex) !== 0;
        }
        /**
         * Get a subscring of the bitstring
         * @param offset
         * @param length
         * @returns
         */
        substring(offset, length) {
          if (length === 0 && offset === this._length) {
            return BitString.EMPTY;
          }
          if (offset >= this._length) {
            throw new Error(`Offset(${offset}) > ${this._length} is out of bounds`);
          }
          if (offset < 0) {
            throw new Error(`Offset(${offset}) < 0 is out of bounds`);
          }
          if (offset + length > this._length) {
            throw new Error(`Offset ${offset} + Length ${length} > ${this._length} is out of bounds`);
          }
          return new BitString(this._data, this._offset + offset, length);
        }
        /**
         * Try to get a buffer from the bitstring without allocations
         * @param offset offset in bits
         * @param length length in bits
         * @returns buffer if the bitstring is aligned to bytes, null otherwise
         */
        subbuffer(offset, length) {
          if (offset >= this._length) {
            throw new Error(`Offset ${offset} is out of bounds`);
          }
          if (offset < 0) {
            throw new Error(`Offset ${offset} is out of bounds`);
          }
          if (offset + length > this._length) {
            throw new Error(`Offset + Lenght = ${offset + length} is out of bounds`);
          }
          if (length % 8 !== 0) {
            return null;
          }
          if ((this._offset + offset) % 8 !== 0) {
            return null;
          }
          let start = this._offset + offset >> 3;
          let end = start + (length >> 3);
          return this._data.subarray(start, end);
        }
        /**
         * Checks for equality
         * @param b other bitstring
         * @returns true if the bitstrings are equal, false otherwise
         */
        equals(b) {
          if (this._length !== b._length) {
            return false;
          }
          for (let i = 0; i < this._length; i++) {
            if (this.at(i) !== b.at(i)) {
              return false;
            }
          }
          return true;
        }
        /**
         * Format to canonical string
         * @returns formatted bits as a string
         */
        toString() {
          const padded = (0, paddedBits_1.bitsToPaddedBuffer)(this);
          if (this._length % 4 === 0) {
            const s = padded.subarray(0, Math.ceil(this._length / 8)).toString("hex").toUpperCase();
            if (this._length % 8 === 0) {
              return s;
            } else {
              return s.substring(0, s.length - 1);
            }
          } else {
            const hex = padded.toString("hex").toUpperCase();
            if (this._length % 8 <= 4) {
              return hex.substring(0, hex.length - 1) + "_";
            } else {
              return hex + "_";
            }
          }
        }
      };
      exports.BitString = BitString;
      _a = symbol_inspect_1.default;
      BitString.EMPTY = new BitString(Buffer2.alloc(0), 0, 0);
    }
  });

  // node_modules/ton-core/dist/boc/BitBuilder.js
  var require_BitBuilder = __commonJS({
    "node_modules/ton-core/dist/boc/BitBuilder.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BitBuilder = void 0;
      var Address_1 = require_Address();
      var ExternalAddress_1 = require_ExternalAddress();
      var BitString_1 = require_BitString();
      var BitBuilder = class {
        constructor(size = 1023) {
          this._buffer = Buffer2.alloc(Math.ceil(size / 8));
          this._length = 0;
        }
        /**
         * Current number of bits written
         */
        get length() {
          return this._length;
        }
        /**
         * Write a single bit
         * @param value bit to write, true or positive number for 1, false or zero or negative for 0
         */
        writeBit(value) {
          let n = this._length;
          if (n > this._buffer.length * 8) {
            throw new Error("BitBuilder overflow");
          }
          if (value === true || value > 0) {
            this._buffer[n / 8 | 0] |= 1 << 7 - n % 8;
          }
          this._length++;
        }
        /**
         * Copy bits from BitString
         * @param src source bits
         */
        writeBits(src) {
          for (let i = 0; i < src.length; i++) {
            this.writeBit(src.at(i));
          }
        }
        /**
         * Write bits from buffer
         * @param src source buffer
         */
        writeBuffer(src) {
          if (this._length % 8 === 0) {
            if (this._length + src.length * 8 > this._buffer.length * 8) {
              throw new Error("BitBuilder overflow");
            }
            src.copy(this._buffer, this._length / 8);
            this._length += src.length * 8;
          } else {
            for (let i = 0; i < src.length; i++) {
              this.writeUint(src[i], 8);
            }
          }
        }
        /**
         * Write uint value
         * @param value value as bigint or number
         * @param bits number of bits to write
         */
        writeUint(value, bits) {
          if (bits === 8 && this._length % 8 === 0) {
            let v2 = Number(value);
            if (v2 < 0 || v2 > 255 || !Number.isSafeInteger(v2)) {
              throw Error(`value is out of range for ${bits} bits. Got ${value}`);
            }
            this._buffer[this._length / 8] = Number(value);
            this._length += 8;
            return;
          }
          if (bits === 16 && this._length % 8 === 0) {
            let v2 = Number(value);
            if (v2 < 0 || v2 > 65536 || !Number.isSafeInteger(v2)) {
              throw Error(`value is out of range for ${bits} bits. Got ${value}`);
            }
            this._buffer[this._length / 8] = v2 >> 8;
            this._buffer[this._length / 8 + 1] = v2 & 255;
            this._length += 16;
            return;
          }
          let v = BigInt(value);
          if (bits < 0 || !Number.isSafeInteger(bits)) {
            throw Error(`invalid bit length. Got ${bits}`);
          }
          if (bits === 0) {
            if (value !== 0n) {
              throw Error(`value is not zero for ${bits} bits. Got ${value}`);
            } else {
              return;
            }
          }
          let vBits = 1n << BigInt(bits);
          if (v < 0 || v >= vBits) {
            throw Error(`bitLength is too small for a value ${value}. Got ${bits}`);
          }
          let b = [];
          while (v > 0) {
            b.push(v % 2n === 1n);
            v /= 2n;
          }
          for (let i = 0; i < bits; i++) {
            let off2 = bits - i - 1;
            if (off2 < b.length) {
              this.writeBit(b[off2]);
            } else {
              this.writeBit(false);
            }
          }
        }
        /**
         * Write int value
         * @param value value as bigint or number
         * @param bits number of bits to write
         */
        writeInt(value, bits) {
          let v = BigInt(value);
          if (bits < 0 || !Number.isSafeInteger(bits)) {
            throw Error(`invalid bit length. Got ${bits}`);
          }
          if (bits === 0) {
            if (value !== 0n) {
              throw Error(`value is not zero for ${bits} bits. Got ${value}`);
            } else {
              return;
            }
          }
          if (bits === 1) {
            if (value !== -1n && value !== 0n) {
              throw Error(`value is not zero or -1 for ${bits} bits. Got ${value}`);
            } else {
              this.writeBit(value === -1n);
              return;
            }
          }
          let vBits = 1n << BigInt(bits) - 1n;
          if (v < -vBits || v >= vBits) {
            throw Error(`value is out of range for ${bits} bits. Got ${value}`);
          }
          if (v < 0) {
            this.writeBit(true);
            v = (1n << BigInt(bits) - 1n) + v;
          } else {
            this.writeBit(false);
          }
          this.writeUint(v, bits - 1);
        }
        /**
         * Wrtie var uint value, used for serializing coins
         * @param value value to write as bigint or number
         * @param bits header bits to write size
         */
        writeVarUint(value, bits) {
          let v = BigInt(value);
          if (bits < 0 || !Number.isSafeInteger(bits)) {
            throw Error(`invalid bit length. Got ${bits}`);
          }
          if (v < 0) {
            throw Error(`value is negative. Got ${value}`);
          }
          if (v === 0n) {
            this.writeUint(0, bits);
            return;
          }
          const sizeBytes = Math.ceil(v.toString(2).length / 8);
          const sizeBits = sizeBytes * 8;
          this.writeUint(sizeBytes, bits);
          this.writeUint(v, sizeBits);
        }
        /**
         * Wrtie var int value, used for serializing coins
         * @param value value to write as bigint or number
         * @param bits header bits to write size
         */
        writeVarInt(value, bits) {
          let v = BigInt(value);
          if (bits < 0 || !Number.isSafeInteger(bits)) {
            throw Error(`invalid bit length. Got ${bits}`);
          }
          if (v === 0n) {
            this.writeUint(0, bits);
            return;
          }
          let v2 = v > 0 ? v : -v;
          const sizeBytes = 1 + Math.ceil(v2.toString(2).length / 8);
          const sizeBits = sizeBytes * 8;
          this.writeUint(sizeBytes, bits);
          this.writeInt(v, sizeBits);
        }
        /**
         * Write coins in var uint format
         * @param amount amount to write
         */
        writeCoins(amount) {
          this.writeVarUint(amount, 4);
        }
        /**
         * Write address
         * @param address write address or address external
         */
        writeAddress(address) {
          if (address === null || address === void 0) {
            this.writeUint(0, 2);
            return;
          }
          if (Address_1.Address.isAddress(address)) {
            this.writeUint(2, 2);
            this.writeUint(0, 1);
            this.writeInt(address.workChain, 8);
            this.writeBuffer(address.hash);
            return;
          }
          if (ExternalAddress_1.ExternalAddress.isAddress(address)) {
            this.writeUint(1, 2);
            this.writeUint(address.bits, 9);
            this.writeUint(address.value, address.bits);
            return;
          }
          throw Error(`Invalid address. Got ${address}`);
        }
        /**
         * Build BitString
         * @returns result bit string
         */
        build() {
          return new BitString_1.BitString(this._buffer, 0, this._length);
        }
        /**
         * Build into Buffer
         * @returns result buffer
         */
        buffer() {
          if (this._length % 8 !== 0) {
            throw new Error("BitBuilder buffer is not byte aligned");
          }
          return this._buffer.subarray(0, this._length / 8);
        }
      };
      exports.BitBuilder = BitBuilder;
    }
  });

  // node_modules/ton-core/dist/boc/CellType.js
  var require_CellType = __commonJS({
    "node_modules/ton-core/dist/boc/CellType.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CellType = void 0;
      var CellType;
      (function(CellType2) {
        CellType2[CellType2["Ordinary"] = -1] = "Ordinary";
        CellType2[CellType2["PrunedBranch"] = 1] = "PrunedBranch";
        CellType2[CellType2["MerkleProof"] = 3] = "MerkleProof";
        CellType2[CellType2["MerkleUpdate"] = 4] = "MerkleUpdate";
      })(CellType = exports.CellType || (exports.CellType = {}));
    }
  });

  // node_modules/ton-core/dist/dict/parseDict.js
  var require_parseDict = __commonJS({
    "node_modules/ton-core/dist/dict/parseDict.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseDict = void 0;
      function readUnaryLength(slice2) {
        let res = 0;
        while (slice2.loadBit()) {
          res++;
        }
        return res;
      }
      function doParse(prefix, slice2, n, res, extractor) {
        let lb0 = slice2.loadBit() ? 1 : 0;
        let prefixLength = 0;
        let pp = prefix;
        if (lb0 === 0) {
          prefixLength = readUnaryLength(slice2);
          for (let i = 0; i < prefixLength; i++) {
            pp += slice2.loadBit() ? "1" : "0";
          }
        } else {
          let lb1 = slice2.loadBit() ? 1 : 0;
          if (lb1 === 0) {
            prefixLength = slice2.loadUint(Math.ceil(Math.log2(n + 1)));
            for (let i = 0; i < prefixLength; i++) {
              pp += slice2.loadBit() ? "1" : "0";
            }
          } else {
            let bit = slice2.loadBit() ? "1" : "0";
            prefixLength = slice2.loadUint(Math.ceil(Math.log2(n + 1)));
            for (let i = 0; i < prefixLength; i++) {
              pp += bit;
            }
          }
        }
        if (n - prefixLength === 0) {
          res.set(BigInt("0b" + pp), extractor(slice2));
        } else {
          let left = slice2.loadRef();
          let right = slice2.loadRef();
          if (!left.isExotic) {
            doParse(pp + "0", left.beginParse(), n - prefixLength - 1, res, extractor);
          }
          if (!right.isExotic) {
            doParse(pp + "1", right.beginParse(), n - prefixLength - 1, res, extractor);
          }
        }
      }
      function parseDict(sc, keySize, extractor) {
        let res = /* @__PURE__ */ new Map();
        if (sc) {
          doParse("", sc, keySize, res, extractor);
        }
        return res;
      }
      exports.parseDict = parseDict;
    }
  });

  // node_modules/ton-core/dist/dict/utils/findCommonPrefix.js
  var require_findCommonPrefix = __commonJS({
    "node_modules/ton-core/dist/dict/utils/findCommonPrefix.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.findCommonPrefix = void 0;
      function findCommonPrefix(src) {
        if (src.length === 0) {
          return "";
        }
        if (src.length === 1) {
          return src[0];
        }
        const sorted = [...src].sort();
        let size = 0;
        for (let i = 0; i < sorted[0].length; i++) {
          if (sorted[0][i] !== sorted[sorted.length - 1][i]) {
            break;
          }
          size++;
        }
        return src[0].slice(0, size);
      }
      exports.findCommonPrefix = findCommonPrefix;
    }
  });

  // node_modules/ton-core/dist/dict/serializeDict.js
  var require_serializeDict = __commonJS({
    "node_modules/ton-core/dist/dict/serializeDict.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.serializeDict = exports.detectLabelType = exports.writeLabelSame = exports.writeLabelLong = exports.writeLabelShort = exports.buildTree = void 0;
      var Builder_1 = require_Builder();
      var findCommonPrefix_1 = require_findCommonPrefix();
      function pad(src, size) {
        while (src.length < size) {
          src = "0" + src;
        }
        return src;
      }
      function removePrefixMap(src, length) {
        if (length === 0) {
          return src;
        } else {
          let res = /* @__PURE__ */ new Map();
          for (let k of src.keys()) {
            let d = src.get(k);
            res.set(k.slice(length), d);
          }
          return res;
        }
      }
      function forkMap(src) {
        if (src.size === 0) {
          throw Error("Internal inconsistency");
        }
        let left = /* @__PURE__ */ new Map();
        let right = /* @__PURE__ */ new Map();
        for (let k of src.keys()) {
          let d = src.get(k);
          if (k.startsWith("0")) {
            left.set(k.substr(1), d);
          } else {
            right.set(k.substr(1), d);
          }
        }
        if (left.size === 0) {
          throw Error("Internal inconsistency. Left emtpy.");
        }
        if (right.size === 0) {
          throw Error("Internal inconsistency. Right emtpy.");
        }
        return { left, right };
      }
      function buildNode(src) {
        if (src.size === 0) {
          throw Error("Internal inconsistency");
        }
        if (src.size === 1) {
          return { type: "leaf", value: Array.from(src.values())[0] };
        }
        let { left, right } = forkMap(src);
        return {
          type: "fork",
          left: buildEdge(left),
          right: buildEdge(right)
        };
      }
      function buildEdge(src) {
        if (src.size === 0) {
          throw Error("Internal inconsistency");
        }
        const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src.keys()));
        return { label, node: buildNode(removePrefixMap(src, label.length)) };
      }
      function buildTree(src, keyLength) {
        let converted = /* @__PURE__ */ new Map();
        for (let k of Array.from(src.keys())) {
          const padded = pad(k.toString(2), keyLength);
          converted.set(padded, src.get(k));
        }
        return buildEdge(converted);
      }
      exports.buildTree = buildTree;
      function writeLabelShort(src, to) {
        to.storeBit(0);
        for (let i = 0; i < src.length; i++) {
          to.storeBit(1);
        }
        to.storeBit(0);
        for (let i = 0; i < src.length; i++) {
          to.storeBit(src[i] === "1");
        }
        return to;
      }
      exports.writeLabelShort = writeLabelShort;
      function labelShortLength(src) {
        return 1 + src.length + 1 + src.length;
      }
      function writeLabelLong(src, keyLength, to) {
        to.storeBit(1);
        to.storeBit(0);
        let length = Math.ceil(Math.log2(keyLength + 1));
        to.storeUint(src.length, length);
        for (let i = 0; i < src.length; i++) {
          to.storeBit(src[i] === "1");
        }
        return to;
      }
      exports.writeLabelLong = writeLabelLong;
      function labelLongLength(src, keyLength) {
        return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src.length;
      }
      function writeLabelSame(value, length, keyLength, to) {
        to.storeBit(1);
        to.storeBit(1);
        to.storeBit(value);
        let lenLen = Math.ceil(Math.log2(keyLength + 1));
        to.storeUint(length, lenLen);
      }
      exports.writeLabelSame = writeLabelSame;
      function labelSameLength(keyLength) {
        return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));
      }
      function isSame(src) {
        if (src.length === 0 || src.length === 1) {
          return true;
        }
        for (let i = 1; i < src.length; i++) {
          if (src[i] !== src[0]) {
            return false;
          }
        }
        return true;
      }
      function detectLabelType(src, keyLength) {
        let kind = "short";
        let kindLength = labelShortLength(src);
        let longLength = labelLongLength(src, keyLength);
        if (longLength < kindLength) {
          kindLength = longLength;
          kind = "long";
        }
        if (isSame(src)) {
          let sameLength = labelSameLength(keyLength);
          if (sameLength < kindLength) {
            kindLength = sameLength;
            kind = "same";
          }
        }
        return kind;
      }
      exports.detectLabelType = detectLabelType;
      function writeLabel(src, keyLength, to) {
        let type = detectLabelType(src, keyLength);
        if (type === "short") {
          writeLabelShort(src, to);
        }
        if (type === "long") {
          writeLabelLong(src, keyLength, to);
        }
        if (type === "same") {
          writeLabelSame(src[0] === "1", src.length, keyLength, to);
        }
      }
      function writeNode(src, keyLength, serializer, to) {
        if (src.type === "leaf") {
          serializer(src.value, to);
        }
        if (src.type === "fork") {
          const leftCell = (0, Builder_1.beginCell)();
          const rightCell = (0, Builder_1.beginCell)();
          writeEdge(src.left, keyLength - 1, serializer, leftCell);
          writeEdge(src.right, keyLength - 1, serializer, rightCell);
          to.storeRef(leftCell);
          to.storeRef(rightCell);
        }
      }
      function writeEdge(src, keyLength, serializer, to) {
        writeLabel(src.label, keyLength, to);
        writeNode(src.node, keyLength - src.label.length, serializer, to);
      }
      function serializeDict(src, keyLength, serializer, to) {
        const tree = buildTree(src, keyLength);
        writeEdge(tree, keyLength, serializer, to);
      }
      exports.serializeDict = serializeDict;
    }
  });

  // node_modules/ton-core/dist/dict/utils/internalKeySerializer.js
  var require_internalKeySerializer = __commonJS({
    "node_modules/ton-core/dist/dict/utils/internalKeySerializer.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.deserializeInternalKey = exports.serializeInternalKey = void 0;
      var Address_1 = require_Address();
      function serializeInternalKey(value) {
        if (typeof value === "number") {
          if (!Number.isSafeInteger(value)) {
            throw Error("Invalid key type: not a safe integer: " + value);
          }
          return "n:" + value.toString(10);
        } else if (typeof value === "bigint") {
          return "b:" + value.toString(10);
        } else if (Address_1.Address.isAddress(value)) {
          return "a:" + value.toString();
        } else if (Buffer2.isBuffer(value)) {
          return "f:" + value.toString("hex");
        } else {
          throw Error("Invalid key type");
        }
      }
      exports.serializeInternalKey = serializeInternalKey;
      function deserializeInternalKey(value) {
        let k = value.slice(0, 2);
        let v = value.slice(2);
        if (k === "n:") {
          return parseInt(v, 10);
        } else if (k === "b:") {
          return BigInt(v);
        } else if (k === "a:") {
          return Address_1.Address.parse(v);
        } else if (k === "f:") {
          return Buffer2.from(v, "hex");
        }
        throw Error("Invalid key type: " + k);
      }
      exports.deserializeInternalKey = deserializeInternalKey;
    }
  });

  // node_modules/ton-core/dist/dict/Dictionary.js
  var require_Dictionary = __commonJS({
    "node_modules/ton-core/dist/dict/Dictionary.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Dictionary = void 0;
      var Address_1 = require_Address();
      var Builder_1 = require_Builder();
      var Cell_1 = require_Cell();
      var parseDict_1 = require_parseDict();
      var serializeDict_1 = require_serializeDict();
      var internalKeySerializer_1 = require_internalKeySerializer();
      var Dictionary = class {
        /**
         * Create an empty map
         * @param key key type
         * @param value value type
         * @returns Dictionary<K, V>
         */
        static empty(key, value) {
          if (key && value) {
            return new Dictionary(/* @__PURE__ */ new Map(), key, value);
          } else {
            return new Dictionary(/* @__PURE__ */ new Map(), null, null);
          }
        }
        /**
         * Load dictionary from slice
         * @param key key description
         * @param value value description
         * @param src slice
         * @returns Dictionary<K, V>
         */
        static load(key, value, sc) {
          let slice2;
          if (sc instanceof Cell_1.Cell) {
            if (sc.isExotic) {
              return Dictionary.empty(key, value);
            }
            slice2 = sc.beginParse();
          } else {
            slice2 = sc;
          }
          let cell = slice2.loadMaybeRef();
          if (cell && !cell.isExotic) {
            return Dictionary.loadDirect(key, value, cell.beginParse());
          } else {
            return Dictionary.empty(key, value);
          }
        }
        /**
         * Low level method for rare dictionaries from system contracts.
         * Loads dictionary from slice directly without going to the ref.
         *
         * @param key key description
         * @param value value description
         * @param sc slice
         * @returns Dictionary<K, V>
         */
        static loadDirect(key, value, sc) {
          if (!sc) {
            return Dictionary.empty(key, value);
          }
          let slice2;
          if (sc instanceof Cell_1.Cell) {
            slice2 = sc.beginParse();
          } else {
            slice2 = sc;
          }
          let values = (0, parseDict_1.parseDict)(slice2, key.bits, value.parse);
          let prepare = /* @__PURE__ */ new Map();
          for (let [k, v] of values) {
            prepare.set((0, internalKeySerializer_1.serializeInternalKey)(key.parse(k)), v);
          }
          return new Dictionary(prepare, key, value);
        }
        constructor(values, key, value) {
          this._key = key;
          this._value = value;
          this._map = values;
        }
        get size() {
          return this._map.size;
        }
        get(key) {
          return this._map.get((0, internalKeySerializer_1.serializeInternalKey)(key));
        }
        has(key) {
          return this._map.has((0, internalKeySerializer_1.serializeInternalKey)(key));
        }
        set(key, value) {
          this._map.set((0, internalKeySerializer_1.serializeInternalKey)(key), value);
          return this;
        }
        delete(key) {
          const k = (0, internalKeySerializer_1.serializeInternalKey)(key);
          return this._map.delete(k);
        }
        clear() {
          this._map.clear();
        }
        *[Symbol.iterator]() {
          for (const [k, v] of this._map) {
            const key = (0, internalKeySerializer_1.deserializeInternalKey)(k);
            yield [key, v];
          }
        }
        keys() {
          return Array.from(this._map.keys()).map((v) => (0, internalKeySerializer_1.deserializeInternalKey)(v));
        }
        values() {
          return Array.from(this._map.values());
        }
        store(builder, key, value) {
          if (this._map.size === 0) {
            builder.storeBit(0);
          } else {
            let resolvedKey = this._key;
            if (key !== null && key !== void 0) {
              resolvedKey = key;
            }
            let resolvedValue = this._value;
            if (value !== null && value !== void 0) {
              resolvedValue = value;
            }
            if (!resolvedKey) {
              throw Error("Key serializer is not defined");
            }
            if (!resolvedValue) {
              throw Error("Value serializer is not defined");
            }
            let prepared = /* @__PURE__ */ new Map();
            for (const [k, v] of this._map) {
              prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);
            }
            builder.storeBit(1);
            let dd = (0, Builder_1.beginCell)();
            (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, dd);
            builder.storeRef(dd.endCell());
          }
        }
        storeDirect(builder, key, value) {
          if (this._map.size === 0) {
            throw Error("Cannot store empty dictionary directly");
          }
          let resolvedKey = this._key;
          if (key !== null && key !== void 0) {
            resolvedKey = key;
          }
          let resolvedValue = this._value;
          if (value !== null && value !== void 0) {
            resolvedValue = value;
          }
          if (!resolvedKey) {
            throw Error("Key serializer is not defined");
          }
          if (!resolvedValue) {
            throw Error("Value serializer is not defined");
          }
          let prepared = /* @__PURE__ */ new Map();
          for (const [k, v] of this._map) {
            prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);
          }
          (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, builder);
        }
      };
      exports.Dictionary = Dictionary;
      Dictionary.Keys = {
        /**
         * Standard address key
         * @returns DictionaryKey<Address>
         */
        Address: () => {
          return createAddressKey();
        },
        /**
         * Create standard big integer key
         * @param bits number of bits
         * @returns DictionaryKey<bigint>
         */
        BigInt: (bits) => {
          return createBigIntKey(bits);
        },
        /**
         * Create integer key
         * @param bits bits of integer
         * @returns DictionaryKey<number>
         */
        Int: (bits) => {
          return createIntKey(bits);
        },
        /**
         * Create standard unsigned big integer key
         * @param bits number of bits
         * @returns DictionaryKey<bigint>
         */
        BigUint: (bits) => {
          return createBigUintKey(bits);
        },
        /**
         * Create standard unsigned integer key
         * @param bits number of bits
         * @returns DictionaryKey<number>
         */
        Uint: (bits) => {
          return createUintKey(bits);
        },
        /**
         * Create standard buffer key
         * @param bytes number of bytes of a buffer
         * @returns DictionaryKey<Buffer>
         */
        Buffer: (bytes) => {
          return createBufferKey(bytes);
        }
      };
      Dictionary.Values = {
        /**
         * Create standard integer value
         * @returns DictionaryValue<bigint>
         */
        BigInt: (bits) => {
          return createBigIntValue(bits);
        },
        /**
         * Create standard integer value
         * @returns DictionaryValue<number>
         */
        Int: (bits) => {
          return createIntValue(bits);
        },
        /**
         * Create big var int
         * @param bits nubmer of header bits
         * @returns DictionaryValue<bigint>
         */
        BigVarInt: (bits) => {
          return createBigVarIntValue(bits);
        },
        /**
         * Create standard unsigned integer value
         * @param bits number of bits
         * @returns DictionaryValue<bigint>
         */
        BigUint: (bits) => {
          return createBigUintValue(bits);
        },
        /**
         * Create standard unsigned integer value
         * @param bits number of bits
         * @returns DictionaryValue<bigint>
         */
        Uint: (bits) => {
          return createUintValue(bits);
        },
        /**
         * Create big var int
         * @param bits nubmer of header bits
         * @returns DictionaryValue<bigint>
         */
        BigVarUint: (bits) => {
          return createBigVarUintValue(bits);
        },
        /**
         * Create standard boolean value
         * @returns DictionaryValue<boolean>
         */
        Bool: () => {
          return createBooleanValue();
        },
        /**
         * Create standard address value
         * @returns DictionaryValue<Address>
         */
        Address: () => {
          return createAddressValue();
        },
        /**
         * Create standard cell value
         * @returns DictionaryValue<Cell>
         */
        Cell: () => {
          return createCellValue();
        },
        /**
         * Create Builder value
         * @param bytes number of bytes of a buffer
         * @returns DictionaryValue<Builder>
         */
        Buffer: (bytes) => {
          return createBufferValue(bytes);
        },
        /**
         * Create dictionary value
         * @param key
         * @param value
         */
        Dictionary: (key, value) => {
          return createDictionaryValue(key, value);
        }
      };
      function createAddressKey() {
        return {
          bits: 267,
          serialize: (src) => {
            if (!Address_1.Address.isAddress(src)) {
              throw Error("Key is not an address");
            }
            return (0, Builder_1.beginCell)().storeAddress(src).endCell().beginParse().preloadUintBig(267);
          },
          parse: (src) => {
            return (0, Builder_1.beginCell)().storeUint(src, 267).endCell().beginParse().loadAddress();
          }
        };
      }
      function createBigIntKey(bits) {
        return {
          bits,
          serialize: (src) => {
            if (typeof src !== "bigint") {
              throw Error("Key is not a bigint");
            }
            return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
          },
          parse: (src) => {
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadIntBig(bits);
          }
        };
      }
      function createIntKey(bits) {
        return {
          bits,
          serialize: (src) => {
            if (typeof src !== "number") {
              throw Error("Key is not a number");
            }
            if (!Number.isSafeInteger(src)) {
              throw Error("Key is not a safe integer: " + src);
            }
            return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
          },
          parse: (src) => {
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadInt(bits);
          }
        };
      }
      function createBigUintKey(bits) {
        return {
          bits,
          serialize: (src) => {
            if (typeof src !== "bigint") {
              throw Error("Key is not a bigint");
            }
            if (src < 0) {
              throw Error("Key is negative: " + src);
            }
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
          },
          parse: (src) => {
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
          }
        };
      }
      function createUintKey(bits) {
        return {
          bits,
          serialize: (src) => {
            if (typeof src !== "number") {
              throw Error("Key is not a number");
            }
            if (!Number.isSafeInteger(src)) {
              throw Error("Key is not a safe integer: " + src);
            }
            if (src < 0) {
              throw Error("Key is negative: " + src);
            }
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
          },
          parse: (src) => {
            return Number((0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUint(bits));
          }
        };
      }
      function createBufferKey(bytes) {
        return {
          bits: bytes * 8,
          serialize: (src) => {
            if (!Buffer2.isBuffer(src)) {
              throw Error("Key is not a buffer");
            }
            return (0, Builder_1.beginCell)().storeBuffer(src).endCell().beginParse().loadUintBig(bytes * 8);
          },
          parse: (src) => {
            return (0, Builder_1.beginCell)().storeUint(src, bytes * 8).endCell().beginParse().loadBuffer(bytes);
          }
        };
      }
      function createIntValue(bits) {
        return {
          serialize: (src, buidler) => {
            buidler.storeInt(src, bits);
          },
          parse: (src) => {
            return src.loadInt(bits);
          }
        };
      }
      function createBigIntValue(bits) {
        return {
          serialize: (src, buidler) => {
            buidler.storeInt(src, bits);
          },
          parse: (src) => {
            return src.loadIntBig(bits);
          }
        };
      }
      function createBigVarIntValue(bits) {
        return {
          serialize: (src, buidler) => {
            buidler.storeVarInt(src, bits);
          },
          parse: (src) => {
            return src.loadVarIntBig(bits);
          }
        };
      }
      function createBigVarUintValue(bits) {
        return {
          serialize: (src, buidler) => {
            buidler.storeVarUint(src, bits);
          },
          parse: (src) => {
            return src.loadVarUintBig(bits);
          }
        };
      }
      function createUintValue(bits) {
        return {
          serialize: (src, buidler) => {
            buidler.storeUint(src, bits);
          },
          parse: (src) => {
            return src.loadUint(bits);
          }
        };
      }
      function createBigUintValue(bits) {
        return {
          serialize: (src, buidler) => {
            buidler.storeUint(src, bits);
          },
          parse: (src) => {
            return src.loadUintBig(bits);
          }
        };
      }
      function createBooleanValue() {
        return {
          serialize: (src, buidler) => {
            buidler.storeBit(src);
          },
          parse: (src) => {
            return src.loadBit();
          }
        };
      }
      function createAddressValue() {
        return {
          serialize: (src, buidler) => {
            buidler.storeAddress(src);
          },
          parse: (src) => {
            return src.loadAddress();
          }
        };
      }
      function createCellValue() {
        return {
          serialize: (src, buidler) => {
            buidler.storeRef(src);
          },
          parse: (src) => {
            return src.loadRef();
          }
        };
      }
      function createDictionaryValue(key, value) {
        return {
          serialize: (src, buidler) => {
            src.store(buidler);
          },
          parse: (src) => {
            return Dictionary.load(key, value, src);
          }
        };
      }
      function createBufferValue(size) {
        return {
          serialize: (src, buidler) => {
            if (src.length !== size) {
              throw Error("Invalid buffer size");
            }
            buidler.storeBuffer(src);
          },
          parse: (src) => {
            return src.loadBuffer(size);
          }
        };
      }
    }
  });

  // node_modules/ton-core/dist/boc/utils/strings.js
  var require_strings = __commonJS({
    "node_modules/ton-core/dist/boc/utils/strings.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.writeString = exports.stringToCell = exports.readString = void 0;
      var Builder_1 = require_Builder();
      function readBuffer(slice2) {
        if (slice2.remainingBits % 8 !== 0) {
          throw new Error(`Invalid string length: ${slice2.remainingBits}`);
        }
        if (slice2.remainingRefs !== 0 && slice2.remainingRefs !== 1) {
          throw new Error(`invalid number of refs: ${slice2.remainingRefs}`);
        }
        if (slice2.remainingRefs === 1 && 1023 - slice2.remainingBits > 7) {
          throw new Error(`invalid string length: ${slice2.remainingBits / 8}`);
        }
        let res;
        if (slice2.remainingBits === 0) {
          res = Buffer2.alloc(0);
        } else {
          res = slice2.loadBuffer(slice2.remainingBits / 8);
        }
        if (slice2.remainingRefs === 1) {
          res = Buffer2.concat([res, readBuffer(slice2.loadRef().beginParse())]);
        }
        return res;
      }
      function readString(slice2) {
        return readBuffer(slice2).toString();
      }
      exports.readString = readString;
      function writeBuffer(src, builder) {
        if (src.length > 0) {
          let bytes = Math.floor(builder.availableBits / 8);
          if (src.length > bytes) {
            let a = src.subarray(0, bytes);
            let t = src.subarray(bytes);
            builder = builder.storeBuffer(a);
            let bb = (0, Builder_1.beginCell)();
            writeBuffer(t, bb);
            builder = builder.storeRef(bb.endCell());
          } else {
            builder = builder.storeBuffer(src);
          }
        }
      }
      function stringToCell(src) {
        let builder = (0, Builder_1.beginCell)();
        writeBuffer(Buffer2.from(src), builder);
        return builder.endCell();
      }
      exports.stringToCell = stringToCell;
      function writeString(src, builder) {
        writeBuffer(Buffer2.from(src), builder);
      }
      exports.writeString = writeString;
    }
  });

  // node_modules/ton-core/dist/boc/Slice.js
  var require_Slice = __commonJS({
    "node_modules/ton-core/dist/boc/Slice.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __importDefault2 = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Slice = void 0;
      var symbol_inspect_1 = __importDefault2(require_symbol());
      var Dictionary_1 = require_Dictionary();
      var Builder_1 = require_Builder();
      var strings_1 = require_strings();
      var Slice = class {
        constructor(reader, refs) {
          this[_a] = () => this.toString();
          this._reader = reader.clone();
          this._refs = [...refs];
        }
        /**
         * Get remaining bits
         */
        get remainingBits() {
          return this._reader.remaining;
        }
        /**
         * Get remaining refs
         */
        get remainingRefs() {
          return this._refs.length;
        }
        /**
         * Skip bits
         * @param bits
         */
        skip(bits) {
          this._reader.skip(bits);
          return this;
        }
        /**
         * Load a single bit
         * @returns true or false depending on the bit value
         */
        loadBit() {
          return this._reader.loadBit();
        }
        /**
         * Preload a signle bit
         * @returns true or false depending on the bit value
         */
        preloadBit() {
          return this._reader.preloadBit();
        }
        /**
         * Load a boolean
         * @returns true or false depending on the bit value
         */
        loadBoolean() {
          return this.loadBit();
        }
        /**
         * Load maybe boolean
         * @returns true or false depending on the bit value or null
         */
        loadMaybeBoolean() {
          if (this.loadBit()) {
            return this.loadBoolean();
          } else {
            return null;
          }
        }
        /**
         * Load bits as a new BitString
         * @param bits number of bits to read
         * @returns new BitString
         */
        loadBits(bits) {
          return this._reader.loadBits(bits);
        }
        /**
         * Preload bits as a new BitString
         * @param bits number of bits to read
         * @returns new BitString
         */
        preloadBits(bits) {
          return this._reader.preloadBits(bits);
        }
        /**
         * Load uint
         * @param bits number of bits to read
         * @returns uint value
         */
        loadUint(bits) {
          return this._reader.loadUint(bits);
        }
        /**
         * Load uint
         * @param bits number of bits to read
         * @returns uint value
         */
        loadUintBig(bits) {
          return this._reader.loadUintBig(bits);
        }
        /**
         * Preload uint
         * @param bits number of bits to read
         * @returns uint value
         */
        preloadUint(bits) {
          return this._reader.preloadUint(bits);
        }
        /**
         * Preload uint
         * @param bits number of bits to read
         * @returns uint value
         */
        preloadUintBig(bits) {
          return this._reader.preloadUintBig(bits);
        }
        /**
         * Load maybe uint
         * @param bits number of bits to read
         * @returns uint value or null
         */
        loadMaybeUint(bits) {
          if (this.loadBit()) {
            return this.loadUint(bits);
          } else {
            return null;
          }
        }
        /**
         * Load maybe uint
         * @param bits number of bits to read
         * @returns uint value or null
         */
        loadMaybeUintBig(bits) {
          if (this.loadBit()) {
            return this.loadUintBig(bits);
          } else {
            return null;
          }
        }
        /**
         * Load int
         * @param bits number of bits to read
         * @returns int value
         */
        loadInt(bits) {
          return this._reader.loadInt(bits);
        }
        /**
         * Load int
         * @param bits number of bits to read
         * @returns int value
         */
        loadIntBig(bits) {
          return this._reader.loadIntBig(bits);
        }
        /**
         * Preload int
         * @param bits number of bits to read
         * @returns int value
         */
        preloadInt(bits) {
          return this._reader.preloadInt(bits);
        }
        /**
         * Preload int
         * @param bits number of bits to read
         * @returns int value
         */
        preloadIntBig(bits) {
          return this._reader.preloadIntBig(bits);
        }
        /**
         * Load maybe uint
         * @param bits number of bits to read
         * @returns uint value or null
         */
        loadMaybeInt(bits) {
          if (this.loadBit()) {
            return this.loadInt(bits);
          } else {
            return null;
          }
        }
        /**
         * Load maybe uint
         * @param bits number of bits to read
         * @returns uint value or null
         */
        loadMaybeIntBig(bits) {
          if (this.loadBit()) {
            return this.loadIntBig(bits);
          } else {
            return null;
          }
        }
        /**
         * Load varuint
         * @param bits number of bits to read in header
         * @returns varuint value
         */
        loadVarUint(bits) {
          return this._reader.loadVarUint(bits);
        }
        /**
         * Load varuint
         * @param bits number of bits to read in header
         * @returns varuint value
         */
        loadVarUintBig(bits) {
          return this._reader.loadVarUintBig(bits);
        }
        /**
         * Preload varuint
         * @param bits number of bits to read in header
         * @returns varuint value
         */
        preloadVarUint(bits) {
          return this._reader.preloadVarUint(bits);
        }
        /**
         * Preload varuint
         * @param bits number of bits to read in header
         * @returns varuint value
         */
        preloadVarUintBig(bits) {
          return this._reader.preloadVarUintBig(bits);
        }
        /**
         * Load varint
         * @param bits number of bits to read in header
         * @returns varint value
         */
        loadVarInt(bits) {
          return this._reader.loadVarInt(bits);
        }
        /**
         * Load varint
         * @param bits number of bits to read in header
         * @returns varint value
         */
        loadVarIntBig(bits) {
          return this._reader.loadVarIntBig(bits);
        }
        /**
         * Preload varint
         * @param bits number of bits to read in header
         * @returns varint value
         */
        preloadVarInt(bits) {
          return this._reader.preloadVarInt(bits);
        }
        /**
         * Preload varint
         * @param bits number of bits to read in header
         * @returns varint value
         */
        preloadVarIntBig(bits) {
          return this._reader.preloadVarIntBig(bits);
        }
        /**
         * Load coins
         * @returns coins value
         */
        loadCoins() {
          return this._reader.loadCoins();
        }
        /**
         * Preload coins
         * @returns coins value
         */
        preloadCoins() {
          return this._reader.preloadCoins();
        }
        /**
         * Load maybe coins
         * @returns coins value or null
         */
        loadMaybeCoins() {
          if (this._reader.loadBit()) {
            return this._reader.loadCoins();
          } else {
            return null;
          }
        }
        /**
         * Load internal Address
         * @returns Address
         */
        loadAddress() {
          return this._reader.loadAddress();
        }
        /**
         * Load optional internal Address
         * @returns Address or null
         */
        loadMaybeAddress() {
          return this._reader.loadMaybeAddress();
        }
        /**
         * Load external address
         * @returns ExternalAddress
         */
        loadExternalAddress() {
          return this._reader.loadExternalAddress();
        }
        /**
         * Load optional external address
         * @returns ExternalAddress or null
         */
        loadMaybeExternalAddress() {
          return this._reader.loadMaybeExternalAddress();
        }
        /**
         * Load address
         * @returns Address, ExternalAddress or null
         */
        loadAddressAny() {
          return this._reader.loadAddressAny();
        }
        /**
         * Load reference
         * @returns Cell
         */
        loadRef() {
          if (this._refs.length === 0) {
            throw new Error("No more references");
          }
          return this._refs.shift();
        }
        /**
         * Preload reference
         * @returns Cell
         */
        preloadRef() {
          if (this._refs.length === 0) {
            throw new Error("No more references");
          }
          return this._refs[0];
        }
        /**
         * Load optional reference
         * @returns Cell or null
         */
        loadMaybeRef() {
          if (this.loadBit()) {
            return this.loadRef();
          } else {
            return null;
          }
        }
        /**
         * Preload optional reference
         * @returns Cell or null
         */
        preloadMaybeRef() {
          if (this.preloadBit()) {
            return this.preloadRef();
          } else {
            return null;
          }
        }
        /**
         * Load byte buffer
         * @param bytes number of bytes to load
         * @returns Buffer
         */
        loadBuffer(bytes) {
          return this._reader.loadBuffer(bytes);
        }
        /**
         * Load byte buffer
         * @param bytes number of bytes to load
         * @returns Buffer
         */
        preloadBuffer(bytes) {
          return this._reader.preloadBuffer(bytes);
        }
        /**
         * Load string tail
         */
        loadStringTail() {
          return (0, strings_1.readString)(this);
        }
        /**
         * Load maybe string tail
         * @returns string or null
         */
        loadMaybeStringTail() {
          if (this.loadBit()) {
            return (0, strings_1.readString)(this);
          } else {
            return null;
          }
        }
        /**
         * Load string tail from ref
         * @returns string
         */
        loadStringRefTail() {
          return (0, strings_1.readString)(this.loadRef().beginParse());
        }
        /**
         * Load maybe string tail from ref
         * @returns string or null
         */
        loadMaybeStringRefTail() {
          const ref = this.loadMaybeRef();
          if (ref) {
            return (0, strings_1.readString)(ref.beginParse());
          } else {
            return null;
          }
        }
        /**
         * Loads dictionary
         * @param key key description
         * @param value value description
         * @returns Dictionary<K, V>
         */
        loadDict(key, value) {
          return Dictionary_1.Dictionary.load(key, value, this);
        }
        /**
         * Loads dictionary directly from current slice
         * @param key key description
         * @param value value description
         * @returns Dictionary<K, V>
         */
        loadDictDirect(key, value) {
          return Dictionary_1.Dictionary.loadDirect(key, value, this);
        }
        /**
         * Checks if slice is empty
         */
        endParse() {
          if (this.remainingBits > 0 || this.remainingRefs > 0) {
            throw new Error("Slice is not empty");
          }
        }
        /**
         * Convert slice to cell
         */
        asCell() {
          return (0, Builder_1.beginCell)().storeSlice(this).endCell();
        }
        /**
         *
         * @returns
         */
        asBuilder() {
          return (0, Builder_1.beginCell)().storeSlice(this);
        }
        /**
         * Clone slice
         * @returns cloned slice
         */
        clone() {
          return new Slice(this._reader, this._refs);
        }
        /**
         * Print slice as string by converting it to cell
         * @returns string
         */
        toString() {
          return this.asCell().toString();
        }
      };
      exports.Slice = Slice;
      _a = symbol_inspect_1.default;
    }
  });

  // node_modules/ton-core/dist/boc/BitReader.js
  var require_BitReader = __commonJS({
    "node_modules/ton-core/dist/boc/BitReader.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BitReader = void 0;
      var Address_1 = require_Address();
      var ExternalAddress_1 = require_ExternalAddress();
      var BitReader = class {
        constructor(bits, offset = 0) {
          this._checkpoints = [];
          this._bits = bits;
          this._offset = offset;
        }
        /**
         * Number of bits remaining
         */
        get remaining() {
          return this._bits.length - this._offset;
        }
        /**
         * Skip bits
         * @param bits number of bits to skip
         */
        skip(bits) {
          if (bits < 0 || this._offset + bits > this._bits.length) {
            throw new Error(`Index ${this._offset + bits} is out of bounds`);
          }
          this._offset += bits;
        }
        /**
         * Reset to the beginning or latest checkpoint
         */
        reset() {
          if (this._checkpoints.length > 0) {
            this._offset = this._checkpoints.pop();
          } else {
            this._offset = 0;
          }
        }
        /**
         * Save checkpoint
         */
        save() {
          this._checkpoints.push(this._offset);
        }
        /**
         * Load a single bit
         * @returns true if the bit is set, false otherwise
         */
        loadBit() {
          let r = this._bits.at(this._offset);
          this._offset++;
          return r;
        }
        /**
         * Preload bit
         * @returns true if the bit is set, false otherwise
         */
        preloadBit() {
          return this._bits.at(this._offset);
        }
        /**
         * Load bit string
         * @param bits number of bits to read
         * @returns new bitstring
         */
        loadBits(bits) {
          let r = this._bits.substring(this._offset, bits);
          this._offset += bits;
          return r;
        }
        /**
         * Preload bit string
         * @param bits number of bits to read
         * @returns new bitstring
         */
        preloadBits(bits) {
          return this._bits.substring(this._offset, bits);
        }
        /**
         * Load buffer
         * @param bytes number of bytes
         * @returns new buffer
         */
        loadBuffer(bytes) {
          let buf = this._preloadBuffer(bytes, this._offset);
          this._offset += bytes * 8;
          return buf;
        }
        /**
         * Preload buffer
         * @param bytes number of bytes
         * @returns new buffer
         */
        preloadBuffer(bytes) {
          return this._preloadBuffer(bytes, this._offset);
        }
        /**
         * Load uint value
         * @param bits uint bits
         * @returns read value as number
         */
        loadUint(bits) {
          return Number(this.loadUintBig(bits));
        }
        /**
         * Load uint value as bigint
         * @param bits uint bits
         * @returns read value as bigint
         */
        loadUintBig(bits) {
          let loaded = this.preloadUintBig(bits);
          this._offset += bits;
          return loaded;
        }
        /**
         * Preload uint value
         * @param bits uint bits
         * @returns read value as number
         */
        preloadUint(bits) {
          return Number(this._preloadUint(bits, this._offset));
        }
        /**
         * Preload uint value as bigint
         * @param bits uint bits
         * @returns read value as bigint
         */
        preloadUintBig(bits) {
          return this._preloadUint(bits, this._offset);
        }
        /**
         * Load int value
         * @param bits int bits
         * @returns read value as bigint
         */
        loadInt(bits) {
          let res = this._preloadInt(bits, this._offset);
          this._offset += bits;
          return Number(res);
        }
        /**
         * Load int value as bigint
         * @param bits int bits
         * @returns read value as bigint
         */
        loadIntBig(bits) {
          let res = this._preloadInt(bits, this._offset);
          this._offset += bits;
          return res;
        }
        /**
         * Preload int value
         * @param bits int bits
         * @returns read value as bigint
         */
        preloadInt(bits) {
          return Number(this._preloadInt(bits, this._offset));
        }
        /**
         * Preload int value
         * @param bits int bits
         * @returns read value as bigint
         */
        preloadIntBig(bits) {
          return this._preloadInt(bits, this._offset);
        }
        /**
         * Load varuint value
         * @param bits number of bits to read the size
         * @returns read value as bigint
         */
        loadVarUint(bits) {
          let size = Number(this.loadUint(bits));
          return Number(this.loadUintBig(size * 8));
        }
        /**
         * Load varuint value
         * @param bits number of bits to read the size
         * @returns read value as bigint
         */
        loadVarUintBig(bits) {
          let size = Number(this.loadUint(bits));
          return this.loadUintBig(size * 8);
        }
        /**
         * Preload varuint value
         * @param bits number of bits to read the size
         * @returns read value as bigint
         */
        preloadVarUint(bits) {
          let size = Number(this._preloadUint(bits, this._offset));
          return Number(this._preloadUint(size * 8, this._offset + bits));
        }
        /**
         * Preload varuint value
         * @param bits number of bits to read the size
         * @returns read value as bigint
         */
        preloadVarUintBig(bits) {
          let size = Number(this._preloadUint(bits, this._offset));
          return this._preloadUint(size * 8, this._offset + bits);
        }
        /**
         * Load varint value
         * @param bits number of bits to read the size
         * @returns read value as bigint
         */
        loadVarInt(bits) {
          let size = Number(this.loadUint(bits));
          return Number(this.loadIntBig(size * 8));
        }
        /**
         * Load varint value
         * @param bits number of bits to read the size
         * @returns read value as bigint
         */
        loadVarIntBig(bits) {
          let size = Number(this.loadUint(bits));
          return this.loadIntBig(size * 8);
        }
        /**
         * Preload varint value
         * @param bits number of bits to read the size
         * @returns read value as bigint
         */
        preloadVarInt(bits) {
          let size = Number(this._preloadUint(bits, this._offset));
          return Number(this._preloadInt(size * 8, this._offset + bits));
        }
        /**
         * Preload varint value
         * @param bits number of bits to read the size
         * @returns read value as bigint
         */
        preloadVarIntBig(bits) {
          let size = Number(this._preloadUint(bits, this._offset));
          return this._preloadInt(size * 8, this._offset + bits);
        }
        /**
         * Load coins value
         * @returns read value as bigint
         */
        loadCoins() {
          return this.loadVarUintBig(4);
        }
        /**
         * Preload coins value
         * @returns read value as bigint
         */
        preloadCoins() {
          return this.preloadVarUintBig(4);
        }
        /**
         * Load Address
         * @returns Address
         */
        loadAddress() {
          let type = Number(this._preloadUint(2, this._offset));
          if (type === 2) {
            return this._loadInternalAddress();
          } else {
            throw new Error("Invalid address: " + type);
          }
        }
        /**
         * Load internal address
         * @returns Address or null
         */
        loadMaybeAddress() {
          let type = Number(this._preloadUint(2, this._offset));
          if (type === 0) {
            this._offset += 2;
            return null;
          } else if (type === 2) {
            return this._loadInternalAddress();
          } else {
            throw new Error("Invalid address");
          }
        }
        /**
         * Load external address
         * @returns ExternalAddress
         */
        loadExternalAddress() {
          let type = Number(this._preloadUint(2, this._offset));
          if (type === 1) {
            return this._loadExternalAddress();
          } else {
            throw new Error("Invalid address");
          }
        }
        /**
         * Load external address
         * @returns ExternalAddress or null
         */
        loadMaybeExternalAddress() {
          let type = Number(this._preloadUint(2, this._offset));
          if (type === 0) {
            this._offset += 2;
            return null;
          } else if (type === 1) {
            return this._loadExternalAddress();
          } else {
            throw new Error("Invalid address");
          }
        }
        /**
         * Read address of any type
         * @returns Address or ExternalAddress or null
         */
        loadAddressAny() {
          let type = Number(this._preloadUint(2, this._offset));
          if (type === 0) {
            this._offset += 2;
            return null;
          } else if (type === 2) {
            return this._loadInternalAddress();
          } else if (type === 1) {
            return this._loadExternalAddress();
          } else if (type === 3) {
            throw Error("Unsupported");
          } else {
            throw Error("Unreachable");
          }
        }
        /**
         * Load bit string that was padded to make it byte alligned. Used in BOC serialization
         * @param bytes number of bytes to read
         */
        loadPaddedBits(bits) {
          if (bits % 8 !== 0) {
            throw new Error("Invalid number of bits");
          }
          let length = bits;
          while (true) {
            if (this._bits.at(this._offset + length - 1)) {
              length--;
              break;
            } else {
              length--;
            }
          }
          let r = this._bits.substring(this._offset, length);
          this._offset += bits;
          return r;
        }
        /**
         * Clone BitReader
         */
        clone() {
          return new BitReader(this._bits, this._offset);
        }
        /**
         * Preload int from specific offset
         * @param bits bits to preload
         * @param offset offset to start from
         * @returns read value as bigint
         */
        _preloadInt(bits, offset) {
          if (bits == 0) {
            return 0n;
          }
          let sign = this._bits.at(offset);
          let res = 0n;
          for (let i = 0; i < bits - 1; i++) {
            if (this._bits.at(offset + 1 + i)) {
              res += 1n << BigInt(bits - i - 1 - 1);
            }
          }
          if (sign) {
            res = res - (1n << BigInt(bits - 1));
          }
          return res;
        }
        /**
         * Preload uint from specific offset
         * @param bits bits to preload
         * @param offset offset to start from
         * @returns read value as bigint
         */
        _preloadUint(bits, offset) {
          if (bits == 0) {
            return 0n;
          }
          let res = 0n;
          for (let i = 0; i < bits; i++) {
            if (this._bits.at(offset + i)) {
              res += 1n << BigInt(bits - i - 1);
            }
          }
          return res;
        }
        _preloadBuffer(bytes, offset) {
          let fastBuffer = this._bits.subbuffer(offset, bytes * 8);
          if (fastBuffer) {
            return fastBuffer;
          }
          let buf = Buffer2.alloc(bytes);
          for (let i = 0; i < bytes; i++) {
            buf[i] = Number(this._preloadUint(8, offset + i * 8));
          }
          return buf;
        }
        _loadInternalAddress() {
          let type = Number(this._preloadUint(2, this._offset));
          if (type !== 2) {
            throw Error("Invalid address");
          }
          if (this._preloadUint(1, this._offset + 2) !== 0n) {
            throw Error("Invalid address");
          }
          let wc = Number(this._preloadInt(8, this._offset + 3));
          let hash = this._preloadBuffer(32, this._offset + 11);
          this._offset += 267;
          return new Address_1.Address(wc, hash);
        }
        _loadExternalAddress() {
          let type = Number(this._preloadUint(2, this._offset));
          if (type !== 1) {
            throw Error("Invalid address");
          }
          let bits = Number(this._preloadUint(9, this._offset + 2));
          let value = this._preloadUint(bits, this._offset + 11);
          this._offset += 11 + bits;
          return new ExternalAddress_1.ExternalAddress(value, bits);
        }
      };
      exports.BitReader = BitReader;
    }
  });

  // node_modules/ton-core/dist/boc/cell/exoticMerkleProof.js
  var require_exoticMerkleProof = __commonJS({
    "node_modules/ton-core/dist/boc/cell/exoticMerkleProof.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.exoticMerkleProof = void 0;
      var BitReader_1 = require_BitReader();
      function exoticMerkleProof(bits, refs) {
        const reader = new BitReader_1.BitReader(bits);
        const size = 8 + 256 + 16;
        if (bits.length !== size) {
          throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${bits.length}"`);
        }
        if (refs.length !== 1) {
          throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${refs.length}"`);
        }
        let type = reader.loadUint(8);
        if (type !== 3) {
          throw new Error(`Merkle Proof cell must have type 3, got "${type}"`);
        }
        const proofHash = reader.loadBuffer(32);
        const proofDepth = reader.loadUint(16);
        const refHash = refs[0].hash(0);
        const refDepth = refs[0].depth(0);
        if (proofDepth !== refDepth) {
          throw new Error(`Merkle Proof cell ref depth must be exactly "${proofDepth}", got "${refDepth}"`);
        }
        if (!proofHash.equals(refHash)) {
          throw new Error(`Merkle Proof cell ref hash must be exactly "${proofHash.toString("hex")}", got "${refHash.toString("hex")}"`);
        }
        return {
          proofDepth,
          proofHash
        };
      }
      exports.exoticMerkleProof = exoticMerkleProof;
    }
  });

  // node_modules/ton-core/dist/boc/cell/exoticMerkleUpdate.js
  var require_exoticMerkleUpdate = __commonJS({
    "node_modules/ton-core/dist/boc/cell/exoticMerkleUpdate.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.exoticMerkleUpdate = void 0;
      var BitReader_1 = require_BitReader();
      function exoticMerkleUpdate(bits, refs) {
        const reader = new BitReader_1.BitReader(bits);
        const size = 8 + 2 * (256 + 16);
        if (bits.length !== size) {
          throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${bits.length}"`);
        }
        if (refs.length !== 2) {
          throw new Error(`Merkle Update cell must have exactly 2 refs, got "${refs.length}"`);
        }
        let type = reader.loadUint(8);
        if (type !== 4) {
          throw new Error(`Merkle Update cell type must be exactly 4, got "${type}"`);
        }
        const proofHash1 = reader.loadBuffer(32);
        const proofHash2 = reader.loadBuffer(32);
        const proofDepth1 = reader.loadUint(16);
        const proofDepth2 = reader.loadUint(16);
        if (proofDepth1 !== refs[0].depth(0)) {
          throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth1}", got "${refs[0].depth(0)}"`);
        }
        if (!proofHash1.equals(refs[0].hash(0))) {
          throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash1.toString("hex")}", got "${refs[0].hash(0).toString("hex")}"`);
        }
        if (proofDepth2 !== refs[1].depth(0)) {
          throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth2}", got "${refs[1].depth(0)}"`);
        }
        if (!proofHash2.equals(refs[1].hash(0))) {
          throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash2.toString("hex")}", got "${refs[1].hash(0).toString("hex")}"`);
        }
        return {
          proofDepth1,
          proofDepth2,
          proofHash1,
          proofHash2
        };
      }
      exports.exoticMerkleUpdate = exoticMerkleUpdate;
    }
  });

  // node_modules/ton-core/dist/boc/cell/LevelMask.js
  var require_LevelMask = __commonJS({
    "node_modules/ton-core/dist/boc/cell/LevelMask.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LevelMask = void 0;
      var LevelMask = class {
        constructor(mask = 0) {
          this._mask = 0;
          this._mask = mask;
          this._hashIndex = countSetBits(this._mask);
          this._hashCount = this._hashIndex + 1;
        }
        get value() {
          return this._mask;
        }
        get level() {
          return 32 - Math.clz32(this._mask);
        }
        get hashIndex() {
          return this._hashIndex;
        }
        get hashCount() {
          return this._hashCount;
        }
        apply(level) {
          return new LevelMask(this._mask & (1 << level) - 1);
        }
        isSignificant(level) {
          let res = level === 0 || (this._mask >> level - 1) % 2 !== 0;
          return res;
        }
      };
      exports.LevelMask = LevelMask;
      function countSetBits(n) {
        n = n - (n >> 1 & 1431655765);
        n = (n & 858993459) + (n >> 2 & 858993459);
        return (n + (n >> 4) & 252645135) * 16843009 >> 24;
      }
    }
  });

  // node_modules/ton-core/dist/boc/cell/exoticPruned.js
  var require_exoticPruned = __commonJS({
    "node_modules/ton-core/dist/boc/cell/exoticPruned.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.exoticPruned = void 0;
      var BitReader_1 = require_BitReader();
      var LevelMask_1 = require_LevelMask();
      function exoticPruned(bits, refs) {
        let reader = new BitReader_1.BitReader(bits);
        let type = reader.loadUint(8);
        if (type !== 1) {
          throw new Error(`Pruned branch cell must have type 1, got "${type}"`);
        }
        if (refs.length !== 0) {
          throw new Error(`Pruned Branch cell can't has refs, got "${refs.length}"`);
        }
        let mask;
        if (bits.length === 280) {
          mask = new LevelMask_1.LevelMask(1);
        } else {
          mask = new LevelMask_1.LevelMask(reader.loadUint(8));
          if (mask.level < 1 || mask.level > 3) {
            throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${mask.level}/${mask.value}"`);
          }
          const size = 8 + 8 + mask.apply(mask.level - 1).hashCount * (256 + 16);
          if (bits.length !== size) {
            throw new Error(`Pruned branch cell must have exactly ${size} bits, got "${bits.length}"`);
          }
        }
        let pruned = [];
        let hashes = [];
        let depths = [];
        for (let i = 0; i < mask.level; i++) {
          hashes.push(reader.loadBuffer(32));
        }
        for (let i = 0; i < mask.level; i++) {
          depths.push(reader.loadUint(16));
        }
        for (let i = 0; i < mask.level; i++) {
          pruned.push({
            depth: depths[i],
            hash: hashes[i]
          });
        }
        return {
          mask: mask.value,
          pruned
        };
      }
      exports.exoticPruned = exoticPruned;
    }
  });

  // node_modules/ton-core/dist/boc/cell/resolveExotic.js
  var require_resolveExotic = __commonJS({
    "node_modules/ton-core/dist/boc/cell/resolveExotic.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.resolveExotic = void 0;
      var BitReader_1 = require_BitReader();
      var CellType_1 = require_CellType();
      var exoticMerkleProof_1 = require_exoticMerkleProof();
      var exoticMerkleUpdate_1 = require_exoticMerkleUpdate();
      var exoticPruned_1 = require_exoticPruned();
      var LevelMask_1 = require_LevelMask();
      function resolvePruned(bits, refs) {
        let pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
        let depths = [];
        let hashes = [];
        let mask = new LevelMask_1.LevelMask(pruned.mask);
        for (let i = 0; i < pruned.pruned.length; i++) {
          depths.push(pruned.pruned[i].depth);
          hashes.push(pruned.pruned[i].hash);
        }
        return {
          type: CellType_1.CellType.PrunedBranch,
          depths,
          hashes,
          mask
        };
      }
      function resolveMerkleProof(bits, refs) {
        let merkleProof = (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
        let depths = [];
        let hashes = [];
        let mask = new LevelMask_1.LevelMask(refs[0].level() >> 1);
        return {
          type: CellType_1.CellType.MerkleProof,
          depths,
          hashes,
          mask
        };
      }
      function resolveMerkleUpdate(bits, refs) {
        let merkleUpdate = (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
        let depths = [];
        let hashes = [];
        let mask = new LevelMask_1.LevelMask((refs[0].level() | refs[1].level()) >> 1);
        return {
          type: CellType_1.CellType.MerkleUpdate,
          depths,
          hashes,
          mask
        };
      }
      function resolveExotic(bits, refs) {
        let reader = new BitReader_1.BitReader(bits);
        let type = reader.preloadUint(8);
        if (type === 1) {
          return resolvePruned(bits, refs);
        }
        if (type === 2) {
          throw new Error("Library cell must be loaded automatically");
        }
        if (type === 3) {
          return resolveMerkleProof(bits, refs);
        }
        if (type === 4) {
          return resolveMerkleUpdate(bits, refs);
        }
        throw Error("Invalid exotic cell type: " + type);
      }
      exports.resolveExotic = resolveExotic;
    }
  });

  // node_modules/ton-core/dist/boc/cell/descriptor.js
  var require_descriptor = __commonJS({
    "node_modules/ton-core/dist/boc/cell/descriptor.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getRepr = exports.getBitsDescriptor = exports.getRefsDescriptor = void 0;
      var CellType_1 = require_CellType();
      var paddedBits_1 = require_paddedBits();
      function getRefsDescriptor(refs, level, type) {
        return refs.length + (type !== CellType_1.CellType.Ordinary ? 1 : 0) * 8 + level * 32;
      }
      exports.getRefsDescriptor = getRefsDescriptor;
      function getBitsDescriptor(bits) {
        let len = bits.length;
        return Math.ceil(len / 8) + Math.floor(len / 8);
      }
      exports.getBitsDescriptor = getBitsDescriptor;
      function getRepr(bits, refs, level, type) {
        const bitsLen = Math.ceil(bits.length / 8);
        const repr = Buffer2.alloc(2 + bitsLen + (2 + 32) * refs.length);
        let reprCursor = 0;
        repr[reprCursor++] = getRefsDescriptor(refs, level, type);
        repr[reprCursor++] = getBitsDescriptor(bits);
        (0, paddedBits_1.bitsToPaddedBuffer)(bits).copy(repr, reprCursor);
        reprCursor += bitsLen;
        for (const c of refs) {
          let childDepth;
          if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
            childDepth = c.depth(level + 1);
          } else {
            childDepth = c.depth(level);
          }
          repr[reprCursor++] = Math.floor(childDepth / 256);
          repr[reprCursor++] = childDepth % 256;
        }
        for (const c of refs) {
          let childHash;
          if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
            childHash = c.hash(level + 1);
          } else {
            childHash = c.hash(level);
          }
          childHash.copy(repr, reprCursor);
          reprCursor += 32;
        }
        return repr;
      }
      exports.getRepr = getRepr;
    }
  });

  // node_modules/jssha/dist/sha.js
  var require_sha = __commonJS({
    "node_modules/jssha/dist/sha.js"(exports, module) {
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      !function(n, r) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = r() : "function" == typeof define && define.amd ? define(r) : (n = "undefined" != typeof globalThis ? globalThis : n || self).jsSHA = r();
      }(exports, function() {
        "use strict";
        var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        function r(n2, r2, t2, e2) {
          var i2, o2, u2, f2 = r2 || [0], w2 = (t2 = t2 || 0) >>> 3, s2 = -1 === e2 ? 3 : 0;
          for (i2 = 0; i2 < n2.length; i2 += 1)
            o2 = (u2 = i2 + w2) >>> 2, f2.length <= o2 && f2.push(0), f2[o2] |= n2[i2] << 8 * (s2 + e2 * (u2 % 4));
          return { value: f2, binLen: 8 * n2.length + t2 };
        }
        function t(t2, e2, i2) {
          switch (e2) {
            case "UTF8":
            case "UTF16BE":
            case "UTF16LE":
              break;
            default:
              throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
          }
          switch (t2) {
            case "HEX":
              return function(n2, r2, t3) {
                return function(n3, r3, t4, e3) {
                  var i3, o2, u2, f2;
                  if (0 != n3.length % 2)
                    throw new Error("String of HEX type must be in byte increments");
                  var w2 = r3 || [0], s2 = (t4 = t4 || 0) >>> 3, a2 = -1 === e3 ? 3 : 0;
                  for (i3 = 0; i3 < n3.length; i3 += 2) {
                    if (o2 = parseInt(n3.substr(i3, 2), 16), isNaN(o2))
                      throw new Error("String of HEX type contains invalid characters");
                    for (u2 = (f2 = (i3 >>> 1) + s2) >>> 2; w2.length <= u2; )
                      w2.push(0);
                    w2[u2] |= o2 << 8 * (a2 + e3 * (f2 % 4));
                  }
                  return { value: w2, binLen: 4 * n3.length + t4 };
                }(n2, r2, t3, i2);
              };
            case "TEXT":
              return function(n2, r2, t3) {
                return function(n3, r3, t4, e3, i3) {
                  var o2, u2, f2, w2, s2, a2, h2, c2, v2 = 0, A2 = t4 || [0], E2 = (e3 = e3 || 0) >>> 3;
                  if ("UTF8" === r3)
                    for (h2 = -1 === i3 ? 3 : 0, f2 = 0; f2 < n3.length; f2 += 1)
                      for (u2 = [], 128 > (o2 = n3.charCodeAt(f2)) ? u2.push(o2) : 2048 > o2 ? (u2.push(192 | o2 >>> 6), u2.push(128 | 63 & o2)) : 55296 > o2 || 57344 <= o2 ? u2.push(224 | o2 >>> 12, 128 | o2 >>> 6 & 63, 128 | 63 & o2) : (f2 += 1, o2 = 65536 + ((1023 & o2) << 10 | 1023 & n3.charCodeAt(f2)), u2.push(240 | o2 >>> 18, 128 | o2 >>> 12 & 63, 128 | o2 >>> 6 & 63, 128 | 63 & o2)), w2 = 0; w2 < u2.length; w2 += 1) {
                        for (s2 = (a2 = v2 + E2) >>> 2; A2.length <= s2; )
                          A2.push(0);
                        A2[s2] |= u2[w2] << 8 * (h2 + i3 * (a2 % 4)), v2 += 1;
                      }
                  else
                    for (h2 = -1 === i3 ? 2 : 0, c2 = "UTF16LE" === r3 && 1 !== i3 || "UTF16LE" !== r3 && 1 === i3, f2 = 0; f2 < n3.length; f2 += 1) {
                      for (o2 = n3.charCodeAt(f2), true === c2 && (o2 = (w2 = 255 & o2) << 8 | o2 >>> 8), s2 = (a2 = v2 + E2) >>> 2; A2.length <= s2; )
                        A2.push(0);
                      A2[s2] |= o2 << 8 * (h2 + i3 * (a2 % 4)), v2 += 2;
                    }
                  return { value: A2, binLen: 8 * v2 + e3 };
                }(n2, e2, r2, t3, i2);
              };
            case "B64":
              return function(r2, t3, e3) {
                return function(r3, t4, e4, i3) {
                  var o2, u2, f2, w2, s2, a2, h2 = 0, c2 = t4 || [0], v2 = (e4 = e4 || 0) >>> 3, A2 = -1 === i3 ? 3 : 0, E2 = r3.indexOf("=");
                  if (-1 === r3.search(/^[a-zA-Z0-9=+/]+$/))
                    throw new Error("Invalid character in base-64 string");
                  if (r3 = r3.replace(/=/g, ""), -1 !== E2 && E2 < r3.length)
                    throw new Error("Invalid '=' found in base-64 string");
                  for (o2 = 0; o2 < r3.length; o2 += 4) {
                    for (w2 = r3.substr(o2, 4), f2 = 0, u2 = 0; u2 < w2.length; u2 += 1)
                      f2 |= n.indexOf(w2.charAt(u2)) << 18 - 6 * u2;
                    for (u2 = 0; u2 < w2.length - 1; u2 += 1) {
                      for (s2 = (a2 = h2 + v2) >>> 2; c2.length <= s2; )
                        c2.push(0);
                      c2[s2] |= (f2 >>> 16 - 8 * u2 & 255) << 8 * (A2 + i3 * (a2 % 4)), h2 += 1;
                    }
                  }
                  return { value: c2, binLen: 8 * h2 + e4 };
                }(r2, t3, e3, i2);
              };
            case "BYTES":
              return function(n2, r2, t3) {
                return function(n3, r3, t4, e3) {
                  var i3, o2, u2, f2, w2 = r3 || [0], s2 = (t4 = t4 || 0) >>> 3, a2 = -1 === e3 ? 3 : 0;
                  for (o2 = 0; o2 < n3.length; o2 += 1)
                    i3 = n3.charCodeAt(o2), u2 = (f2 = o2 + s2) >>> 2, w2.length <= u2 && w2.push(0), w2[u2] |= i3 << 8 * (a2 + e3 * (f2 % 4));
                  return { value: w2, binLen: 8 * n3.length + t4 };
                }(n2, r2, t3, i2);
              };
            case "ARRAYBUFFER":
              try {
                new ArrayBuffer(0);
              } catch (n2) {
                throw new Error("ARRAYBUFFER not supported by this environment");
              }
              return function(n2, t3, e3) {
                return function(n3, t4, e4, i3) {
                  return r(new Uint8Array(n3), t4, e4, i3);
                }(n2, t3, e3, i2);
              };
            case "UINT8ARRAY":
              try {
                new Uint8Array(0);
              } catch (n2) {
                throw new Error("UINT8ARRAY not supported by this environment");
              }
              return function(n2, t3, e3) {
                return r(n2, t3, e3, i2);
              };
            default:
              throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
          }
        }
        function e(r2, t2, e2, i2) {
          switch (r2) {
            case "HEX":
              return function(n2) {
                return function(n3, r3, t3, e3) {
                  var i3, o2, u2 = "", f2 = r3 / 8, w2 = -1 === t3 ? 3 : 0;
                  for (i3 = 0; i3 < f2; i3 += 1)
                    o2 = n3[i3 >>> 2] >>> 8 * (w2 + t3 * (i3 % 4)), u2 += "0123456789abcdef".charAt(o2 >>> 4 & 15) + "0123456789abcdef".charAt(15 & o2);
                  return e3.outputUpper ? u2.toUpperCase() : u2;
                }(n2, t2, e2, i2);
              };
            case "B64":
              return function(r3) {
                return function(r4, t3, e3, i3) {
                  var o2, u2, f2, w2, s2, a2 = "", h2 = t3 / 8, c2 = -1 === e3 ? 3 : 0;
                  for (o2 = 0; o2 < h2; o2 += 3)
                    for (w2 = o2 + 1 < h2 ? r4[o2 + 1 >>> 2] : 0, s2 = o2 + 2 < h2 ? r4[o2 + 2 >>> 2] : 0, f2 = (r4[o2 >>> 2] >>> 8 * (c2 + e3 * (o2 % 4)) & 255) << 16 | (w2 >>> 8 * (c2 + e3 * ((o2 + 1) % 4)) & 255) << 8 | s2 >>> 8 * (c2 + e3 * ((o2 + 2) % 4)) & 255, u2 = 0; u2 < 4; u2 += 1)
                      a2 += 8 * o2 + 6 * u2 <= t3 ? n.charAt(f2 >>> 6 * (3 - u2) & 63) : i3.b64Pad;
                  return a2;
                }(r3, t2, e2, i2);
              };
            case "BYTES":
              return function(n2) {
                return function(n3, r3, t3) {
                  var e3, i3, o2 = "", u2 = r3 / 8, f2 = -1 === t3 ? 3 : 0;
                  for (e3 = 0; e3 < u2; e3 += 1)
                    i3 = n3[e3 >>> 2] >>> 8 * (f2 + t3 * (e3 % 4)) & 255, o2 += String.fromCharCode(i3);
                  return o2;
                }(n2, t2, e2);
              };
            case "ARRAYBUFFER":
              try {
                new ArrayBuffer(0);
              } catch (n2) {
                throw new Error("ARRAYBUFFER not supported by this environment");
              }
              return function(n2) {
                return function(n3, r3, t3) {
                  var e3, i3 = r3 / 8, o2 = new ArrayBuffer(i3), u2 = new Uint8Array(o2), f2 = -1 === t3 ? 3 : 0;
                  for (e3 = 0; e3 < i3; e3 += 1)
                    u2[e3] = n3[e3 >>> 2] >>> 8 * (f2 + t3 * (e3 % 4)) & 255;
                  return o2;
                }(n2, t2, e2);
              };
            case "UINT8ARRAY":
              try {
                new Uint8Array(0);
              } catch (n2) {
                throw new Error("UINT8ARRAY not supported by this environment");
              }
              return function(n2) {
                return function(n3, r3, t3) {
                  var e3, i3 = r3 / 8, o2 = -1 === t3 ? 3 : 0, u2 = new Uint8Array(i3);
                  for (e3 = 0; e3 < i3; e3 += 1)
                    u2[e3] = n3[e3 >>> 2] >>> 8 * (o2 + t3 * (e3 % 4)) & 255;
                  return u2;
                }(n2, t2, e2);
              };
            default:
              throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
          }
        }
        var i = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], o = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428], u = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], f = "Chosen SHA variant is not supported";
        function w(n2, r2) {
          var t2, e2, i2 = n2.binLen >>> 3, o2 = r2.binLen >>> 3, u2 = i2 << 3, f2 = 4 - i2 << 3;
          if (i2 % 4 != 0) {
            for (t2 = 0; t2 < o2; t2 += 4)
              e2 = i2 + t2 >>> 2, n2.value[e2] |= r2.value[t2 >>> 2] << u2, n2.value.push(0), n2.value[e2 + 1] |= r2.value[t2 >>> 2] >>> f2;
            return (n2.value.length << 2) - 4 >= o2 + i2 && n2.value.pop(), { value: n2.value, binLen: n2.binLen + r2.binLen };
          }
          return { value: n2.value.concat(r2.value), binLen: n2.binLen + r2.binLen };
        }
        function s(n2) {
          var r2 = { outputUpper: false, b64Pad: "=", outputLen: -1 }, t2 = n2 || {}, e2 = "Output length must be a multiple of 8";
          if (r2.outputUpper = t2.outputUpper || false, t2.b64Pad && (r2.b64Pad = t2.b64Pad), t2.outputLen) {
            if (t2.outputLen % 8 != 0)
              throw new Error(e2);
            r2.outputLen = t2.outputLen;
          } else if (t2.shakeLen) {
            if (t2.shakeLen % 8 != 0)
              throw new Error(e2);
            r2.outputLen = t2.shakeLen;
          }
          if ("boolean" != typeof r2.outputUpper)
            throw new Error("Invalid outputUpper formatting option");
          if ("string" != typeof r2.b64Pad)
            throw new Error("Invalid b64Pad formatting option");
          return r2;
        }
        function a(n2, r2, e2, i2) {
          var o2 = n2 + " must include a value and format";
          if (!r2) {
            if (!i2)
              throw new Error(o2);
            return i2;
          }
          if (void 0 === r2.value || !r2.format)
            throw new Error(o2);
          return t(r2.format, r2.encoding || "UTF8", e2)(r2.value);
        }
        var h = function() {
          function n2(n3, r2, t2) {
            var e2 = t2 || {};
            if (this.t = r2, this.i = e2.encoding || "UTF8", this.numRounds = e2.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds)
              throw new Error("numRounds must a integer >= 1");
            this.o = n3, this.u = [], this.s = 0, this.h = false, this.v = 0, this.A = false, this.l = [], this.H = [];
          }
          return n2.prototype.update = function(n3) {
            var r2, t2 = 0, e2 = this.S >>> 5, i2 = this.p(n3, this.u, this.s), o2 = i2.binLen, u2 = i2.value, f2 = o2 >>> 5;
            for (r2 = 0; r2 < f2; r2 += e2)
              t2 + this.S <= o2 && (this.m = this.R(u2.slice(r2, r2 + e2), this.m), t2 += this.S);
            this.v += t2, this.u = u2.slice(t2 >>> 5), this.s = o2 % this.S, this.h = true;
          }, n2.prototype.getHash = function(n3, r2) {
            var t2, i2, o2 = this.U, u2 = s(r2);
            if (this.T) {
              if (-1 === u2.outputLen)
                throw new Error("Output length must be specified in options");
              o2 = u2.outputLen;
            }
            var f2 = e(n3, o2, this.C, u2);
            if (this.A && this.F)
              return f2(this.F(u2));
            for (i2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), o2), t2 = 1; t2 < this.numRounds; t2 += 1)
              this.T && o2 % 32 != 0 && (i2[i2.length - 1] &= 16777215 >>> 24 - o2 % 32), i2 = this.K(i2, o2, 0, this.L(this.o), o2);
            return f2(i2);
          }, n2.prototype.setHMACKey = function(n3, r2, e2) {
            if (!this.g)
              throw new Error("Variant does not support HMAC");
            if (this.h)
              throw new Error("Cannot set MAC key after calling update");
            var i2 = t(r2, (e2 || {}).encoding || "UTF8", this.C);
            this.k(i2(n3));
          }, n2.prototype.k = function(n3) {
            var r2, t2 = this.S >>> 3, e2 = t2 / 4 - 1;
            if (1 !== this.numRounds)
              throw new Error("Cannot set numRounds with MAC");
            if (this.A)
              throw new Error("MAC key already set");
            for (t2 < n3.binLen / 8 && (n3.value = this.K(n3.value, n3.binLen, 0, this.L(this.o), this.U)); n3.value.length <= e2; )
              n3.value.push(0);
            for (r2 = 0; r2 <= e2; r2 += 1)
              this.l[r2] = 909522486 ^ n3.value[r2], this.H[r2] = 1549556828 ^ n3.value[r2];
            this.m = this.R(this.l, this.m), this.v = this.S, this.A = true;
          }, n2.prototype.getHMAC = function(n3, r2) {
            var t2 = s(r2);
            return e(n3, this.U, this.C, t2)(this.Y());
          }, n2.prototype.Y = function() {
            var n3;
            if (!this.A)
              throw new Error("Cannot call getHMAC without first setting MAC key");
            var r2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), this.U);
            return n3 = this.R(this.H, this.L(this.o)), n3 = this.K(r2, this.U, this.S, n3, this.U);
          }, n2;
        }(), c = function(n2, r2) {
          return (c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, r3) {
            n3.__proto__ = r3;
          } || function(n3, r3) {
            for (var t2 in r3)
              Object.prototype.hasOwnProperty.call(r3, t2) && (n3[t2] = r3[t2]);
          })(n2, r2);
        };
        function v(n2, r2) {
          function t2() {
            this.constructor = n2;
          }
          c(n2, r2), n2.prototype = null === r2 ? Object.create(r2) : (t2.prototype = r2.prototype, new t2());
        }
        function A(n2, r2) {
          return n2 << r2 | n2 >>> 32 - r2;
        }
        function E(n2, r2) {
          return n2 >>> r2 | n2 << 32 - r2;
        }
        function l(n2, r2) {
          return n2 >>> r2;
        }
        function b(n2, r2, t2) {
          return n2 ^ r2 ^ t2;
        }
        function H(n2, r2, t2) {
          return n2 & r2 ^ ~n2 & t2;
        }
        function d(n2, r2, t2) {
          return n2 & r2 ^ n2 & t2 ^ r2 & t2;
        }
        function S(n2) {
          return E(n2, 2) ^ E(n2, 13) ^ E(n2, 22);
        }
        function p(n2, r2) {
          var t2 = (65535 & n2) + (65535 & r2);
          return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16)) << 16 | 65535 & t2;
        }
        function m(n2, r2, t2, e2) {
          var i2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2);
          return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16)) << 16 | 65535 & i2;
        }
        function y(n2, r2, t2, e2, i2) {
          var o2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2) + (65535 & i2);
          return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16) + (o2 >>> 16)) << 16 | 65535 & o2;
        }
        function R(n2) {
          return E(n2, 7) ^ E(n2, 18) ^ l(n2, 3);
        }
        function U(n2) {
          return E(n2, 6) ^ E(n2, 11) ^ E(n2, 25);
        }
        function T(n2) {
          return [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        }
        function C(n2, r2) {
          var t2, e2, i2, o2, u2, f2, w2, s2 = [];
          for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], w2 = 0; w2 < 80; w2 += 1)
            s2[w2] = w2 < 16 ? n2[w2] : A(s2[w2 - 3] ^ s2[w2 - 8] ^ s2[w2 - 14] ^ s2[w2 - 16], 1), f2 = w2 < 20 ? y(A(t2, 5), H(e2, i2, o2), u2, 1518500249, s2[w2]) : w2 < 40 ? y(A(t2, 5), b(e2, i2, o2), u2, 1859775393, s2[w2]) : w2 < 60 ? y(A(t2, 5), d(e2, i2, o2), u2, 2400959708, s2[w2]) : y(A(t2, 5), b(e2, i2, o2), u2, 3395469782, s2[w2]), u2 = o2, o2 = i2, i2 = A(e2, 30), e2 = t2, t2 = f2;
          return r2[0] = p(t2, r2[0]), r2[1] = p(e2, r2[1]), r2[2] = p(i2, r2[2]), r2[3] = p(o2, r2[3]), r2[4] = p(u2, r2[4]), r2;
        }
        function F(n2, r2, t2, e2) {
          for (var i2, o2 = 15 + (r2 + 65 >>> 9 << 4), u2 = r2 + t2; n2.length <= o2; )
            n2.push(0);
          for (n2[r2 >>> 5] |= 128 << 24 - r2 % 32, n2[o2] = 4294967295 & u2, n2[o2 - 1] = u2 / 4294967296 | 0, i2 = 0; i2 < n2.length; i2 += 16)
            e2 = C(n2.slice(i2, i2 + 16), e2);
          return e2;
        }
        var K = function(n2) {
          function r2(r3, e2, i2) {
            var o2 = this;
            if ("SHA-1" !== r3)
              throw new Error(f);
            var u2 = i2 || {};
            return (o2 = n2.call(this, r3, e2, i2) || this).g = true, o2.F = o2.Y, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = C, o2.B = function(n3) {
              return n3.slice();
            }, o2.L = T, o2.K = F, o2.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], o2.S = 512, o2.U = 160, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
          }
          return v(r2, n2), r2;
        }(h);
        function B(n2) {
          return "SHA-224" == n2 ? o.slice() : u.slice();
        }
        function L(n2, r2) {
          var t2, e2, o2, u2, f2, w2, s2, a2, h2, c2, v2, A2, b2 = [];
          for (t2 = r2[0], e2 = r2[1], o2 = r2[2], u2 = r2[3], f2 = r2[4], w2 = r2[5], s2 = r2[6], a2 = r2[7], v2 = 0; v2 < 64; v2 += 1)
            b2[v2] = v2 < 16 ? n2[v2] : m(E(A2 = b2[v2 - 2], 17) ^ E(A2, 19) ^ l(A2, 10), b2[v2 - 7], R(b2[v2 - 15]), b2[v2 - 16]), h2 = y(a2, U(f2), H(f2, w2, s2), i[v2], b2[v2]), c2 = p(S(t2), d(t2, e2, o2)), a2 = s2, s2 = w2, w2 = f2, f2 = p(u2, h2), u2 = o2, o2 = e2, e2 = t2, t2 = p(h2, c2);
          return r2[0] = p(t2, r2[0]), r2[1] = p(e2, r2[1]), r2[2] = p(o2, r2[2]), r2[3] = p(u2, r2[3]), r2[4] = p(f2, r2[4]), r2[5] = p(w2, r2[5]), r2[6] = p(s2, r2[6]), r2[7] = p(a2, r2[7]), r2;
        }
        var g = function(n2) {
          function r2(r3, e2, i2) {
            var o2 = this;
            if ("SHA-224" !== r3 && "SHA-256" !== r3)
              throw new Error(f);
            var u2 = i2 || {};
            return (o2 = n2.call(this, r3, e2, i2) || this).F = o2.Y, o2.g = true, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = L, o2.B = function(n3) {
              return n3.slice();
            }, o2.L = B, o2.K = function(n3, t2, e3, i3) {
              return function(n4, r4, t3, e4, i4) {
                for (var o3, u3 = 15 + (r4 + 65 >>> 9 << 4), f2 = r4 + t3; n4.length <= u3; )
                  n4.push(0);
                for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f2, n4[u3 - 1] = f2 / 4294967296 | 0, o3 = 0; o3 < n4.length; o3 += 16)
                  e4 = L(n4.slice(o3, o3 + 16), e4);
                return "SHA-224" === i4 ? [e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]] : e4;
              }(n3, t2, e3, i3, r3);
            }, o2.m = B(r3), o2.S = 512, o2.U = "SHA-224" === r3 ? 224 : 256, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
          }
          return v(r2, n2), r2;
        }(h), k = function(n2, r2) {
          this.N = n2, this.I = r2;
        };
        function Y(n2, r2) {
          var t2;
          return r2 > 32 ? (t2 = 64 - r2, new k(n2.I << r2 | n2.N >>> t2, n2.N << r2 | n2.I >>> t2)) : 0 !== r2 ? (t2 = 32 - r2, new k(n2.N << r2 | n2.I >>> t2, n2.I << r2 | n2.N >>> t2)) : n2;
        }
        function N(n2, r2) {
          var t2;
          return r2 < 32 ? (t2 = 32 - r2, new k(n2.N >>> r2 | n2.I << t2, n2.I >>> r2 | n2.N << t2)) : (t2 = 64 - r2, new k(n2.I >>> r2 | n2.N << t2, n2.N >>> r2 | n2.I << t2));
        }
        function I(n2, r2) {
          return new k(n2.N >>> r2, n2.I >>> r2 | n2.N << 32 - r2);
        }
        function M(n2, r2, t2) {
          return new k(n2.N & r2.N ^ ~n2.N & t2.N, n2.I & r2.I ^ ~n2.I & t2.I);
        }
        function X(n2, r2, t2) {
          return new k(n2.N & r2.N ^ n2.N & t2.N ^ r2.N & t2.N, n2.I & r2.I ^ n2.I & t2.I ^ r2.I & t2.I);
        }
        function z(n2) {
          var r2 = N(n2, 28), t2 = N(n2, 34), e2 = N(n2, 39);
          return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
        }
        function O(n2, r2) {
          var t2, e2;
          t2 = (65535 & n2.I) + (65535 & r2.I);
          var i2 = (65535 & (e2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2 >>> 16))) << 16 | 65535 & t2;
          return t2 = (65535 & n2.N) + (65535 & r2.N) + (e2 >>> 16), e2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2 >>> 16), new k((65535 & e2) << 16 | 65535 & t2, i2);
        }
        function j(n2, r2, t2, e2) {
          var i2, o2;
          i2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I);
          var u2 = (65535 & (o2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2 >>> 16))) << 16 | 65535 & i2;
          return i2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (o2 >>> 16), o2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2 >>> 16), new k((65535 & o2) << 16 | 65535 & i2, u2);
        }
        function _(n2, r2, t2, e2, i2) {
          var o2, u2;
          o2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I) + (65535 & i2.I);
          var f2 = (65535 & (u2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2.I >>> 16) + (o2 >>> 16))) << 16 | 65535 & o2;
          return o2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (65535 & i2.N) + (u2 >>> 16), u2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2.N >>> 16) + (o2 >>> 16), new k((65535 & u2) << 16 | 65535 & o2, f2);
        }
        function P(n2, r2) {
          return new k(n2.N ^ r2.N, n2.I ^ r2.I);
        }
        function x(n2) {
          var r2 = N(n2, 1), t2 = N(n2, 8), e2 = I(n2, 7);
          return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
        }
        function V(n2) {
          var r2 = N(n2, 14), t2 = N(n2, 18), e2 = N(n2, 41);
          return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
        }
        var Z = [new k(i[0], 3609767458), new k(i[1], 602891725), new k(i[2], 3964484399), new k(i[3], 2173295548), new k(i[4], 4081628472), new k(i[5], 3053834265), new k(i[6], 2937671579), new k(i[7], 3664609560), new k(i[8], 2734883394), new k(i[9], 1164996542), new k(i[10], 1323610764), new k(i[11], 3590304994), new k(i[12], 4068182383), new k(i[13], 991336113), new k(i[14], 633803317), new k(i[15], 3479774868), new k(i[16], 2666613458), new k(i[17], 944711139), new k(i[18], 2341262773), new k(i[19], 2007800933), new k(i[20], 1495990901), new k(i[21], 1856431235), new k(i[22], 3175218132), new k(i[23], 2198950837), new k(i[24], 3999719339), new k(i[25], 766784016), new k(i[26], 2566594879), new k(i[27], 3203337956), new k(i[28], 1034457026), new k(i[29], 2466948901), new k(i[30], 3758326383), new k(i[31], 168717936), new k(i[32], 1188179964), new k(i[33], 1546045734), new k(i[34], 1522805485), new k(i[35], 2643833823), new k(i[36], 2343527390), new k(i[37], 1014477480), new k(i[38], 1206759142), new k(i[39], 344077627), new k(i[40], 1290863460), new k(i[41], 3158454273), new k(i[42], 3505952657), new k(i[43], 106217008), new k(i[44], 3606008344), new k(i[45], 1432725776), new k(i[46], 1467031594), new k(i[47], 851169720), new k(i[48], 3100823752), new k(i[49], 1363258195), new k(i[50], 3750685593), new k(i[51], 3785050280), new k(i[52], 3318307427), new k(i[53], 3812723403), new k(i[54], 2003034995), new k(i[55], 3602036899), new k(i[56], 1575990012), new k(i[57], 1125592928), new k(i[58], 2716904306), new k(i[59], 442776044), new k(i[60], 593698344), new k(i[61], 3733110249), new k(i[62], 2999351573), new k(i[63], 3815920427), new k(3391569614, 3928383900), new k(3515267271, 566280711), new k(3940187606, 3454069534), new k(4118630271, 4000239992), new k(116418474, 1914138554), new k(174292421, 2731055270), new k(289380356, 3203993006), new k(460393269, 320620315), new k(685471733, 587496836), new k(852142971, 1086792851), new k(1017036298, 365543100), new k(1126000580, 2618297676), new k(1288033470, 3409855158), new k(1501505948, 4234509866), new k(1607167915, 987167468), new k(1816402316, 1246189591)];
        function q(n2) {
          return "SHA-384" === n2 ? [new k(3418070365, o[0]), new k(1654270250, o[1]), new k(2438529370, o[2]), new k(355462360, o[3]), new k(1731405415, o[4]), new k(41048885895, o[5]), new k(3675008525, o[6]), new k(1203062813, o[7])] : [new k(u[0], 4089235720), new k(u[1], 2227873595), new k(u[2], 4271175723), new k(u[3], 1595750129), new k(u[4], 2917565137), new k(u[5], 725511199), new k(u[6], 4215389547), new k(u[7], 327033209)];
        }
        function D(n2, r2) {
          var t2, e2, i2, o2, u2, f2, w2, s2, a2, h2, c2, v2, A2, E2, l2, b2, H2 = [];
          for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], f2 = r2[5], w2 = r2[6], s2 = r2[7], c2 = 0; c2 < 80; c2 += 1)
            c2 < 16 ? (v2 = 2 * c2, H2[c2] = new k(n2[v2], n2[v2 + 1])) : H2[c2] = j((A2 = H2[c2 - 2], E2 = void 0, l2 = void 0, b2 = void 0, E2 = N(A2, 19), l2 = N(A2, 61), b2 = I(A2, 6), new k(E2.N ^ l2.N ^ b2.N, E2.I ^ l2.I ^ b2.I)), H2[c2 - 7], x(H2[c2 - 15]), H2[c2 - 16]), a2 = _(s2, V(u2), M(u2, f2, w2), Z[c2], H2[c2]), h2 = O(z(t2), X(t2, e2, i2)), s2 = w2, w2 = f2, f2 = u2, u2 = O(o2, a2), o2 = i2, i2 = e2, e2 = t2, t2 = O(a2, h2);
          return r2[0] = O(t2, r2[0]), r2[1] = O(e2, r2[1]), r2[2] = O(i2, r2[2]), r2[3] = O(o2, r2[3]), r2[4] = O(u2, r2[4]), r2[5] = O(f2, r2[5]), r2[6] = O(w2, r2[6]), r2[7] = O(s2, r2[7]), r2;
        }
        var G = function(n2) {
          function r2(r3, e2, i2) {
            var o2 = this;
            if ("SHA-384" !== r3 && "SHA-512" !== r3)
              throw new Error(f);
            var u2 = i2 || {};
            return (o2 = n2.call(this, r3, e2, i2) || this).F = o2.Y, o2.g = true, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = D, o2.B = function(n3) {
              return n3.slice();
            }, o2.L = q, o2.K = function(n3, t2, e3, i3) {
              return function(n4, r4, t3, e4, i4) {
                for (var o3, u3 = 31 + (r4 + 129 >>> 10 << 5), f2 = r4 + t3; n4.length <= u3; )
                  n4.push(0);
                for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f2, n4[u3 - 1] = f2 / 4294967296 | 0, o3 = 0; o3 < n4.length; o3 += 32)
                  e4 = D(n4.slice(o3, o3 + 32), e4);
                return "SHA-384" === i4 ? [(e4 = e4)[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I] : [e4[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I, e4[6].N, e4[6].I, e4[7].N, e4[7].I];
              }(n3, t2, e3, i3, r3);
            }, o2.m = q(r3), o2.S = 1024, o2.U = "SHA-384" === r3 ? 384 : 512, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
          }
          return v(r2, n2), r2;
        }(h), J = [new k(0, 1), new k(0, 32898), new k(2147483648, 32906), new k(2147483648, 2147516416), new k(0, 32907), new k(0, 2147483649), new k(2147483648, 2147516545), new k(2147483648, 32777), new k(0, 138), new k(0, 136), new k(0, 2147516425), new k(0, 2147483658), new k(0, 2147516555), new k(2147483648, 139), new k(2147483648, 32905), new k(2147483648, 32771), new k(2147483648, 32770), new k(2147483648, 128), new k(0, 32778), new k(2147483648, 2147483658), new k(2147483648, 2147516545), new k(2147483648, 32896), new k(0, 2147483649), new k(2147483648, 2147516424)], Q = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
        function W(n2) {
          var r2, t2 = [];
          for (r2 = 0; r2 < 5; r2 += 1)
            t2[r2] = [new k(0, 0), new k(0, 0), new k(0, 0), new k(0, 0), new k(0, 0)];
          return t2;
        }
        function $(n2) {
          var r2, t2 = [];
          for (r2 = 0; r2 < 5; r2 += 1)
            t2[r2] = n2[r2].slice();
          return t2;
        }
        function nn(n2, r2) {
          var t2, e2, i2, o2, u2, f2, w2, s2, a2, h2 = [], c2 = [];
          if (null !== n2)
            for (e2 = 0; e2 < n2.length; e2 += 2)
              r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0] = P(r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0], new k(n2[e2 + 1], n2[e2]));
          for (t2 = 0; t2 < 24; t2 += 1) {
            for (o2 = W(), e2 = 0; e2 < 5; e2 += 1)
              h2[e2] = (u2 = r2[e2][0], f2 = r2[e2][1], w2 = r2[e2][2], s2 = r2[e2][3], a2 = r2[e2][4], new k(u2.N ^ f2.N ^ w2.N ^ s2.N ^ a2.N, u2.I ^ f2.I ^ w2.I ^ s2.I ^ a2.I));
            for (e2 = 0; e2 < 5; e2 += 1)
              c2[e2] = P(h2[(e2 + 4) % 5], Y(h2[(e2 + 1) % 5], 1));
            for (e2 = 0; e2 < 5; e2 += 1)
              for (i2 = 0; i2 < 5; i2 += 1)
                r2[e2][i2] = P(r2[e2][i2], c2[e2]);
            for (e2 = 0; e2 < 5; e2 += 1)
              for (i2 = 0; i2 < 5; i2 += 1)
                o2[i2][(2 * e2 + 3 * i2) % 5] = Y(r2[e2][i2], Q[e2][i2]);
            for (e2 = 0; e2 < 5; e2 += 1)
              for (i2 = 0; i2 < 5; i2 += 1)
                r2[e2][i2] = P(o2[e2][i2], new k(~o2[(e2 + 1) % 5][i2].N & o2[(e2 + 2) % 5][i2].N, ~o2[(e2 + 1) % 5][i2].I & o2[(e2 + 2) % 5][i2].I));
            r2[0][0] = P(r2[0][0], J[t2]);
          }
          return r2;
        }
        function rn(n2) {
          var r2, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n2, n2 / 4294967296 & 2097151];
          for (r2 = 6; r2 >= 0; r2--)
            0 === (t2 = o2[r2 >> 2] >>> 8 * r2 & 255) && 0 === e2 || (i2[e2 + 1 >> 2] |= t2 << 8 * (e2 + 1), e2 += 1);
          return e2 = 0 !== e2 ? e2 : 1, i2[0] |= e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
        }
        function tn(n2) {
          return w(rn(n2.binLen), n2);
        }
        function en(n2, r2) {
          var t2, e2 = rn(r2), i2 = r2 >>> 2, o2 = (i2 - (e2 = w(e2, n2)).value.length % i2) % i2;
          for (t2 = 0; t2 < o2; t2++)
            e2.value.push(0);
          return e2.value;
        }
        var on2 = function(n2) {
          function r2(r3, e2, i2) {
            var o2 = this, u2 = 6, w2 = 0, s2 = i2 || {};
            if (1 !== (o2 = n2.call(this, r3, e2, i2) || this).numRounds) {
              if (s2.kmacKey || s2.hmacKey)
                throw new Error("Cannot set numRounds with MAC");
              if ("CSHAKE128" === o2.o || "CSHAKE256" === o2.o)
                throw new Error("Cannot set numRounds for CSHAKE variants");
            }
            switch (o2.C = 1, o2.p = t(o2.t, o2.i, o2.C), o2.R = nn, o2.B = $, o2.L = W, o2.m = W(), o2.T = false, r3) {
              case "SHA3-224":
                o2.S = w2 = 1152, o2.U = 224, o2.g = true, o2.F = o2.Y;
                break;
              case "SHA3-256":
                o2.S = w2 = 1088, o2.U = 256, o2.g = true, o2.F = o2.Y;
                break;
              case "SHA3-384":
                o2.S = w2 = 832, o2.U = 384, o2.g = true, o2.F = o2.Y;
                break;
              case "SHA3-512":
                o2.S = w2 = 576, o2.U = 512, o2.g = true, o2.F = o2.Y;
                break;
              case "SHAKE128":
                u2 = 31, o2.S = w2 = 1344, o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
                break;
              case "SHAKE256":
                u2 = 31, o2.S = w2 = 1088, o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
                break;
              case "KMAC128":
                u2 = 4, o2.S = w2 = 1344, o2.M(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = o2.X;
                break;
              case "KMAC256":
                u2 = 4, o2.S = w2 = 1088, o2.M(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = o2.X;
                break;
              case "CSHAKE128":
                o2.S = w2 = 1344, u2 = o2.O(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
                break;
              case "CSHAKE256":
                o2.S = w2 = 1088, u2 = o2.O(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
                break;
              default:
                throw new Error(f);
            }
            return o2.K = function(n3, r4, t2, e3, i3) {
              return function(n4, r5, t3, e4, i4, o3, u3) {
                var f2, w3, s3 = 0, a2 = [], h2 = i4 >>> 5, c2 = r5 >>> 5;
                for (f2 = 0; f2 < c2 && r5 >= i4; f2 += h2)
                  e4 = nn(n4.slice(f2, f2 + h2), e4), r5 -= i4;
                for (n4 = n4.slice(f2), r5 %= i4; n4.length < h2; )
                  n4.push(0);
                for (n4[(f2 = r5 >>> 3) >> 2] ^= o3 << f2 % 4 * 8, n4[h2 - 1] ^= 2147483648, e4 = nn(n4, e4); 32 * a2.length < u3 && (w3 = e4[s3 % 5][s3 / 5 | 0], a2.push(w3.I), !(32 * a2.length >= u3)); )
                  a2.push(w3.N), 0 == 64 * (s3 += 1) % i4 && (nn(null, e4), s3 = 0);
                return a2;
              }(n3, r4, 0, e3, w2, u2, i3);
            }, s2.hmacKey && o2.k(a("hmacKey", s2.hmacKey, o2.C)), o2;
          }
          return v(r2, n2), r2.prototype.O = function(n3, r3) {
            var t2 = function(n4) {
              var r4 = n4 || {};
              return { funcName: a("funcName", r4.funcName, 1, { value: [], binLen: 0 }), customization: a("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
            }(n3 || {});
            r3 && (t2.funcName = r3);
            var e2 = w(tn(t2.funcName), tn(t2.customization));
            if (0 !== t2.customization.binLen || 0 !== t2.funcName.binLen) {
              for (var i2 = en(e2, this.S >>> 3), o2 = 0; o2 < i2.length; o2 += this.S >>> 5)
                this.m = this.R(i2.slice(o2, o2 + (this.S >>> 5)), this.m), this.v += this.S;
              return 4;
            }
            return 31;
          }, r2.prototype.M = function(n3) {
            var r3 = function(n4) {
              var r4 = n4 || {};
              return { kmacKey: a("kmacKey", r4.kmacKey, 1), funcName: { value: [1128353099], binLen: 32 }, customization: a("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
            }(n3 || {});
            this.O(n3, r3.funcName);
            for (var t2 = en(tn(r3.kmacKey), this.S >>> 3), e2 = 0; e2 < t2.length; e2 += this.S >>> 5)
              this.m = this.R(t2.slice(e2, e2 + (this.S >>> 5)), this.m), this.v += this.S;
            this.A = true;
          }, r2.prototype.X = function(n3) {
            var r3 = w({ value: this.u.slice(), binLen: this.s }, function(n4) {
              var r4, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n4, n4 / 4294967296 & 2097151];
              for (r4 = 6; r4 >= 0; r4--)
                0 == (t2 = o2[r4 >> 2] >>> 8 * r4 & 255) && 0 === e2 || (i2[e2 >> 2] |= t2 << 8 * e2, e2 += 1);
              return i2[(e2 = 0 !== e2 ? e2 : 1) >> 2] |= e2 << 8 * e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
            }(n3.outputLen));
            return this.K(r3.value, r3.binLen, this.v, this.B(this.m), n3.outputLen);
          }, r2;
        }(h);
        return function() {
          function n2(n3, r2, t2) {
            if ("SHA-1" == n3)
              this.j = new K(n3, r2, t2);
            else if ("SHA-224" == n3 || "SHA-256" == n3)
              this.j = new g(n3, r2, t2);
            else if ("SHA-384" == n3 || "SHA-512" == n3)
              this.j = new G(n3, r2, t2);
            else {
              if ("SHA3-224" != n3 && "SHA3-256" != n3 && "SHA3-384" != n3 && "SHA3-512" != n3 && "SHAKE128" != n3 && "SHAKE256" != n3 && "CSHAKE128" != n3 && "CSHAKE256" != n3 && "KMAC128" != n3 && "KMAC256" != n3)
                throw new Error(f);
              this.j = new on2(n3, r2, t2);
            }
          }
          return n2.prototype.update = function(n3) {
            this.j.update(n3);
          }, n2.prototype.getHash = function(n3, r2) {
            return this.j.getHash(n3, r2);
          }, n2.prototype.setHMACKey = function(n3, r2, t2) {
            this.j.setHMACKey(n3, r2, t2);
          }, n2.prototype.getHMAC = function(n3, r2) {
            return this.j.getHMAC(n3, r2);
          }, n2;
        }();
      });
    }
  });

  // node_modules/ton-crypto-primitives/dist/browser/getSecureRandom.js
  var require_getSecureRandom = __commonJS({
    "node_modules/ton-crypto-primitives/dist/browser/getSecureRandom.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
      function getSecureRandomBytes(size) {
        return Buffer2.from(window.crypto.getRandomValues(new Uint8Array(size)));
      }
      exports.getSecureRandomBytes = getSecureRandomBytes;
      function getSecureRandomWords(size) {
        return window.crypto.getRandomValues(new Uint16Array(size));
      }
      exports.getSecureRandomWords = getSecureRandomWords;
    }
  });

  // node_modules/ton-crypto-primitives/dist/browser/hmac_sha512.js
  var require_hmac_sha512 = __commonJS({
    "node_modules/ton-crypto-primitives/dist/browser/hmac_sha512.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hmac_sha512 = void 0;
      async function hmac_sha512(key, data) {
        let keyBuffer = typeof key === "string" ? Buffer2.from(key, "utf-8") : key;
        let dataBuffer = typeof data === "string" ? Buffer2.from(data, "utf-8") : data;
        const hmacAlgo = { name: "HMAC", hash: "SHA-512" };
        const hmacKey = await window.crypto.subtle.importKey("raw", keyBuffer, hmacAlgo, false, ["sign"]);
        return Buffer2.from(await crypto.subtle.sign(hmacAlgo, hmacKey, dataBuffer));
      }
      exports.hmac_sha512 = hmac_sha512;
    }
  });

  // node_modules/ton-crypto-primitives/dist/browser/pbkdf2_sha512.js
  var require_pbkdf2_sha512 = __commonJS({
    "node_modules/ton-crypto-primitives/dist/browser/pbkdf2_sha512.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pbkdf2_sha512 = void 0;
      async function pbkdf2_sha512(key, salt, iterations, keyLen) {
        const keyBuffer = typeof key === "string" ? Buffer2.from(key, "utf-8") : key;
        const saltBuffer = typeof salt === "string" ? Buffer2.from(salt, "utf-8") : salt;
        const pbkdf2_key = await window.crypto.subtle.importKey("raw", keyBuffer, { name: "PBKDF2" }, false, ["deriveBits"]);
        const derivedBits = await window.crypto.subtle.deriveBits({ name: "PBKDF2", hash: "SHA-512", salt: saltBuffer, iterations }, pbkdf2_key, keyLen * 8);
        return Buffer2.from(derivedBits);
      }
      exports.pbkdf2_sha512 = pbkdf2_sha512;
    }
  });

  // node_modules/ton-crypto-primitives/dist/browser/sha256.js
  var require_sha256 = __commonJS({
    "node_modules/ton-crypto-primitives/dist/browser/sha256.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha256 = void 0;
      async function sha256(source) {
        if (typeof source === "string") {
          return Buffer2.from(await crypto.subtle.digest("SHA-256", Buffer2.from(source, "utf-8")));
        }
        return Buffer2.from(await crypto.subtle.digest("SHA-256", source));
      }
      exports.sha256 = sha256;
    }
  });

  // node_modules/ton-crypto-primitives/dist/browser/sha512.js
  var require_sha512 = __commonJS({
    "node_modules/ton-crypto-primitives/dist/browser/sha512.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha512 = void 0;
      async function sha512(source) {
        if (typeof source === "string") {
          return Buffer2.from(await crypto.subtle.digest("SHA-512", Buffer2.from(source, "utf-8")));
        }
        return Buffer2.from(await crypto.subtle.digest("SHA-512", source));
      }
      exports.sha512 = sha512;
    }
  });

  // node_modules/ton-crypto-primitives/dist/browser.js
  var require_browser = __commonJS({
    "node_modules/ton-crypto-primitives/dist/browser.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha512 = exports.sha256 = exports.pbkdf2_sha512 = exports.hmac_sha512 = exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
      var getSecureRandom_1 = require_getSecureRandom();
      Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
        return getSecureRandom_1.getSecureRandomBytes;
      } });
      Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
        return getSecureRandom_1.getSecureRandomWords;
      } });
      var hmac_sha512_1 = require_hmac_sha512();
      Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
        return hmac_sha512_1.hmac_sha512;
      } });
      var pbkdf2_sha512_1 = require_pbkdf2_sha512();
      Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
        return pbkdf2_sha512_1.pbkdf2_sha512;
      } });
      var sha256_1 = require_sha256();
      Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
        return sha256_1.sha256;
      } });
      var sha512_1 = require_sha512();
      Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
        return sha512_1.sha512;
      } });
    }
  });

  // node_modules/ton-crypto/dist/primitives/sha256.js
  var require_sha2562 = __commonJS({
    "node_modules/ton-crypto/dist/primitives/sha256.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __importDefault2 = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha256 = exports.sha256_fallback = exports.sha256_sync = void 0;
      var jssha_1 = __importDefault2(require_sha());
      var ton_crypto_primitives_1 = require_browser();
      function sha256_sync(source) {
        let src;
        if (typeof source === "string") {
          src = Buffer2.from(source, "utf-8").toString("hex");
        } else {
          src = source.toString("hex");
        }
        let hasher = new jssha_1.default("SHA-256", "HEX");
        hasher.update(src);
        let res = hasher.getHash("HEX");
        return Buffer2.from(res, "hex");
      }
      exports.sha256_sync = sha256_sync;
      async function sha256_fallback(source) {
        return sha256_sync(source);
      }
      exports.sha256_fallback = sha256_fallback;
      function sha256(source) {
        return (0, ton_crypto_primitives_1.sha256)(source);
      }
      exports.sha256 = sha256;
    }
  });

  // node_modules/ton-crypto/dist/primitives/sha512.js
  var require_sha5122 = __commonJS({
    "node_modules/ton-crypto/dist/primitives/sha512.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __importDefault2 = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha512 = exports.sha512_fallback = exports.sha512_sync = void 0;
      var jssha_1 = __importDefault2(require_sha());
      var ton_crypto_primitives_1 = require_browser();
      function sha512_sync(source) {
        let src;
        if (typeof source === "string") {
          src = Buffer2.from(source, "utf-8").toString("hex");
        } else {
          src = source.toString("hex");
        }
        let hasher = new jssha_1.default("SHA-512", "HEX");
        hasher.update(src);
        let res = hasher.getHash("HEX");
        return Buffer2.from(res, "hex");
      }
      exports.sha512_sync = sha512_sync;
      async function sha512_fallback(source) {
        return sha512_sync(source);
      }
      exports.sha512_fallback = sha512_fallback;
      async function sha512(source) {
        return (0, ton_crypto_primitives_1.sha512)(source);
      }
      exports.sha512 = sha512;
    }
  });

  // node_modules/ton-crypto/dist/primitives/pbkdf2_sha512.js
  var require_pbkdf2_sha5122 = __commonJS({
    "node_modules/ton-crypto/dist/primitives/pbkdf2_sha512.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pbkdf2_sha512 = void 0;
      var ton_crypto_primitives_1 = require_browser();
      function pbkdf2_sha512(key, salt, iterations, keyLen) {
        return (0, ton_crypto_primitives_1.pbkdf2_sha512)(key, salt, iterations, keyLen);
      }
      exports.pbkdf2_sha512 = pbkdf2_sha512;
    }
  });

  // node_modules/ton-crypto/dist/primitives/hmac_sha512.js
  var require_hmac_sha5122 = __commonJS({
    "node_modules/ton-crypto/dist/primitives/hmac_sha512.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __importDefault2 = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hmac_sha512 = exports.hmac_sha512_fallback = void 0;
      var jssha_1 = __importDefault2(require_sha());
      var ton_crypto_primitives_1 = require_browser();
      async function hmac_sha512_fallback(key, data) {
        let keyBuffer = typeof key === "string" ? Buffer2.from(key, "utf-8") : key;
        let dataBuffer = typeof data === "string" ? Buffer2.from(data, "utf-8") : data;
        const shaObj = new jssha_1.default("SHA-512", "HEX", {
          hmacKey: { value: keyBuffer.toString("hex"), format: "HEX" }
        });
        shaObj.update(dataBuffer.toString("hex"));
        const hmac = shaObj.getHash("HEX");
        return Buffer2.from(hmac, "hex");
      }
      exports.hmac_sha512_fallback = hmac_sha512_fallback;
      function hmac_sha512(key, data) {
        return (0, ton_crypto_primitives_1.hmac_sha512)(key, data);
      }
      exports.hmac_sha512 = hmac_sha512;
    }
  });

  // node_modules/ton-crypto/dist/primitives/getSecureRandom.js
  var require_getSecureRandom2 = __commonJS({
    "node_modules/ton-crypto/dist/primitives/getSecureRandom.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getSecureRandomNumber = exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
      var ton_crypto_primitives_1 = require_browser();
      async function getSecureRandomBytes(size) {
        return (0, ton_crypto_primitives_1.getSecureRandomBytes)(size);
      }
      exports.getSecureRandomBytes = getSecureRandomBytes;
      async function getSecureRandomWords(size) {
        return getSecureRandomWords(size);
      }
      exports.getSecureRandomWords = getSecureRandomWords;
      async function getSecureRandomNumber(min, max) {
        let range = max - min;
        var bitsNeeded = Math.ceil(Math.log2(range));
        if (bitsNeeded > 53) {
          throw new Error("Range is too large");
        }
        var bytesNeeded = Math.ceil(bitsNeeded / 8);
        var mask = Math.pow(2, bitsNeeded) - 1;
        while (true) {
          let res = await getSecureRandomBytes(bitsNeeded);
          let power = (bytesNeeded - 1) * 8;
          let numberValue = 0;
          for (var i = 0; i < bytesNeeded; i++) {
            numberValue += res[i] * Math.pow(2, power);
            power -= 8;
          }
          numberValue = numberValue & mask;
          if (numberValue >= range) {
            continue;
          }
          return min + numberValue;
        }
      }
      exports.getSecureRandomNumber = getSecureRandomNumber;
    }
  });

  // node_modules/ton-crypto/dist/passwords/wordlist.js
  var require_wordlist = __commonJS({
    "node_modules/ton-crypto/dist/passwords/wordlist.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.wordlist = void 0;
      exports.wordlist = [
        "abacus",
        "abdomen",
        "abdominal",
        "abide",
        "abiding",
        "ability",
        "ablaze",
        "able",
        "abnormal",
        "abrasion",
        "abrasive",
        "abreast",
        "abridge",
        "abroad",
        "abruptly",
        "absence",
        "absentee",
        "absently",
        "absinthe",
        "absolute",
        "absolve",
        "abstain",
        "abstract",
        "absurd",
        "accent",
        "acclaim",
        "acclimate",
        "accompany",
        "account",
        "accuracy",
        "accurate",
        "accustom",
        "acetone",
        "achiness",
        "aching",
        "acid",
        "acorn",
        "acquaint",
        "acquire",
        "acre",
        "acrobat",
        "acronym",
        "acting",
        "action",
        "activate",
        "activator",
        "active",
        "activism",
        "activist",
        "activity",
        "actress",
        "acts",
        "acutely",
        "acuteness",
        "aeration",
        "aerobics",
        "aerosol",
        "aerospace",
        "afar",
        "affair",
        "affected",
        "affecting",
        "affection",
        "affidavit",
        "affiliate",
        "affirm",
        "affix",
        "afflicted",
        "affluent",
        "afford",
        "affront",
        "aflame",
        "afloat",
        "aflutter",
        "afoot",
        "afraid",
        "afterglow",
        "afterlife",
        "aftermath",
        "aftermost",
        "afternoon",
        "aged",
        "ageless",
        "agency",
        "agenda",
        "agent",
        "aggregate",
        "aghast",
        "agile",
        "agility",
        "aging",
        "agnostic",
        "agonize",
        "agonizing",
        "agony",
        "agreeable",
        "agreeably",
        "agreed",
        "agreeing",
        "agreement",
        "aground",
        "ahead",
        "ahoy",
        "aide",
        "aids",
        "aim",
        "ajar",
        "alabaster",
        "alarm",
        "albatross",
        "album",
        "alfalfa",
        "algebra",
        "algorithm",
        "alias",
        "alibi",
        "alienable",
        "alienate",
        "aliens",
        "alike",
        "alive",
        "alkaline",
        "alkalize",
        "almanac",
        "almighty",
        "almost",
        "aloe",
        "aloft",
        "aloha",
        "alone",
        "alongside",
        "aloof",
        "alphabet",
        "alright",
        "although",
        "altitude",
        "alto",
        "aluminum",
        "alumni",
        "always",
        "amaretto",
        "amaze",
        "amazingly",
        "amber",
        "ambiance",
        "ambiguity",
        "ambiguous",
        "ambition",
        "ambitious",
        "ambulance",
        "ambush",
        "amendable",
        "amendment",
        "amends",
        "amenity",
        "amiable",
        "amicably",
        "amid",
        "amigo",
        "amino",
        "amiss",
        "ammonia",
        "ammonium",
        "amnesty",
        "amniotic",
        "among",
        "amount",
        "amperage",
        "ample",
        "amplifier",
        "amplify",
        "amply",
        "amuck",
        "amulet",
        "amusable",
        "amused",
        "amusement",
        "amuser",
        "amusing",
        "anaconda",
        "anaerobic",
        "anagram",
        "anatomist",
        "anatomy",
        "anchor",
        "anchovy",
        "ancient",
        "android",
        "anemia",
        "anemic",
        "aneurism",
        "anew",
        "angelfish",
        "angelic",
        "anger",
        "angled",
        "angler",
        "angles",
        "angling",
        "angrily",
        "angriness",
        "anguished",
        "angular",
        "animal",
        "animate",
        "animating",
        "animation",
        "animator",
        "anime",
        "animosity",
        "ankle",
        "annex",
        "annotate",
        "announcer",
        "annoying",
        "annually",
        "annuity",
        "anointer",
        "another",
        "answering",
        "antacid",
        "antarctic",
        "anteater",
        "antelope",
        "antennae",
        "anthem",
        "anthill",
        "anthology",
        "antibody",
        "antics",
        "antidote",
        "antihero",
        "antiquely",
        "antiques",
        "antiquity",
        "antirust",
        "antitoxic",
        "antitrust",
        "antiviral",
        "antivirus",
        "antler",
        "antonym",
        "antsy",
        "anvil",
        "anybody",
        "anyhow",
        "anymore",
        "anyone",
        "anyplace",
        "anything",
        "anytime",
        "anyway",
        "anywhere",
        "aorta",
        "apache",
        "apostle",
        "appealing",
        "appear",
        "appease",
        "appeasing",
        "appendage",
        "appendix",
        "appetite",
        "appetizer",
        "applaud",
        "applause",
        "apple",
        "appliance",
        "applicant",
        "applied",
        "apply",
        "appointee",
        "appraisal",
        "appraiser",
        "apprehend",
        "approach",
        "approval",
        "approve",
        "apricot",
        "april",
        "apron",
        "aptitude",
        "aptly",
        "aqua",
        "aqueduct",
        "arbitrary",
        "arbitrate",
        "ardently",
        "area",
        "arena",
        "arguable",
        "arguably",
        "argue",
        "arise",
        "armadillo",
        "armband",
        "armchair",
        "armed",
        "armful",
        "armhole",
        "arming",
        "armless",
        "armoire",
        "armored",
        "armory",
        "armrest",
        "army",
        "aroma",
        "arose",
        "around",
        "arousal",
        "arrange",
        "array",
        "arrest",
        "arrival",
        "arrive",
        "arrogance",
        "arrogant",
        "arson",
        "art",
        "ascend",
        "ascension",
        "ascent",
        "ascertain",
        "ashamed",
        "ashen",
        "ashes",
        "ashy",
        "aside",
        "askew",
        "asleep",
        "asparagus",
        "aspect",
        "aspirate",
        "aspire",
        "aspirin",
        "astonish",
        "astound",
        "astride",
        "astrology",
        "astronaut",
        "astronomy",
        "astute",
        "atlantic",
        "atlas",
        "atom",
        "atonable",
        "atop",
        "atrium",
        "atrocious",
        "atrophy",
        "attach",
        "attain",
        "attempt",
        "attendant",
        "attendee",
        "attention",
        "attentive",
        "attest",
        "attic",
        "attire",
        "attitude",
        "attractor",
        "attribute",
        "atypical",
        "auction",
        "audacious",
        "audacity",
        "audible",
        "audibly",
        "audience",
        "audio",
        "audition",
        "augmented",
        "august",
        "authentic",
        "author",
        "autism",
        "autistic",
        "autograph",
        "automaker",
        "automated",
        "automatic",
        "autopilot",
        "available",
        "avalanche",
        "avatar",
        "avenge",
        "avenging",
        "avenue",
        "average",
        "aversion",
        "avert",
        "aviation",
        "aviator",
        "avid",
        "avoid",
        "await",
        "awaken",
        "award",
        "aware",
        "awhile",
        "awkward",
        "awning",
        "awoke",
        "awry",
        "axis",
        "babble",
        "babbling",
        "babied",
        "baboon",
        "backache",
        "backboard",
        "backboned",
        "backdrop",
        "backed",
        "backer",
        "backfield",
        "backfire",
        "backhand",
        "backing",
        "backlands",
        "backlash",
        "backless",
        "backlight",
        "backlit",
        "backlog",
        "backpack",
        "backpedal",
        "backrest",
        "backroom",
        "backshift",
        "backside",
        "backslid",
        "backspace",
        "backspin",
        "backstab",
        "backstage",
        "backtalk",
        "backtrack",
        "backup",
        "backward",
        "backwash",
        "backwater",
        "backyard",
        "bacon",
        "bacteria",
        "bacterium",
        "badass",
        "badge",
        "badland",
        "badly",
        "badness",
        "baffle",
        "baffling",
        "bagel",
        "bagful",
        "baggage",
        "bagged",
        "baggie",
        "bagginess",
        "bagging",
        "baggy",
        "bagpipe",
        "baguette",
        "baked",
        "bakery",
        "bakeshop",
        "baking",
        "balance",
        "balancing",
        "balcony",
        "balmy",
        "balsamic",
        "bamboo",
        "banana",
        "banish",
        "banister",
        "banjo",
        "bankable",
        "bankbook",
        "banked",
        "banker",
        "banking",
        "banknote",
        "bankroll",
        "banner",
        "bannister",
        "banshee",
        "banter",
        "barbecue",
        "barbed",
        "barbell",
        "barber",
        "barcode",
        "barge",
        "bargraph",
        "barista",
        "baritone",
        "barley",
        "barmaid",
        "barman",
        "barn",
        "barometer",
        "barrack",
        "barracuda",
        "barrel",
        "barrette",
        "barricade",
        "barrier",
        "barstool",
        "bartender",
        "barterer",
        "bash",
        "basically",
        "basics",
        "basil",
        "basin",
        "basis",
        "basket",
        "batboy",
        "batch",
        "bath",
        "baton",
        "bats",
        "battalion",
        "battered",
        "battering",
        "battery",
        "batting",
        "battle",
        "bauble",
        "bazooka",
        "blabber",
        "bladder",
        "blade",
        "blah",
        "blame",
        "blaming",
        "blanching",
        "blandness",
        "blank",
        "blaspheme",
        "blasphemy",
        "blast",
        "blatancy",
        "blatantly",
        "blazer",
        "blazing",
        "bleach",
        "bleak",
        "bleep",
        "blemish",
        "blend",
        "bless",
        "blighted",
        "blimp",
        "bling",
        "blinked",
        "blinker",
        "blinking",
        "blinks",
        "blip",
        "blissful",
        "blitz",
        "blizzard",
        "bloated",
        "bloating",
        "blob",
        "blog",
        "bloomers",
        "blooming",
        "blooper",
        "blot",
        "blouse",
        "blubber",
        "bluff",
        "bluish",
        "blunderer",
        "blunt",
        "blurb",
        "blurred",
        "blurry",
        "blurt",
        "blush",
        "blustery",
        "boaster",
        "boastful",
        "boasting",
        "boat",
        "bobbed",
        "bobbing",
        "bobble",
        "bobcat",
        "bobsled",
        "bobtail",
        "bodacious",
        "body",
        "bogged",
        "boggle",
        "bogus",
        "boil",
        "bok",
        "bolster",
        "bolt",
        "bonanza",
        "bonded",
        "bonding",
        "bondless",
        "boned",
        "bonehead",
        "boneless",
        "bonelike",
        "boney",
        "bonfire",
        "bonnet",
        "bonsai",
        "bonus",
        "bony",
        "boogeyman",
        "boogieman",
        "book",
        "boondocks",
        "booted",
        "booth",
        "bootie",
        "booting",
        "bootlace",
        "bootleg",
        "boots",
        "boozy",
        "borax",
        "boring",
        "borough",
        "borrower",
        "borrowing",
        "boss",
        "botanical",
        "botanist",
        "botany",
        "botch",
        "both",
        "bottle",
        "bottling",
        "bottom",
        "bounce",
        "bouncing",
        "bouncy",
        "bounding",
        "boundless",
        "bountiful",
        "bovine",
        "boxcar",
        "boxer",
        "boxing",
        "boxlike",
        "boxy",
        "breach",
        "breath",
        "breeches",
        "breeching",
        "breeder",
        "breeding",
        "breeze",
        "breezy",
        "brethren",
        "brewery",
        "brewing",
        "briar",
        "bribe",
        "brick",
        "bride",
        "bridged",
        "brigade",
        "bright",
        "brilliant",
        "brim",
        "bring",
        "brink",
        "brisket",
        "briskly",
        "briskness",
        "bristle",
        "brittle",
        "broadband",
        "broadcast",
        "broaden",
        "broadly",
        "broadness",
        "broadside",
        "broadways",
        "broiler",
        "broiling",
        "broken",
        "broker",
        "bronchial",
        "bronco",
        "bronze",
        "bronzing",
        "brook",
        "broom",
        "brought",
        "browbeat",
        "brownnose",
        "browse",
        "browsing",
        "bruising",
        "brunch",
        "brunette",
        "brunt",
        "brush",
        "brussels",
        "brute",
        "brutishly",
        "bubble",
        "bubbling",
        "bubbly",
        "buccaneer",
        "bucked",
        "bucket",
        "buckle",
        "buckshot",
        "buckskin",
        "bucktooth",
        "buckwheat",
        "buddhism",
        "buddhist",
        "budding",
        "buddy",
        "budget",
        "buffalo",
        "buffed",
        "buffer",
        "buffing",
        "buffoon",
        "buggy",
        "bulb",
        "bulge",
        "bulginess",
        "bulgur",
        "bulk",
        "bulldog",
        "bulldozer",
        "bullfight",
        "bullfrog",
        "bullhorn",
        "bullion",
        "bullish",
        "bullpen",
        "bullring",
        "bullseye",
        "bullwhip",
        "bully",
        "bunch",
        "bundle",
        "bungee",
        "bunion",
        "bunkbed",
        "bunkhouse",
        "bunkmate",
        "bunny",
        "bunt",
        "busboy",
        "bush",
        "busily",
        "busload",
        "bust",
        "busybody",
        "buzz",
        "cabana",
        "cabbage",
        "cabbie",
        "cabdriver",
        "cable",
        "caboose",
        "cache",
        "cackle",
        "cacti",
        "cactus",
        "caddie",
        "caddy",
        "cadet",
        "cadillac",
        "cadmium",
        "cage",
        "cahoots",
        "cake",
        "calamari",
        "calamity",
        "calcium",
        "calculate",
        "calculus",
        "caliber",
        "calibrate",
        "calm",
        "caloric",
        "calorie",
        "calzone",
        "camcorder",
        "cameo",
        "camera",
        "camisole",
        "camper",
        "campfire",
        "camping",
        "campsite",
        "campus",
        "canal",
        "canary",
        "cancel",
        "candied",
        "candle",
        "candy",
        "cane",
        "canine",
        "canister",
        "cannabis",
        "canned",
        "canning",
        "cannon",
        "cannot",
        "canola",
        "canon",
        "canopener",
        "canopy",
        "canteen",
        "canyon",
        "capable",
        "capably",
        "capacity",
        "cape",
        "capillary",
        "capital",
        "capitol",
        "capped",
        "capricorn",
        "capsize",
        "capsule",
        "caption",
        "captivate",
        "captive",
        "captivity",
        "capture",
        "caramel",
        "carat",
        "caravan",
        "carbon",
        "cardboard",
        "carded",
        "cardiac",
        "cardigan",
        "cardinal",
        "cardstock",
        "carefully",
        "caregiver",
        "careless",
        "caress",
        "caretaker",
        "cargo",
        "caring",
        "carless",
        "carload",
        "carmaker",
        "carnage",
        "carnation",
        "carnival",
        "carnivore",
        "carol",
        "carpenter",
        "carpentry",
        "carpool",
        "carport",
        "carried",
        "carrot",
        "carrousel",
        "carry",
        "cartel",
        "cartload",
        "carton",
        "cartoon",
        "cartridge",
        "cartwheel",
        "carve",
        "carving",
        "carwash",
        "cascade",
        "case",
        "cash",
        "casing",
        "casino",
        "casket",
        "cassette",
        "casually",
        "casualty",
        "catacomb",
        "catalog",
        "catalyst",
        "catalyze",
        "catapult",
        "cataract",
        "catatonic",
        "catcall",
        "catchable",
        "catcher",
        "catching",
        "catchy",
        "caterer",
        "catering",
        "catfight",
        "catfish",
        "cathedral",
        "cathouse",
        "catlike",
        "catnap",
        "catnip",
        "catsup",
        "cattail",
        "cattishly",
        "cattle",
        "catty",
        "catwalk",
        "caucasian",
        "caucus",
        "causal",
        "causation",
        "cause",
        "causing",
        "cauterize",
        "caution",
        "cautious",
        "cavalier",
        "cavalry",
        "caviar",
        "cavity",
        "cedar",
        "celery",
        "celestial",
        "celibacy",
        "celibate",
        "celtic",
        "cement",
        "census",
        "ceramics",
        "ceremony",
        "certainly",
        "certainty",
        "certified",
        "certify",
        "cesarean",
        "cesspool",
        "chafe",
        "chaffing",
        "chain",
        "chair",
        "chalice",
        "challenge",
        "chamber",
        "chamomile",
        "champion",
        "chance",
        "change",
        "channel",
        "chant",
        "chaos",
        "chaperone",
        "chaplain",
        "chapped",
        "chaps",
        "chapter",
        "character",
        "charbroil",
        "charcoal",
        "charger",
        "charging",
        "chariot",
        "charity",
        "charm",
        "charred",
        "charter",
        "charting",
        "chase",
        "chasing",
        "chaste",
        "chastise",
        "chastity",
        "chatroom",
        "chatter",
        "chatting",
        "chatty",
        "cheating",
        "cheddar",
        "cheek",
        "cheer",
        "cheese",
        "cheesy",
        "chef",
        "chemicals",
        "chemist",
        "chemo",
        "cherisher",
        "cherub",
        "chess",
        "chest",
        "chevron",
        "chevy",
        "chewable",
        "chewer",
        "chewing",
        "chewy",
        "chief",
        "chihuahua",
        "childcare",
        "childhood",
        "childish",
        "childless",
        "childlike",
        "chili",
        "chill",
        "chimp",
        "chip",
        "chirping",
        "chirpy",
        "chitchat",
        "chivalry",
        "chive",
        "chloride",
        "chlorine",
        "choice",
        "chokehold",
        "choking",
        "chomp",
        "chooser",
        "choosing",
        "choosy",
        "chop",
        "chosen",
        "chowder",
        "chowtime",
        "chrome",
        "chubby",
        "chuck",
        "chug",
        "chummy",
        "chump",
        "chunk",
        "churn",
        "chute",
        "cider",
        "cilantro",
        "cinch",
        "cinema",
        "cinnamon",
        "circle",
        "circling",
        "circular",
        "circulate",
        "circus",
        "citable",
        "citadel",
        "citation",
        "citizen",
        "citric",
        "citrus",
        "city",
        "civic",
        "civil",
        "clad",
        "claim",
        "clambake",
        "clammy",
        "clamor",
        "clamp",
        "clamshell",
        "clang",
        "clanking",
        "clapped",
        "clapper",
        "clapping",
        "clarify",
        "clarinet",
        "clarity",
        "clash",
        "clasp",
        "class",
        "clatter",
        "clause",
        "clavicle",
        "claw",
        "clay",
        "clean",
        "clear",
        "cleat",
        "cleaver",
        "cleft",
        "clench",
        "clergyman",
        "clerical",
        "clerk",
        "clever",
        "clicker",
        "client",
        "climate",
        "climatic",
        "cling",
        "clinic",
        "clinking",
        "clip",
        "clique",
        "cloak",
        "clobber",
        "clock",
        "clone",
        "cloning",
        "closable",
        "closure",
        "clothes",
        "clothing",
        "cloud",
        "clover",
        "clubbed",
        "clubbing",
        "clubhouse",
        "clump",
        "clumsily",
        "clumsy",
        "clunky",
        "clustered",
        "clutch",
        "clutter",
        "coach",
        "coagulant",
        "coastal",
        "coaster",
        "coasting",
        "coastland",
        "coastline",
        "coat",
        "coauthor",
        "cobalt",
        "cobbler",
        "cobweb",
        "cocoa",
        "coconut",
        "cod",
        "coeditor",
        "coerce",
        "coexist",
        "coffee",
        "cofounder",
        "cognition",
        "cognitive",
        "cogwheel",
        "coherence",
        "coherent",
        "cohesive",
        "coil",
        "coke",
        "cola",
        "cold",
        "coleslaw",
        "coliseum",
        "collage",
        "collapse",
        "collar",
        "collected",
        "collector",
        "collide",
        "collie",
        "collision",
        "colonial",
        "colonist",
        "colonize",
        "colony",
        "colossal",
        "colt",
        "coma",
        "come",
        "comfort",
        "comfy",
        "comic",
        "coming",
        "comma",
        "commence",
        "commend",
        "comment",
        "commerce",
        "commode",
        "commodity",
        "commodore",
        "common",
        "commotion",
        "commute",
        "commuting",
        "compacted",
        "compacter",
        "compactly",
        "compactor",
        "companion",
        "company",
        "compare",
        "compel",
        "compile",
        "comply",
        "component",
        "composed",
        "composer",
        "composite",
        "compost",
        "composure",
        "compound",
        "compress",
        "comprised",
        "computer",
        "computing",
        "comrade",
        "concave",
        "conceal",
        "conceded",
        "concept",
        "concerned",
        "concert",
        "conch",
        "concierge",
        "concise",
        "conclude",
        "concrete",
        "concur",
        "condense",
        "condiment",
        "condition",
        "condone",
        "conducive",
        "conductor",
        "conduit",
        "cone",
        "confess",
        "confetti",
        "confidant",
        "confident",
        "confider",
        "confiding",
        "configure",
        "confined",
        "confining",
        "confirm",
        "conflict",
        "conform",
        "confound",
        "confront",
        "confused",
        "confusing",
        "confusion",
        "congenial",
        "congested",
        "congrats",
        "congress",
        "conical",
        "conjoined",
        "conjure",
        "conjuror",
        "connected",
        "connector",
        "consensus",
        "consent",
        "console",
        "consoling",
        "consonant",
        "constable",
        "constant",
        "constrain",
        "constrict",
        "construct",
        "consult",
        "consumer",
        "consuming",
        "contact",
        "container",
        "contempt",
        "contend",
        "contented",
        "contently",
        "contents",
        "contest",
        "context",
        "contort",
        "contour",
        "contrite",
        "control",
        "contusion",
        "convene",
        "convent",
        "copartner",
        "cope",
        "copied",
        "copier",
        "copilot",
        "coping",
        "copious",
        "copper",
        "copy",
        "coral",
        "cork",
        "cornball",
        "cornbread",
        "corncob",
        "cornea",
        "corned",
        "corner",
        "cornfield",
        "cornflake",
        "cornhusk",
        "cornmeal",
        "cornstalk",
        "corny",
        "coronary",
        "coroner",
        "corporal",
        "corporate",
        "corral",
        "correct",
        "corridor",
        "corrode",
        "corroding",
        "corrosive",
        "corsage",
        "corset",
        "cortex",
        "cosigner",
        "cosmetics",
        "cosmic",
        "cosmos",
        "cosponsor",
        "cost",
        "cottage",
        "cotton",
        "couch",
        "cough",
        "could",
        "countable",
        "countdown",
        "counting",
        "countless",
        "country",
        "county",
        "courier",
        "covenant",
        "cover",
        "coveted",
        "coveting",
        "coyness",
        "cozily",
        "coziness",
        "cozy",
        "crabbing",
        "crabgrass",
        "crablike",
        "crabmeat",
        "cradle",
        "cradling",
        "crafter",
        "craftily",
        "craftsman",
        "craftwork",
        "crafty",
        "cramp",
        "cranberry",
        "crane",
        "cranial",
        "cranium",
        "crank",
        "crate",
        "crave",
        "craving",
        "crawfish",
        "crawlers",
        "crawling",
        "crayfish",
        "crayon",
        "crazed",
        "crazily",
        "craziness",
        "crazy",
        "creamed",
        "creamer",
        "creamlike",
        "crease",
        "creasing",
        "creatable",
        "create",
        "creation",
        "creative",
        "creature",
        "credible",
        "credibly",
        "credit",
        "creed",
        "creme",
        "creole",
        "crepe",
        "crept",
        "crescent",
        "crested",
        "cresting",
        "crestless",
        "crevice",
        "crewless",
        "crewman",
        "crewmate",
        "crib",
        "cricket",
        "cried",
        "crier",
        "crimp",
        "crimson",
        "cringe",
        "cringing",
        "crinkle",
        "crinkly",
        "crisped",
        "crisping",
        "crisply",
        "crispness",
        "crispy",
        "criteria",
        "critter",
        "croak",
        "crock",
        "crook",
        "croon",
        "crop",
        "cross",
        "crouch",
        "crouton",
        "crowbar",
        "crowd",
        "crown",
        "crucial",
        "crudely",
        "crudeness",
        "cruelly",
        "cruelness",
        "cruelty",
        "crumb",
        "crummiest",
        "crummy",
        "crumpet",
        "crumpled",
        "cruncher",
        "crunching",
        "crunchy",
        "crusader",
        "crushable",
        "crushed",
        "crusher",
        "crushing",
        "crust",
        "crux",
        "crying",
        "cryptic",
        "crystal",
        "cubbyhole",
        "cube",
        "cubical",
        "cubicle",
        "cucumber",
        "cuddle",
        "cuddly",
        "cufflink",
        "culinary",
        "culminate",
        "culpable",
        "culprit",
        "cultivate",
        "cultural",
        "culture",
        "cupbearer",
        "cupcake",
        "cupid",
        "cupped",
        "cupping",
        "curable",
        "curator",
        "curdle",
        "cure",
        "curfew",
        "curing",
        "curled",
        "curler",
        "curliness",
        "curling",
        "curly",
        "curry",
        "curse",
        "cursive",
        "cursor",
        "curtain",
        "curtly",
        "curtsy",
        "curvature",
        "curve",
        "curvy",
        "cushy",
        "cusp",
        "cussed",
        "custard",
        "custodian",
        "custody",
        "customary",
        "customer",
        "customize",
        "customs",
        "cut",
        "cycle",
        "cyclic",
        "cycling",
        "cyclist",
        "cylinder",
        "cymbal",
        "cytoplasm",
        "cytoplast",
        "dab",
        "dad",
        "daffodil",
        "dagger",
        "daily",
        "daintily",
        "dainty",
        "dairy",
        "daisy",
        "dallying",
        "dance",
        "dancing",
        "dandelion",
        "dander",
        "dandruff",
        "dandy",
        "danger",
        "dangle",
        "dangling",
        "daredevil",
        "dares",
        "daringly",
        "darkened",
        "darkening",
        "darkish",
        "darkness",
        "darkroom",
        "darling",
        "darn",
        "dart",
        "darwinism",
        "dash",
        "dastardly",
        "data",
        "datebook",
        "dating",
        "daughter",
        "daunting",
        "dawdler",
        "dawn",
        "daybed",
        "daybreak",
        "daycare",
        "daydream",
        "daylight",
        "daylong",
        "dayroom",
        "daytime",
        "dazzler",
        "dazzling",
        "deacon",
        "deafening",
        "deafness",
        "dealer",
        "dealing",
        "dealmaker",
        "dealt",
        "dean",
        "debatable",
        "debate",
        "debating",
        "debit",
        "debrief",
        "debtless",
        "debtor",
        "debug",
        "debunk",
        "decade",
        "decaf",
        "decal",
        "decathlon",
        "decay",
        "deceased",
        "deceit",
        "deceiver",
        "deceiving",
        "december",
        "decency",
        "decent",
        "deception",
        "deceptive",
        "decibel",
        "decidable",
        "decimal",
        "decimeter",
        "decipher",
        "deck",
        "declared",
        "decline",
        "decode",
        "decompose",
        "decorated",
        "decorator",
        "decoy",
        "decrease",
        "decree",
        "dedicate",
        "dedicator",
        "deduce",
        "deduct",
        "deed",
        "deem",
        "deepen",
        "deeply",
        "deepness",
        "deface",
        "defacing",
        "defame",
        "default",
        "defeat",
        "defection",
        "defective",
        "defendant",
        "defender",
        "defense",
        "defensive",
        "deferral",
        "deferred",
        "defiance",
        "defiant",
        "defile",
        "defiling",
        "define",
        "definite",
        "deflate",
        "deflation",
        "deflator",
        "deflected",
        "deflector",
        "defog",
        "deforest",
        "defraud",
        "defrost",
        "deftly",
        "defuse",
        "defy",
        "degraded",
        "degrading",
        "degrease",
        "degree",
        "dehydrate",
        "deity",
        "dejected",
        "delay",
        "delegate",
        "delegator",
        "delete",
        "deletion",
        "delicacy",
        "delicate",
        "delicious",
        "delighted",
        "delirious",
        "delirium",
        "deliverer",
        "delivery",
        "delouse",
        "delta",
        "deluge",
        "delusion",
        "deluxe",
        "demanding",
        "demeaning",
        "demeanor",
        "demise",
        "democracy",
        "democrat",
        "demote",
        "demotion",
        "demystify",
        "denatured",
        "deniable",
        "denial",
        "denim",
        "denote",
        "dense",
        "density",
        "dental",
        "dentist",
        "denture",
        "deny",
        "deodorant",
        "deodorize",
        "departed",
        "departure",
        "depict",
        "deplete",
        "depletion",
        "deplored",
        "deploy",
        "deport",
        "depose",
        "depraved",
        "depravity",
        "deprecate",
        "depress",
        "deprive",
        "depth",
        "deputize",
        "deputy",
        "derail",
        "deranged",
        "derby",
        "derived",
        "desecrate",
        "deserve",
        "deserving",
        "designate",
        "designed",
        "designer",
        "designing",
        "deskbound",
        "desktop",
        "deskwork",
        "desolate",
        "despair",
        "despise",
        "despite",
        "destiny",
        "destitute",
        "destruct",
        "detached",
        "detail",
        "detection",
        "detective",
        "detector",
        "detention",
        "detergent",
        "detest",
        "detonate",
        "detonator",
        "detoxify",
        "detract",
        "deuce",
        "devalue",
        "deviancy",
        "deviant",
        "deviate",
        "deviation",
        "deviator",
        "device",
        "devious",
        "devotedly",
        "devotee",
        "devotion",
        "devourer",
        "devouring",
        "devoutly",
        "dexterity",
        "dexterous",
        "diabetes",
        "diabetic",
        "diabolic",
        "diagnoses",
        "diagnosis",
        "diagram",
        "dial",
        "diameter",
        "diaper",
        "diaphragm",
        "diary",
        "dice",
        "dicing",
        "dictate",
        "dictation",
        "dictator",
        "difficult",
        "diffused",
        "diffuser",
        "diffusion",
        "diffusive",
        "dig",
        "dilation",
        "diligence",
        "diligent",
        "dill",
        "dilute",
        "dime",
        "diminish",
        "dimly",
        "dimmed",
        "dimmer",
        "dimness",
        "dimple",
        "diner",
        "dingbat",
        "dinghy",
        "dinginess",
        "dingo",
        "dingy",
        "dining",
        "dinner",
        "diocese",
        "dioxide",
        "diploma",
        "dipped",
        "dipper",
        "dipping",
        "directed",
        "direction",
        "directive",
        "directly",
        "directory",
        "direness",
        "dirtiness",
        "disabled",
        "disagree",
        "disallow",
        "disarm",
        "disarray",
        "disaster",
        "disband",
        "disbelief",
        "disburse",
        "discard",
        "discern",
        "discharge",
        "disclose",
        "discolor",
        "discount",
        "discourse",
        "discover",
        "discuss",
        "disdain",
        "disengage",
        "disfigure",
        "disgrace",
        "dish",
        "disinfect",
        "disjoin",
        "disk",
        "dislike",
        "disliking",
        "dislocate",
        "dislodge",
        "disloyal",
        "dismantle",
        "dismay",
        "dismiss",
        "dismount",
        "disobey",
        "disorder",
        "disown",
        "disparate",
        "disparity",
        "dispatch",
        "dispense",
        "dispersal",
        "dispersed",
        "disperser",
        "displace",
        "display",
        "displease",
        "disposal",
        "dispose",
        "disprove",
        "dispute",
        "disregard",
        "disrupt",
        "dissuade",
        "distance",
        "distant",
        "distaste",
        "distill",
        "distinct",
        "distort",
        "distract",
        "distress",
        "district",
        "distrust",
        "ditch",
        "ditto",
        "ditzy",
        "dividable",
        "divided",
        "dividend",
        "dividers",
        "dividing",
        "divinely",
        "diving",
        "divinity",
        "divisible",
        "divisibly",
        "division",
        "divisive",
        "divorcee",
        "dizziness",
        "dizzy",
        "doable",
        "docile",
        "dock",
        "doctrine",
        "document",
        "dodge",
        "dodgy",
        "doily",
        "doing",
        "dole",
        "dollar",
        "dollhouse",
        "dollop",
        "dolly",
        "dolphin",
        "domain",
        "domelike",
        "domestic",
        "dominion",
        "dominoes",
        "donated",
        "donation",
        "donator",
        "donor",
        "donut",
        "doodle",
        "doorbell",
        "doorframe",
        "doorknob",
        "doorman",
        "doormat",
        "doornail",
        "doorpost",
        "doorstep",
        "doorstop",
        "doorway",
        "doozy",
        "dork",
        "dormitory",
        "dorsal",
        "dosage",
        "dose",
        "dotted",
        "doubling",
        "douche",
        "dove",
        "down",
        "dowry",
        "doze",
        "drab",
        "dragging",
        "dragonfly",
        "dragonish",
        "dragster",
        "drainable",
        "drainage",
        "drained",
        "drainer",
        "drainpipe",
        "dramatic",
        "dramatize",
        "drank",
        "drapery",
        "drastic",
        "draw",
        "dreaded",
        "dreadful",
        "dreadlock",
        "dreamboat",
        "dreamily",
        "dreamland",
        "dreamless",
        "dreamlike",
        "dreamt",
        "dreamy",
        "drearily",
        "dreary",
        "drench",
        "dress",
        "drew",
        "dribble",
        "dried",
        "drier",
        "drift",
        "driller",
        "drilling",
        "drinkable",
        "drinking",
        "dripping",
        "drippy",
        "drivable",
        "driven",
        "driver",
        "driveway",
        "driving",
        "drizzle",
        "drizzly",
        "drone",
        "drool",
        "droop",
        "drop-down",
        "dropbox",
        "dropkick",
        "droplet",
        "dropout",
        "dropper",
        "drove",
        "drown",
        "drowsily",
        "drudge",
        "drum",
        "dry",
        "dubbed",
        "dubiously",
        "duchess",
        "duckbill",
        "ducking",
        "duckling",
        "ducktail",
        "ducky",
        "duct",
        "dude",
        "duffel",
        "dugout",
        "duh",
        "duke",
        "duller",
        "dullness",
        "duly",
        "dumping",
        "dumpling",
        "dumpster",
        "duo",
        "dupe",
        "duplex",
        "duplicate",
        "duplicity",
        "durable",
        "durably",
        "duration",
        "duress",
        "during",
        "dusk",
        "dust",
        "dutiful",
        "duty",
        "duvet",
        "dwarf",
        "dweeb",
        "dwelled",
        "dweller",
        "dwelling",
        "dwindle",
        "dwindling",
        "dynamic",
        "dynamite",
        "dynasty",
        "dyslexia",
        "dyslexic",
        "each",
        "eagle",
        "earache",
        "eardrum",
        "earflap",
        "earful",
        "earlobe",
        "early",
        "earmark",
        "earmuff",
        "earphone",
        "earpiece",
        "earplugs",
        "earring",
        "earshot",
        "earthen",
        "earthlike",
        "earthling",
        "earthly",
        "earthworm",
        "earthy",
        "earwig",
        "easeful",
        "easel",
        "easiest",
        "easily",
        "easiness",
        "easing",
        "eastbound",
        "eastcoast",
        "easter",
        "eastward",
        "eatable",
        "eaten",
        "eatery",
        "eating",
        "eats",
        "ebay",
        "ebony",
        "ebook",
        "ecard",
        "eccentric",
        "echo",
        "eclair",
        "eclipse",
        "ecologist",
        "ecology",
        "economic",
        "economist",
        "economy",
        "ecosphere",
        "ecosystem",
        "edge",
        "edginess",
        "edging",
        "edgy",
        "edition",
        "editor",
        "educated",
        "education",
        "educator",
        "eel",
        "effective",
        "effects",
        "efficient",
        "effort",
        "eggbeater",
        "egging",
        "eggnog",
        "eggplant",
        "eggshell",
        "egomaniac",
        "egotism",
        "egotistic",
        "either",
        "eject",
        "elaborate",
        "elastic",
        "elated",
        "elbow",
        "eldercare",
        "elderly",
        "eldest",
        "electable",
        "election",
        "elective",
        "elephant",
        "elevate",
        "elevating",
        "elevation",
        "elevator",
        "eleven",
        "elf",
        "eligible",
        "eligibly",
        "eliminate",
        "elite",
        "elitism",
        "elixir",
        "elk",
        "ellipse",
        "elliptic",
        "elm",
        "elongated",
        "elope",
        "eloquence",
        "eloquent",
        "elsewhere",
        "elude",
        "elusive",
        "elves",
        "email",
        "embargo",
        "embark",
        "embassy",
        "embattled",
        "embellish",
        "ember",
        "embezzle",
        "emblaze",
        "emblem",
        "embody",
        "embolism",
        "emboss",
        "embroider",
        "emcee",
        "emerald",
        "emergency",
        "emission",
        "emit",
        "emote",
        "emoticon",
        "emotion",
        "empathic",
        "empathy",
        "emperor",
        "emphases",
        "emphasis",
        "emphasize",
        "emphatic",
        "empirical",
        "employed",
        "employee",
        "employer",
        "emporium",
        "empower",
        "emptier",
        "emptiness",
        "empty",
        "emu",
        "enable",
        "enactment",
        "enamel",
        "enchanted",
        "enchilada",
        "encircle",
        "enclose",
        "enclosure",
        "encode",
        "encore",
        "encounter",
        "encourage",
        "encroach",
        "encrust",
        "encrypt",
        "endanger",
        "endeared",
        "endearing",
        "ended",
        "ending",
        "endless",
        "endnote",
        "endocrine",
        "endorphin",
        "endorse",
        "endowment",
        "endpoint",
        "endurable",
        "endurance",
        "enduring",
        "energetic",
        "energize",
        "energy",
        "enforced",
        "enforcer",
        "engaged",
        "engaging",
        "engine",
        "engorge",
        "engraved",
        "engraver",
        "engraving",
        "engross",
        "engulf",
        "enhance",
        "enigmatic",
        "enjoyable",
        "enjoyably",
        "enjoyer",
        "enjoying",
        "enjoyment",
        "enlarged",
        "enlarging",
        "enlighten",
        "enlisted",
        "enquirer",
        "enrage",
        "enrich",
        "enroll",
        "enslave",
        "ensnare",
        "ensure",
        "entail",
        "entangled",
        "entering",
        "entertain",
        "enticing",
        "entire",
        "entitle",
        "entity",
        "entomb",
        "entourage",
        "entrap",
        "entree",
        "entrench",
        "entrust",
        "entryway",
        "entwine",
        "enunciate",
        "envelope",
        "enviable",
        "enviably",
        "envious",
        "envision",
        "envoy",
        "envy",
        "enzyme",
        "epic",
        "epidemic",
        "epidermal",
        "epidermis",
        "epidural",
        "epilepsy",
        "epileptic",
        "epilogue",
        "epiphany",
        "episode",
        "equal",
        "equate",
        "equation",
        "equator",
        "equinox",
        "equipment",
        "equity",
        "equivocal",
        "eradicate",
        "erasable",
        "erased",
        "eraser",
        "erasure",
        "ergonomic",
        "errand",
        "errant",
        "erratic",
        "error",
        "erupt",
        "escalate",
        "escalator",
        "escapable",
        "escapade",
        "escapist",
        "escargot",
        "eskimo",
        "esophagus",
        "espionage",
        "espresso",
        "esquire",
        "essay",
        "essence",
        "essential",
        "establish",
        "estate",
        "esteemed",
        "estimate",
        "estimator",
        "estranged",
        "estrogen",
        "etching",
        "eternal",
        "eternity",
        "ethanol",
        "ether",
        "ethically",
        "ethics",
        "euphemism",
        "evacuate",
        "evacuee",
        "evade",
        "evaluate",
        "evaluator",
        "evaporate",
        "evasion",
        "evasive",
        "even",
        "everglade",
        "evergreen",
        "everybody",
        "everyday",
        "everyone",
        "evict",
        "evidence",
        "evident",
        "evil",
        "evoke",
        "evolution",
        "evolve",
        "exact",
        "exalted",
        "example",
        "excavate",
        "excavator",
        "exceeding",
        "exception",
        "excess",
        "exchange",
        "excitable",
        "exciting",
        "exclaim",
        "exclude",
        "excluding",
        "exclusion",
        "exclusive",
        "excretion",
        "excretory",
        "excursion",
        "excusable",
        "excusably",
        "excuse",
        "exemplary",
        "exemplify",
        "exemption",
        "exerciser",
        "exert",
        "exes",
        "exfoliate",
        "exhale",
        "exhaust",
        "exhume",
        "exile",
        "existing",
        "exit",
        "exodus",
        "exonerate",
        "exorcism",
        "exorcist",
        "expand",
        "expanse",
        "expansion",
        "expansive",
        "expectant",
        "expedited",
        "expediter",
        "expel",
        "expend",
        "expenses",
        "expensive",
        "expert",
        "expire",
        "expiring",
        "explain",
        "expletive",
        "explicit",
        "explode",
        "exploit",
        "explore",
        "exploring",
        "exponent",
        "exporter",
        "exposable",
        "expose",
        "exposure",
        "express",
        "expulsion",
        "exquisite",
        "extended",
        "extending",
        "extent",
        "extenuate",
        "exterior",
        "external",
        "extinct",
        "extortion",
        "extradite",
        "extras",
        "extrovert",
        "extrude",
        "extruding",
        "exuberant",
        "fable",
        "fabric",
        "fabulous",
        "facebook",
        "facecloth",
        "facedown",
        "faceless",
        "facelift",
        "faceplate",
        "faceted",
        "facial",
        "facility",
        "facing",
        "facsimile",
        "faction",
        "factoid",
        "factor",
        "factsheet",
        "factual",
        "faculty",
        "fade",
        "fading",
        "failing",
        "falcon",
        "fall",
        "false",
        "falsify",
        "fame",
        "familiar",
        "family",
        "famine",
        "famished",
        "fanatic",
        "fancied",
        "fanciness",
        "fancy",
        "fanfare",
        "fang",
        "fanning",
        "fantasize",
        "fantastic",
        "fantasy",
        "fascism",
        "fastball",
        "faster",
        "fasting",
        "fastness",
        "faucet",
        "favorable",
        "favorably",
        "favored",
        "favoring",
        "favorite",
        "fax",
        "feast",
        "federal",
        "fedora",
        "feeble",
        "feed",
        "feel",
        "feisty",
        "feline",
        "felt-tip",
        "feminine",
        "feminism",
        "feminist",
        "feminize",
        "femur",
        "fence",
        "fencing",
        "fender",
        "ferment",
        "fernlike",
        "ferocious",
        "ferocity",
        "ferret",
        "ferris",
        "ferry",
        "fervor",
        "fester",
        "festival",
        "festive",
        "festivity",
        "fetal",
        "fetch",
        "fever",
        "fiber",
        "fiction",
        "fiddle",
        "fiddling",
        "fidelity",
        "fidgeting",
        "fidgety",
        "fifteen",
        "fifth",
        "fiftieth",
        "fifty",
        "figment",
        "figure",
        "figurine",
        "filing",
        "filled",
        "filler",
        "filling",
        "film",
        "filter",
        "filth",
        "filtrate",
        "finale",
        "finalist",
        "finalize",
        "finally",
        "finance",
        "financial",
        "finch",
        "fineness",
        "finer",
        "finicky",
        "finished",
        "finisher",
        "finishing",
        "finite",
        "finless",
        "finlike",
        "fiscally",
        "fit",
        "five",
        "flaccid",
        "flagman",
        "flagpole",
        "flagship",
        "flagstick",
        "flagstone",
        "flail",
        "flakily",
        "flaky",
        "flame",
        "flammable",
        "flanked",
        "flanking",
        "flannels",
        "flap",
        "flaring",
        "flashback",
        "flashbulb",
        "flashcard",
        "flashily",
        "flashing",
        "flashy",
        "flask",
        "flatbed",
        "flatfoot",
        "flatly",
        "flatness",
        "flatten",
        "flattered",
        "flatterer",
        "flattery",
        "flattop",
        "flatware",
        "flatworm",
        "flavored",
        "flavorful",
        "flavoring",
        "flaxseed",
        "fled",
        "fleshed",
        "fleshy",
        "flick",
        "flier",
        "flight",
        "flinch",
        "fling",
        "flint",
        "flip",
        "flirt",
        "float",
        "flock",
        "flogging",
        "flop",
        "floral",
        "florist",
        "floss",
        "flounder",
        "flyable",
        "flyaway",
        "flyer",
        "flying",
        "flyover",
        "flypaper",
        "foam",
        "foe",
        "fog",
        "foil",
        "folic",
        "folk",
        "follicle",
        "follow",
        "fondling",
        "fondly",
        "fondness",
        "fondue",
        "font",
        "food",
        "fool",
        "footage",
        "football",
        "footbath",
        "footboard",
        "footer",
        "footgear",
        "foothill",
        "foothold",
        "footing",
        "footless",
        "footman",
        "footnote",
        "footpad",
        "footpath",
        "footprint",
        "footrest",
        "footsie",
        "footsore",
        "footwear",
        "footwork",
        "fossil",
        "foster",
        "founder",
        "founding",
        "fountain",
        "fox",
        "foyer",
        "fraction",
        "fracture",
        "fragile",
        "fragility",
        "fragment",
        "fragrance",
        "fragrant",
        "frail",
        "frame",
        "framing",
        "frantic",
        "fraternal",
        "frayed",
        "fraying",
        "frays",
        "freckled",
        "freckles",
        "freebase",
        "freebee",
        "freebie",
        "freedom",
        "freefall",
        "freehand",
        "freeing",
        "freeload",
        "freely",
        "freemason",
        "freeness",
        "freestyle",
        "freeware",
        "freeway",
        "freewill",
        "freezable",
        "freezing",
        "freight",
        "french",
        "frenzied",
        "frenzy",
        "frequency",
        "frequent",
        "fresh",
        "fretful",
        "fretted",
        "friction",
        "friday",
        "fridge",
        "fried",
        "friend",
        "frighten",
        "frightful",
        "frigidity",
        "frigidly",
        "frill",
        "fringe",
        "frisbee",
        "frisk",
        "fritter",
        "frivolous",
        "frolic",
        "from",
        "front",
        "frostbite",
        "frosted",
        "frostily",
        "frosting",
        "frostlike",
        "frosty",
        "froth",
        "frown",
        "frozen",
        "fructose",
        "frugality",
        "frugally",
        "fruit",
        "frustrate",
        "frying",
        "gab",
        "gaffe",
        "gag",
        "gainfully",
        "gaining",
        "gains",
        "gala",
        "gallantly",
        "galleria",
        "gallery",
        "galley",
        "gallon",
        "gallows",
        "gallstone",
        "galore",
        "galvanize",
        "gambling",
        "game",
        "gaming",
        "gamma",
        "gander",
        "gangly",
        "gangrene",
        "gangway",
        "gap",
        "garage",
        "garbage",
        "garden",
        "gargle",
        "garland",
        "garlic",
        "garment",
        "garnet",
        "garnish",
        "garter",
        "gas",
        "gatherer",
        "gathering",
        "gating",
        "gauging",
        "gauntlet",
        "gauze",
        "gave",
        "gawk",
        "gazing",
        "gear",
        "gecko",
        "geek",
        "geiger",
        "gem",
        "gender",
        "generic",
        "generous",
        "genetics",
        "genre",
        "gentile",
        "gentleman",
        "gently",
        "gents",
        "geography",
        "geologic",
        "geologist",
        "geology",
        "geometric",
        "geometry",
        "geranium",
        "gerbil",
        "geriatric",
        "germicide",
        "germinate",
        "germless",
        "germproof",
        "gestate",
        "gestation",
        "gesture",
        "getaway",
        "getting",
        "getup",
        "giant",
        "gibberish",
        "giblet",
        "giddily",
        "giddiness",
        "giddy",
        "gift",
        "gigabyte",
        "gigahertz",
        "gigantic",
        "giggle",
        "giggling",
        "giggly",
        "gigolo",
        "gilled",
        "gills",
        "gimmick",
        "girdle",
        "giveaway",
        "given",
        "giver",
        "giving",
        "gizmo",
        "gizzard",
        "glacial",
        "glacier",
        "glade",
        "gladiator",
        "gladly",
        "glamorous",
        "glamour",
        "glance",
        "glancing",
        "glandular",
        "glare",
        "glaring",
        "glass",
        "glaucoma",
        "glazing",
        "gleaming",
        "gleeful",
        "glider",
        "gliding",
        "glimmer",
        "glimpse",
        "glisten",
        "glitch",
        "glitter",
        "glitzy",
        "gloater",
        "gloating",
        "gloomily",
        "gloomy",
        "glorified",
        "glorifier",
        "glorify",
        "glorious",
        "glory",
        "gloss",
        "glove",
        "glowing",
        "glowworm",
        "glucose",
        "glue",
        "gluten",
        "glutinous",
        "glutton",
        "gnarly",
        "gnat",
        "goal",
        "goatskin",
        "goes",
        "goggles",
        "going",
        "goldfish",
        "goldmine",
        "goldsmith",
        "golf",
        "goliath",
        "gonad",
        "gondola",
        "gone",
        "gong",
        "good",
        "gooey",
        "goofball",
        "goofiness",
        "goofy",
        "google",
        "goon",
        "gopher",
        "gore",
        "gorged",
        "gorgeous",
        "gory",
        "gosling",
        "gossip",
        "gothic",
        "gotten",
        "gout",
        "gown",
        "grab",
        "graceful",
        "graceless",
        "gracious",
        "gradation",
        "graded",
        "grader",
        "gradient",
        "grading",
        "gradually",
        "graduate",
        "graffiti",
        "grafted",
        "grafting",
        "grain",
        "granddad",
        "grandkid",
        "grandly",
        "grandma",
        "grandpa",
        "grandson",
        "granite",
        "granny",
        "granola",
        "grant",
        "granular",
        "grape",
        "graph",
        "grapple",
        "grappling",
        "grasp",
        "grass",
        "gratified",
        "gratify",
        "grating",
        "gratitude",
        "gratuity",
        "gravel",
        "graveness",
        "graves",
        "graveyard",
        "gravitate",
        "gravity",
        "gravy",
        "gray",
        "grazing",
        "greasily",
        "greedily",
        "greedless",
        "greedy",
        "green",
        "greeter",
        "greeting",
        "grew",
        "greyhound",
        "grid",
        "grief",
        "grievance",
        "grieving",
        "grievous",
        "grill",
        "grimace",
        "grimacing",
        "grime",
        "griminess",
        "grimy",
        "grinch",
        "grinning",
        "grip",
        "gristle",
        "grit",
        "groggily",
        "groggy",
        "groin",
        "groom",
        "groove",
        "grooving",
        "groovy",
        "grope",
        "ground",
        "grouped",
        "grout",
        "grove",
        "grower",
        "growing",
        "growl",
        "grub",
        "grudge",
        "grudging",
        "grueling",
        "gruffly",
        "grumble",
        "grumbling",
        "grumbly",
        "grumpily",
        "grunge",
        "grunt",
        "guacamole",
        "guidable",
        "guidance",
        "guide",
        "guiding",
        "guileless",
        "guise",
        "gulf",
        "gullible",
        "gully",
        "gulp",
        "gumball",
        "gumdrop",
        "gumminess",
        "gumming",
        "gummy",
        "gurgle",
        "gurgling",
        "guru",
        "gush",
        "gusto",
        "gusty",
        "gutless",
        "guts",
        "gutter",
        "guy",
        "guzzler",
        "gyration",
        "habitable",
        "habitant",
        "habitat",
        "habitual",
        "hacked",
        "hacker",
        "hacking",
        "hacksaw",
        "had",
        "haggler",
        "haiku",
        "half",
        "halogen",
        "halt",
        "halved",
        "halves",
        "hamburger",
        "hamlet",
        "hammock",
        "hamper",
        "hamster",
        "hamstring",
        "handbag",
        "handball",
        "handbook",
        "handbrake",
        "handcart",
        "handclap",
        "handclasp",
        "handcraft",
        "handcuff",
        "handed",
        "handful",
        "handgrip",
        "handgun",
        "handheld",
        "handiness",
        "handiwork",
        "handlebar",
        "handled",
        "handler",
        "handling",
        "handmade",
        "handoff",
        "handpick",
        "handprint",
        "handrail",
        "handsaw",
        "handset",
        "handsfree",
        "handshake",
        "handstand",
        "handwash",
        "handwork",
        "handwoven",
        "handwrite",
        "handyman",
        "hangnail",
        "hangout",
        "hangover",
        "hangup",
        "hankering",
        "hankie",
        "hanky",
        "haphazard",
        "happening",
        "happier",
        "happiest",
        "happily",
        "happiness",
        "happy",
        "harbor",
        "hardcopy",
        "hardcore",
        "hardcover",
        "harddisk",
        "hardened",
        "hardener",
        "hardening",
        "hardhat",
        "hardhead",
        "hardiness",
        "hardly",
        "hardness",
        "hardship",
        "hardware",
        "hardwired",
        "hardwood",
        "hardy",
        "harmful",
        "harmless",
        "harmonica",
        "harmonics",
        "harmonize",
        "harmony",
        "harness",
        "harpist",
        "harsh",
        "harvest",
        "hash",
        "hassle",
        "haste",
        "hastily",
        "hastiness",
        "hasty",
        "hatbox",
        "hatchback",
        "hatchery",
        "hatchet",
        "hatching",
        "hatchling",
        "hate",
        "hatless",
        "hatred",
        "haunt",
        "haven",
        "hazard",
        "hazelnut",
        "hazily",
        "haziness",
        "hazing",
        "hazy",
        "headache",
        "headband",
        "headboard",
        "headcount",
        "headdress",
        "headed",
        "header",
        "headfirst",
        "headgear",
        "heading",
        "headlamp",
        "headless",
        "headlock",
        "headphone",
        "headpiece",
        "headrest",
        "headroom",
        "headscarf",
        "headset",
        "headsman",
        "headstand",
        "headstone",
        "headway",
        "headwear",
        "heap",
        "heat",
        "heave",
        "heavily",
        "heaviness",
        "heaving",
        "hedge",
        "hedging",
        "heftiness",
        "hefty",
        "helium",
        "helmet",
        "helper",
        "helpful",
        "helping",
        "helpless",
        "helpline",
        "hemlock",
        "hemstitch",
        "hence",
        "henchman",
        "henna",
        "herald",
        "herbal",
        "herbicide",
        "herbs",
        "heritage",
        "hermit",
        "heroics",
        "heroism",
        "herring",
        "herself",
        "hertz",
        "hesitancy",
        "hesitant",
        "hesitate",
        "hexagon",
        "hexagram",
        "hubcap",
        "huddle",
        "huddling",
        "huff",
        "hug",
        "hula",
        "hulk",
        "hull",
        "human",
        "humble",
        "humbling",
        "humbly",
        "humid",
        "humiliate",
        "humility",
        "humming",
        "hummus",
        "humongous",
        "humorist",
        "humorless",
        "humorous",
        "humpback",
        "humped",
        "humvee",
        "hunchback",
        "hundredth",
        "hunger",
        "hungrily",
        "hungry",
        "hunk",
        "hunter",
        "hunting",
        "huntress",
        "huntsman",
        "hurdle",
        "hurled",
        "hurler",
        "hurling",
        "hurray",
        "hurricane",
        "hurried",
        "hurry",
        "hurt",
        "husband",
        "hush",
        "husked",
        "huskiness",
        "hut",
        "hybrid",
        "hydrant",
        "hydrated",
        "hydration",
        "hydrogen",
        "hydroxide",
        "hyperlink",
        "hypertext",
        "hyphen",
        "hypnoses",
        "hypnosis",
        "hypnotic",
        "hypnotism",
        "hypnotist",
        "hypnotize",
        "hypocrisy",
        "hypocrite",
        "ibuprofen",
        "ice",
        "iciness",
        "icing",
        "icky",
        "icon",
        "icy",
        "idealism",
        "idealist",
        "idealize",
        "ideally",
        "idealness",
        "identical",
        "identify",
        "identity",
        "ideology",
        "idiocy",
        "idiom",
        "idly",
        "igloo",
        "ignition",
        "ignore",
        "iguana",
        "illicitly",
        "illusion",
        "illusive",
        "image",
        "imaginary",
        "imagines",
        "imaging",
        "imbecile",
        "imitate",
        "imitation",
        "immature",
        "immerse",
        "immersion",
        "imminent",
        "immobile",
        "immodest",
        "immorally",
        "immortal",
        "immovable",
        "immovably",
        "immunity",
        "immunize",
        "impaired",
        "impale",
        "impart",
        "impatient",
        "impeach",
        "impeding",
        "impending",
        "imperfect",
        "imperial",
        "impish",
        "implant",
        "implement",
        "implicate",
        "implicit",
        "implode",
        "implosion",
        "implosive",
        "imply",
        "impolite",
        "important",
        "importer",
        "impose",
        "imposing",
        "impotence",
        "impotency",
        "impotent",
        "impound",
        "imprecise",
        "imprint",
        "imprison",
        "impromptu",
        "improper",
        "improve",
        "improving",
        "improvise",
        "imprudent",
        "impulse",
        "impulsive",
        "impure",
        "impurity",
        "iodine",
        "iodize",
        "ion",
        "ipad",
        "iphone",
        "ipod",
        "irate",
        "irk",
        "iron",
        "irregular",
        "irrigate",
        "irritable",
        "irritably",
        "irritant",
        "irritate",
        "islamic",
        "islamist",
        "isolated",
        "isolating",
        "isolation",
        "isotope",
        "issue",
        "issuing",
        "italicize",
        "italics",
        "item",
        "itinerary",
        "itunes",
        "ivory",
        "ivy",
        "jab",
        "jackal",
        "jacket",
        "jackknife",
        "jackpot",
        "jailbird",
        "jailbreak",
        "jailer",
        "jailhouse",
        "jalapeno",
        "jam",
        "janitor",
        "january",
        "jargon",
        "jarring",
        "jasmine",
        "jaundice",
        "jaunt",
        "java",
        "jawed",
        "jawless",
        "jawline",
        "jaws",
        "jaybird",
        "jaywalker",
        "jazz",
        "jeep",
        "jeeringly",
        "jellied",
        "jelly",
        "jersey",
        "jester",
        "jet",
        "jiffy",
        "jigsaw",
        "jimmy",
        "jingle",
        "jingling",
        "jinx",
        "jitters",
        "jittery",
        "job",
        "jockey",
        "jockstrap",
        "jogger",
        "jogging",
        "john",
        "joining",
        "jokester",
        "jokingly",
        "jolliness",
        "jolly",
        "jolt",
        "jot",
        "jovial",
        "joyfully",
        "joylessly",
        "joyous",
        "joyride",
        "joystick",
        "jubilance",
        "jubilant",
        "judge",
        "judgingly",
        "judicial",
        "judiciary",
        "judo",
        "juggle",
        "juggling",
        "jugular",
        "juice",
        "juiciness",
        "juicy",
        "jujitsu",
        "jukebox",
        "july",
        "jumble",
        "jumbo",
        "jump",
        "junction",
        "juncture",
        "june",
        "junior",
        "juniper",
        "junkie",
        "junkman",
        "junkyard",
        "jurist",
        "juror",
        "jury",
        "justice",
        "justifier",
        "justify",
        "justly",
        "justness",
        "juvenile",
        "kabob",
        "kangaroo",
        "karaoke",
        "karate",
        "karma",
        "kebab",
        "keenly",
        "keenness",
        "keep",
        "keg",
        "kelp",
        "kennel",
        "kept",
        "kerchief",
        "kerosene",
        "kettle",
        "kick",
        "kiln",
        "kilobyte",
        "kilogram",
        "kilometer",
        "kilowatt",
        "kilt",
        "kimono",
        "kindle",
        "kindling",
        "kindly",
        "kindness",
        "kindred",
        "kinetic",
        "kinfolk",
        "king",
        "kinship",
        "kinsman",
        "kinswoman",
        "kissable",
        "kisser",
        "kissing",
        "kitchen",
        "kite",
        "kitten",
        "kitty",
        "kiwi",
        "kleenex",
        "knapsack",
        "knee",
        "knelt",
        "knickers",
        "knoll",
        "koala",
        "kooky",
        "kosher",
        "krypton",
        "kudos",
        "kung",
        "labored",
        "laborer",
        "laboring",
        "laborious",
        "labrador",
        "ladder",
        "ladies",
        "ladle",
        "ladybug",
        "ladylike",
        "lagged",
        "lagging",
        "lagoon",
        "lair",
        "lake",
        "lance",
        "landed",
        "landfall",
        "landfill",
        "landing",
        "landlady",
        "landless",
        "landline",
        "landlord",
        "landmark",
        "landmass",
        "landmine",
        "landowner",
        "landscape",
        "landside",
        "landslide",
        "language",
        "lankiness",
        "lanky",
        "lantern",
        "lapdog",
        "lapel",
        "lapped",
        "lapping",
        "laptop",
        "lard",
        "large",
        "lark",
        "lash",
        "lasso",
        "last",
        "latch",
        "late",
        "lather",
        "latitude",
        "latrine",
        "latter",
        "latticed",
        "launch",
        "launder",
        "laundry",
        "laurel",
        "lavender",
        "lavish",
        "laxative",
        "lazily",
        "laziness",
        "lazy",
        "lecturer",
        "left",
        "legacy",
        "legal",
        "legend",
        "legged",
        "leggings",
        "legible",
        "legibly",
        "legislate",
        "lego",
        "legroom",
        "legume",
        "legwarmer",
        "legwork",
        "lemon",
        "lend",
        "length",
        "lens",
        "lent",
        "leotard",
        "lesser",
        "letdown",
        "lethargic",
        "lethargy",
        "letter",
        "lettuce",
        "level",
        "leverage",
        "levers",
        "levitate",
        "levitator",
        "liability",
        "liable",
        "liberty",
        "librarian",
        "library",
        "licking",
        "licorice",
        "lid",
        "life",
        "lifter",
        "lifting",
        "liftoff",
        "ligament",
        "likely",
        "likeness",
        "likewise",
        "liking",
        "lilac",
        "lilly",
        "lily",
        "limb",
        "limeade",
        "limelight",
        "limes",
        "limit",
        "limping",
        "limpness",
        "line",
        "lingo",
        "linguini",
        "linguist",
        "lining",
        "linked",
        "linoleum",
        "linseed",
        "lint",
        "lion",
        "lip",
        "liquefy",
        "liqueur",
        "liquid",
        "lisp",
        "list",
        "litigate",
        "litigator",
        "litmus",
        "litter",
        "little",
        "livable",
        "lived",
        "lively",
        "liver",
        "livestock",
        "lividly",
        "living",
        "lizard",
        "lubricant",
        "lubricate",
        "lucid",
        "luckily",
        "luckiness",
        "luckless",
        "lucrative",
        "ludicrous",
        "lugged",
        "lukewarm",
        "lullaby",
        "lumber",
        "luminance",
        "luminous",
        "lumpiness",
        "lumping",
        "lumpish",
        "lunacy",
        "lunar",
        "lunchbox",
        "luncheon",
        "lunchroom",
        "lunchtime",
        "lung",
        "lurch",
        "lure",
        "luridness",
        "lurk",
        "lushly",
        "lushness",
        "luster",
        "lustfully",
        "lustily",
        "lustiness",
        "lustrous",
        "lusty",
        "luxurious",
        "luxury",
        "lying",
        "lyrically",
        "lyricism",
        "lyricist",
        "lyrics",
        "macarena",
        "macaroni",
        "macaw",
        "mace",
        "machine",
        "machinist",
        "magazine",
        "magenta",
        "maggot",
        "magical",
        "magician",
        "magma",
        "magnesium",
        "magnetic",
        "magnetism",
        "magnetize",
        "magnifier",
        "magnify",
        "magnitude",
        "magnolia",
        "mahogany",
        "maimed",
        "majestic",
        "majesty",
        "majorette",
        "majority",
        "makeover",
        "maker",
        "makeshift",
        "making",
        "malformed",
        "malt",
        "mama",
        "mammal",
        "mammary",
        "mammogram",
        "manager",
        "managing",
        "manatee",
        "mandarin",
        "mandate",
        "mandatory",
        "mandolin",
        "manger",
        "mangle",
        "mango",
        "mangy",
        "manhandle",
        "manhole",
        "manhood",
        "manhunt",
        "manicotti",
        "manicure",
        "manifesto",
        "manila",
        "mankind",
        "manlike",
        "manliness",
        "manly",
        "manmade",
        "manned",
        "mannish",
        "manor",
        "manpower",
        "mantis",
        "mantra",
        "manual",
        "many",
        "map",
        "marathon",
        "marauding",
        "marbled",
        "marbles",
        "marbling",
        "march",
        "mardi",
        "margarine",
        "margarita",
        "margin",
        "marigold",
        "marina",
        "marine",
        "marital",
        "maritime",
        "marlin",
        "marmalade",
        "maroon",
        "married",
        "marrow",
        "marry",
        "marshland",
        "marshy",
        "marsupial",
        "marvelous",
        "marxism",
        "mascot",
        "masculine",
        "mashed",
        "mashing",
        "massager",
        "masses",
        "massive",
        "mastiff",
        "matador",
        "matchbook",
        "matchbox",
        "matcher",
        "matching",
        "matchless",
        "material",
        "maternal",
        "maternity",
        "math",
        "mating",
        "matriarch",
        "matrimony",
        "matrix",
        "matron",
        "matted",
        "matter",
        "maturely",
        "maturing",
        "maturity",
        "mauve",
        "maverick",
        "maximize",
        "maximum",
        "maybe",
        "mayday",
        "mayflower",
        "moaner",
        "moaning",
        "mobile",
        "mobility",
        "mobilize",
        "mobster",
        "mocha",
        "mocker",
        "mockup",
        "modified",
        "modify",
        "modular",
        "modulator",
        "module",
        "moisten",
        "moistness",
        "moisture",
        "molar",
        "molasses",
        "mold",
        "molecular",
        "molecule",
        "molehill",
        "mollusk",
        "mom",
        "monastery",
        "monday",
        "monetary",
        "monetize",
        "moneybags",
        "moneyless",
        "moneywise",
        "mongoose",
        "mongrel",
        "monitor",
        "monkhood",
        "monogamy",
        "monogram",
        "monologue",
        "monopoly",
        "monorail",
        "monotone",
        "monotype",
        "monoxide",
        "monsieur",
        "monsoon",
        "monstrous",
        "monthly",
        "monument",
        "moocher",
        "moodiness",
        "moody",
        "mooing",
        "moonbeam",
        "mooned",
        "moonlight",
        "moonlike",
        "moonlit",
        "moonrise",
        "moonscape",
        "moonshine",
        "moonstone",
        "moonwalk",
        "mop",
        "morale",
        "morality",
        "morally",
        "morbidity",
        "morbidly",
        "morphine",
        "morphing",
        "morse",
        "mortality",
        "mortally",
        "mortician",
        "mortified",
        "mortify",
        "mortuary",
        "mosaic",
        "mossy",
        "most",
        "mothball",
        "mothproof",
        "motion",
        "motivate",
        "motivator",
        "motive",
        "motocross",
        "motor",
        "motto",
        "mountable",
        "mountain",
        "mounted",
        "mounting",
        "mourner",
        "mournful",
        "mouse",
        "mousiness",
        "moustache",
        "mousy",
        "mouth",
        "movable",
        "move",
        "movie",
        "moving",
        "mower",
        "mowing",
        "much",
        "muck",
        "mud",
        "mug",
        "mulberry",
        "mulch",
        "mule",
        "mulled",
        "mullets",
        "multiple",
        "multiply",
        "multitask",
        "multitude",
        "mumble",
        "mumbling",
        "mumbo",
        "mummified",
        "mummify",
        "mummy",
        "mumps",
        "munchkin",
        "mundane",
        "municipal",
        "muppet",
        "mural",
        "murkiness",
        "murky",
        "murmuring",
        "muscular",
        "museum",
        "mushily",
        "mushiness",
        "mushroom",
        "mushy",
        "music",
        "musket",
        "muskiness",
        "musky",
        "mustang",
        "mustard",
        "muster",
        "mustiness",
        "musty",
        "mutable",
        "mutate",
        "mutation",
        "mute",
        "mutilated",
        "mutilator",
        "mutiny",
        "mutt",
        "mutual",
        "muzzle",
        "myself",
        "myspace",
        "mystified",
        "mystify",
        "myth",
        "nacho",
        "nag",
        "nail",
        "name",
        "naming",
        "nanny",
        "nanometer",
        "nape",
        "napkin",
        "napped",
        "napping",
        "nappy",
        "narrow",
        "nastily",
        "nastiness",
        "national",
        "native",
        "nativity",
        "natural",
        "nature",
        "naturist",
        "nautical",
        "navigate",
        "navigator",
        "navy",
        "nearby",
        "nearest",
        "nearly",
        "nearness",
        "neatly",
        "neatness",
        "nebula",
        "nebulizer",
        "nectar",
        "negate",
        "negation",
        "negative",
        "neglector",
        "negligee",
        "negligent",
        "negotiate",
        "nemeses",
        "nemesis",
        "neon",
        "nephew",
        "nerd",
        "nervous",
        "nervy",
        "nest",
        "net",
        "neurology",
        "neuron",
        "neurosis",
        "neurotic",
        "neuter",
        "neutron",
        "never",
        "next",
        "nibble",
        "nickname",
        "nicotine",
        "niece",
        "nifty",
        "nimble",
        "nimbly",
        "nineteen",
        "ninetieth",
        "ninja",
        "nintendo",
        "ninth",
        "nuclear",
        "nuclei",
        "nucleus",
        "nugget",
        "nullify",
        "number",
        "numbing",
        "numbly",
        "numbness",
        "numeral",
        "numerate",
        "numerator",
        "numeric",
        "numerous",
        "nuptials",
        "nursery",
        "nursing",
        "nurture",
        "nutcase",
        "nutlike",
        "nutmeg",
        "nutrient",
        "nutshell",
        "nuttiness",
        "nutty",
        "nuzzle",
        "nylon",
        "oaf",
        "oak",
        "oasis",
        "oat",
        "obedience",
        "obedient",
        "obituary",
        "object",
        "obligate",
        "obliged",
        "oblivion",
        "oblivious",
        "oblong",
        "obnoxious",
        "oboe",
        "obscure",
        "obscurity",
        "observant",
        "observer",
        "observing",
        "obsessed",
        "obsession",
        "obsessive",
        "obsolete",
        "obstacle",
        "obstinate",
        "obstruct",
        "obtain",
        "obtrusive",
        "obtuse",
        "obvious",
        "occultist",
        "occupancy",
        "occupant",
        "occupier",
        "occupy",
        "ocean",
        "ocelot",
        "octagon",
        "octane",
        "october",
        "octopus",
        "ogle",
        "oil",
        "oink",
        "ointment",
        "okay",
        "old",
        "olive",
        "olympics",
        "omega",
        "omen",
        "ominous",
        "omission",
        "omit",
        "omnivore",
        "onboard",
        "oncoming",
        "ongoing",
        "onion",
        "online",
        "onlooker",
        "only",
        "onscreen",
        "onset",
        "onshore",
        "onslaught",
        "onstage",
        "onto",
        "onward",
        "onyx",
        "oops",
        "ooze",
        "oozy",
        "opacity",
        "opal",
        "open",
        "operable",
        "operate",
        "operating",
        "operation",
        "operative",
        "operator",
        "opium",
        "opossum",
        "opponent",
        "oppose",
        "opposing",
        "opposite",
        "oppressed",
        "oppressor",
        "opt",
        "opulently",
        "osmosis",
        "other",
        "otter",
        "ouch",
        "ought",
        "ounce",
        "outage",
        "outback",
        "outbid",
        "outboard",
        "outbound",
        "outbreak",
        "outburst",
        "outcast",
        "outclass",
        "outcome",
        "outdated",
        "outdoors",
        "outer",
        "outfield",
        "outfit",
        "outflank",
        "outgoing",
        "outgrow",
        "outhouse",
        "outing",
        "outlast",
        "outlet",
        "outline",
        "outlook",
        "outlying",
        "outmatch",
        "outmost",
        "outnumber",
        "outplayed",
        "outpost",
        "outpour",
        "output",
        "outrage",
        "outrank",
        "outreach",
        "outright",
        "outscore",
        "outsell",
        "outshine",
        "outshoot",
        "outsider",
        "outskirts",
        "outsmart",
        "outsource",
        "outspoken",
        "outtakes",
        "outthink",
        "outward",
        "outweigh",
        "outwit",
        "oval",
        "ovary",
        "oven",
        "overact",
        "overall",
        "overarch",
        "overbid",
        "overbill",
        "overbite",
        "overblown",
        "overboard",
        "overbook",
        "overbuilt",
        "overcast",
        "overcoat",
        "overcome",
        "overcook",
        "overcrowd",
        "overdraft",
        "overdrawn",
        "overdress",
        "overdrive",
        "overdue",
        "overeager",
        "overeater",
        "overexert",
        "overfed",
        "overfeed",
        "overfill",
        "overflow",
        "overfull",
        "overgrown",
        "overhand",
        "overhang",
        "overhaul",
        "overhead",
        "overhear",
        "overheat",
        "overhung",
        "overjoyed",
        "overkill",
        "overlabor",
        "overlaid",
        "overlap",
        "overlay",
        "overload",
        "overlook",
        "overlord",
        "overlying",
        "overnight",
        "overpass",
        "overpay",
        "overplant",
        "overplay",
        "overpower",
        "overprice",
        "overrate",
        "overreach",
        "overreact",
        "override",
        "overripe",
        "overrule",
        "overrun",
        "overshoot",
        "overshot",
        "oversight",
        "oversized",
        "oversleep",
        "oversold",
        "overspend",
        "overstate",
        "overstay",
        "overstep",
        "overstock",
        "overstuff",
        "oversweet",
        "overtake",
        "overthrow",
        "overtime",
        "overtly",
        "overtone",
        "overture",
        "overturn",
        "overuse",
        "overvalue",
        "overview",
        "overwrite",
        "owl",
        "oxford",
        "oxidant",
        "oxidation",
        "oxidize",
        "oxidizing",
        "oxygen",
        "oxymoron",
        "oyster",
        "ozone",
        "paced",
        "pacemaker",
        "pacific",
        "pacifier",
        "pacifism",
        "pacifist",
        "pacify",
        "padded",
        "padding",
        "paddle",
        "paddling",
        "padlock",
        "pagan",
        "pager",
        "paging",
        "pajamas",
        "palace",
        "palatable",
        "palm",
        "palpable",
        "palpitate",
        "paltry",
        "pampered",
        "pamperer",
        "pampers",
        "pamphlet",
        "panama",
        "pancake",
        "pancreas",
        "panda",
        "pandemic",
        "pang",
        "panhandle",
        "panic",
        "panning",
        "panorama",
        "panoramic",
        "panther",
        "pantomime",
        "pantry",
        "pants",
        "pantyhose",
        "paparazzi",
        "papaya",
        "paper",
        "paprika",
        "papyrus",
        "parabola",
        "parachute",
        "parade",
        "paradox",
        "paragraph",
        "parakeet",
        "paralegal",
        "paralyses",
        "paralysis",
        "paralyze",
        "paramedic",
        "parameter",
        "paramount",
        "parasail",
        "parasite",
        "parasitic",
        "parcel",
        "parched",
        "parchment",
        "pardon",
        "parish",
        "parka",
        "parking",
        "parkway",
        "parlor",
        "parmesan",
        "parole",
        "parrot",
        "parsley",
        "parsnip",
        "partake",
        "parted",
        "parting",
        "partition",
        "partly",
        "partner",
        "partridge",
        "party",
        "passable",
        "passably",
        "passage",
        "passcode",
        "passenger",
        "passerby",
        "passing",
        "passion",
        "passive",
        "passivism",
        "passover",
        "passport",
        "password",
        "pasta",
        "pasted",
        "pastel",
        "pastime",
        "pastor",
        "pastrami",
        "pasture",
        "pasty",
        "patchwork",
        "patchy",
        "paternal",
        "paternity",
        "path",
        "patience",
        "patient",
        "patio",
        "patriarch",
        "patriot",
        "patrol",
        "patronage",
        "patronize",
        "pauper",
        "pavement",
        "paver",
        "pavestone",
        "pavilion",
        "paving",
        "pawing",
        "payable",
        "payback",
        "paycheck",
        "payday",
        "payee",
        "payer",
        "paying",
        "payment",
        "payphone",
        "payroll",
        "pebble",
        "pebbly",
        "pecan",
        "pectin",
        "peculiar",
        "peddling",
        "pediatric",
        "pedicure",
        "pedigree",
        "pedometer",
        "pegboard",
        "pelican",
        "pellet",
        "pelt",
        "pelvis",
        "penalize",
        "penalty",
        "pencil",
        "pendant",
        "pending",
        "penholder",
        "penknife",
        "pennant",
        "penniless",
        "penny",
        "penpal",
        "pension",
        "pentagon",
        "pentagram",
        "pep",
        "perceive",
        "percent",
        "perch",
        "percolate",
        "perennial",
        "perfected",
        "perfectly",
        "perfume",
        "periscope",
        "perish",
        "perjurer",
        "perjury",
        "perkiness",
        "perky",
        "perm",
        "peroxide",
        "perpetual",
        "perplexed",
        "persecute",
        "persevere",
        "persuaded",
        "persuader",
        "pesky",
        "peso",
        "pessimism",
        "pessimist",
        "pester",
        "pesticide",
        "petal",
        "petite",
        "petition",
        "petri",
        "petroleum",
        "petted",
        "petticoat",
        "pettiness",
        "petty",
        "petunia",
        "phantom",
        "phobia",
        "phoenix",
        "phonebook",
        "phoney",
        "phonics",
        "phoniness",
        "phony",
        "phosphate",
        "photo",
        "phrase",
        "phrasing",
        "placard",
        "placate",
        "placidly",
        "plank",
        "planner",
        "plant",
        "plasma",
        "plaster",
        "plastic",
        "plated",
        "platform",
        "plating",
        "platinum",
        "platonic",
        "platter",
        "platypus",
        "plausible",
        "plausibly",
        "playable",
        "playback",
        "player",
        "playful",
        "playgroup",
        "playhouse",
        "playing",
        "playlist",
        "playmaker",
        "playmate",
        "playoff",
        "playpen",
        "playroom",
        "playset",
        "plaything",
        "playtime",
        "plaza",
        "pleading",
        "pleat",
        "pledge",
        "plentiful",
        "plenty",
        "plethora",
        "plexiglas",
        "pliable",
        "plod",
        "plop",
        "plot",
        "plow",
        "ploy",
        "pluck",
        "plug",
        "plunder",
        "plunging",
        "plural",
        "plus",
        "plutonium",
        "plywood",
        "poach",
        "pod",
        "poem",
        "poet",
        "pogo",
        "pointed",
        "pointer",
        "pointing",
        "pointless",
        "pointy",
        "poise",
        "poison",
        "poker",
        "poking",
        "polar",
        "police",
        "policy",
        "polio",
        "polish",
        "politely",
        "polka",
        "polo",
        "polyester",
        "polygon",
        "polygraph",
        "polymer",
        "poncho",
        "pond",
        "pony",
        "popcorn",
        "pope",
        "poplar",
        "popper",
        "poppy",
        "popsicle",
        "populace",
        "popular",
        "populate",
        "porcupine",
        "pork",
        "porous",
        "porridge",
        "portable",
        "portal",
        "portfolio",
        "porthole",
        "portion",
        "portly",
        "portside",
        "poser",
        "posh",
        "posing",
        "possible",
        "possibly",
        "possum",
        "postage",
        "postal",
        "postbox",
        "postcard",
        "posted",
        "poster",
        "posting",
        "postnasal",
        "posture",
        "postwar",
        "pouch",
        "pounce",
        "pouncing",
        "pound",
        "pouring",
        "pout",
        "powdered",
        "powdering",
        "powdery",
        "power",
        "powwow",
        "pox",
        "praising",
        "prance",
        "prancing",
        "pranker",
        "prankish",
        "prankster",
        "prayer",
        "praying",
        "preacher",
        "preaching",
        "preachy",
        "preamble",
        "precinct",
        "precise",
        "precision",
        "precook",
        "precut",
        "predator",
        "predefine",
        "predict",
        "preface",
        "prefix",
        "preflight",
        "preformed",
        "pregame",
        "pregnancy",
        "pregnant",
        "preheated",
        "prelaunch",
        "prelaw",
        "prelude",
        "premiere",
        "premises",
        "premium",
        "prenatal",
        "preoccupy",
        "preorder",
        "prepaid",
        "prepay",
        "preplan",
        "preppy",
        "preschool",
        "prescribe",
        "preseason",
        "preset",
        "preshow",
        "president",
        "presoak",
        "press",
        "presume",
        "presuming",
        "preteen",
        "pretended",
        "pretender",
        "pretense",
        "pretext",
        "pretty",
        "pretzel",
        "prevail",
        "prevalent",
        "prevent",
        "preview",
        "previous",
        "prewar",
        "prewashed",
        "prideful",
        "pried",
        "primal",
        "primarily",
        "primary",
        "primate",
        "primer",
        "primp",
        "princess",
        "print",
        "prior",
        "prism",
        "prison",
        "prissy",
        "pristine",
        "privacy",
        "private",
        "privatize",
        "prize",
        "proactive",
        "probable",
        "probably",
        "probation",
        "probe",
        "probing",
        "probiotic",
        "problem",
        "procedure",
        "process",
        "proclaim",
        "procreate",
        "procurer",
        "prodigal",
        "prodigy",
        "produce",
        "product",
        "profane",
        "profanity",
        "professed",
        "professor",
        "profile",
        "profound",
        "profusely",
        "progeny",
        "prognosis",
        "program",
        "progress",
        "projector",
        "prologue",
        "prolonged",
        "promenade",
        "prominent",
        "promoter",
        "promotion",
        "prompter",
        "promptly",
        "prone",
        "prong",
        "pronounce",
        "pronto",
        "proofing",
        "proofread",
        "proofs",
        "propeller",
        "properly",
        "property",
        "proponent",
        "proposal",
        "propose",
        "props",
        "prorate",
        "protector",
        "protegee",
        "proton",
        "prototype",
        "protozoan",
        "protract",
        "protrude",
        "proud",
        "provable",
        "proved",
        "proven",
        "provided",
        "provider",
        "providing",
        "province",
        "proving",
        "provoke",
        "provoking",
        "provolone",
        "prowess",
        "prowler",
        "prowling",
        "proximity",
        "proxy",
        "prozac",
        "prude",
        "prudishly",
        "prune",
        "pruning",
        "pry",
        "psychic",
        "public",
        "publisher",
        "pucker",
        "pueblo",
        "pug",
        "pull",
        "pulmonary",
        "pulp",
        "pulsate",
        "pulse",
        "pulverize",
        "puma",
        "pumice",
        "pummel",
        "punch",
        "punctual",
        "punctuate",
        "punctured",
        "pungent",
        "punisher",
        "punk",
        "pupil",
        "puppet",
        "puppy",
        "purchase",
        "pureblood",
        "purebred",
        "purely",
        "pureness",
        "purgatory",
        "purge",
        "purging",
        "purifier",
        "purify",
        "purist",
        "puritan",
        "purity",
        "purple",
        "purplish",
        "purposely",
        "purr",
        "purse",
        "pursuable",
        "pursuant",
        "pursuit",
        "purveyor",
        "pushcart",
        "pushchair",
        "pusher",
        "pushiness",
        "pushing",
        "pushover",
        "pushpin",
        "pushup",
        "pushy",
        "putdown",
        "putt",
        "puzzle",
        "puzzling",
        "pyramid",
        "pyromania",
        "python",
        "quack",
        "quadrant",
        "quail",
        "quaintly",
        "quake",
        "quaking",
        "qualified",
        "qualifier",
        "qualify",
        "quality",
        "qualm",
        "quantum",
        "quarrel",
        "quarry",
        "quartered",
        "quarterly",
        "quarters",
        "quartet",
        "quench",
        "query",
        "quicken",
        "quickly",
        "quickness",
        "quicksand",
        "quickstep",
        "quiet",
        "quill",
        "quilt",
        "quintet",
        "quintuple",
        "quirk",
        "quit",
        "quiver",
        "quizzical",
        "quotable",
        "quotation",
        "quote",
        "rabid",
        "race",
        "racing",
        "racism",
        "rack",
        "racoon",
        "radar",
        "radial",
        "radiance",
        "radiantly",
        "radiated",
        "radiation",
        "radiator",
        "radio",
        "radish",
        "raffle",
        "raft",
        "rage",
        "ragged",
        "raging",
        "ragweed",
        "raider",
        "railcar",
        "railing",
        "railroad",
        "railway",
        "raisin",
        "rake",
        "raking",
        "rally",
        "ramble",
        "rambling",
        "ramp",
        "ramrod",
        "ranch",
        "rancidity",
        "random",
        "ranged",
        "ranger",
        "ranging",
        "ranked",
        "ranking",
        "ransack",
        "ranting",
        "rants",
        "rare",
        "rarity",
        "rascal",
        "rash",
        "rasping",
        "ravage",
        "raven",
        "ravine",
        "raving",
        "ravioli",
        "ravishing",
        "reabsorb",
        "reach",
        "reacquire",
        "reaction",
        "reactive",
        "reactor",
        "reaffirm",
        "ream",
        "reanalyze",
        "reappear",
        "reapply",
        "reappoint",
        "reapprove",
        "rearrange",
        "rearview",
        "reason",
        "reassign",
        "reassure",
        "reattach",
        "reawake",
        "rebalance",
        "rebate",
        "rebel",
        "rebirth",
        "reboot",
        "reborn",
        "rebound",
        "rebuff",
        "rebuild",
        "rebuilt",
        "reburial",
        "rebuttal",
        "recall",
        "recant",
        "recapture",
        "recast",
        "recede",
        "recent",
        "recess",
        "recharger",
        "recipient",
        "recital",
        "recite",
        "reckless",
        "reclaim",
        "recliner",
        "reclining",
        "recluse",
        "reclusive",
        "recognize",
        "recoil",
        "recollect",
        "recolor",
        "reconcile",
        "reconfirm",
        "reconvene",
        "recopy",
        "record",
        "recount",
        "recoup",
        "recovery",
        "recreate",
        "rectal",
        "rectangle",
        "rectified",
        "rectify",
        "recycled",
        "recycler",
        "recycling",
        "reemerge",
        "reenact",
        "reenter",
        "reentry",
        "reexamine",
        "referable",
        "referee",
        "reference",
        "refill",
        "refinance",
        "refined",
        "refinery",
        "refining",
        "refinish",
        "reflected",
        "reflector",
        "reflex",
        "reflux",
        "refocus",
        "refold",
        "reforest",
        "reformat",
        "reformed",
        "reformer",
        "reformist",
        "refract",
        "refrain",
        "refreeze",
        "refresh",
        "refried",
        "refueling",
        "refund",
        "refurbish",
        "refurnish",
        "refusal",
        "refuse",
        "refusing",
        "refutable",
        "refute",
        "regain",
        "regalia",
        "regally",
        "reggae",
        "regime",
        "region",
        "register",
        "registrar",
        "registry",
        "regress",
        "regretful",
        "regroup",
        "regular",
        "regulate",
        "regulator",
        "rehab",
        "reheat",
        "rehire",
        "rehydrate",
        "reimburse",
        "reissue",
        "reiterate",
        "rejoice",
        "rejoicing",
        "rejoin",
        "rekindle",
        "relapse",
        "relapsing",
        "relatable",
        "related",
        "relation",
        "relative",
        "relax",
        "relay",
        "relearn",
        "release",
        "relenting",
        "reliable",
        "reliably",
        "reliance",
        "reliant",
        "relic",
        "relieve",
        "relieving",
        "relight",
        "relish",
        "relive",
        "reload",
        "relocate",
        "relock",
        "reluctant",
        "rely",
        "remake",
        "remark",
        "remarry",
        "rematch",
        "remedial",
        "remedy",
        "remember",
        "reminder",
        "remindful",
        "remission",
        "remix",
        "remnant",
        "remodeler",
        "remold",
        "remorse",
        "remote",
        "removable",
        "removal",
        "removed",
        "remover",
        "removing",
        "rename",
        "renderer",
        "rendering",
        "rendition",
        "renegade",
        "renewable",
        "renewably",
        "renewal",
        "renewed",
        "renounce",
        "renovate",
        "renovator",
        "rentable",
        "rental",
        "rented",
        "renter",
        "reoccupy",
        "reoccur",
        "reopen",
        "reorder",
        "repackage",
        "repacking",
        "repaint",
        "repair",
        "repave",
        "repaying",
        "repayment",
        "repeal",
        "repeated",
        "repeater",
        "repent",
        "rephrase",
        "replace",
        "replay",
        "replica",
        "reply",
        "reporter",
        "repose",
        "repossess",
        "repost",
        "repressed",
        "reprimand",
        "reprint",
        "reprise",
        "reproach",
        "reprocess",
        "reproduce",
        "reprogram",
        "reps",
        "reptile",
        "reptilian",
        "repugnant",
        "repulsion",
        "repulsive",
        "repurpose",
        "reputable",
        "reputably",
        "request",
        "require",
        "requisite",
        "reroute",
        "rerun",
        "resale",
        "resample",
        "rescuer",
        "reseal",
        "research",
        "reselect",
        "reseller",
        "resemble",
        "resend",
        "resent",
        "reset",
        "reshape",
        "reshoot",
        "reshuffle",
        "residence",
        "residency",
        "resident",
        "residual",
        "residue",
        "resigned",
        "resilient",
        "resistant",
        "resisting",
        "resize",
        "resolute",
        "resolved",
        "resonant",
        "resonate",
        "resort",
        "resource",
        "respect",
        "resubmit",
        "result",
        "resume",
        "resupply",
        "resurface",
        "resurrect",
        "retail",
        "retainer",
        "retaining",
        "retake",
        "retaliate",
        "retention",
        "rethink",
        "retinal",
        "retired",
        "retiree",
        "retiring",
        "retold",
        "retool",
        "retorted",
        "retouch",
        "retrace",
        "retract",
        "retrain",
        "retread",
        "retreat",
        "retrial",
        "retrieval",
        "retriever",
        "retry",
        "return",
        "retying",
        "retype",
        "reunion",
        "reunite",
        "reusable",
        "reuse",
        "reveal",
        "reveler",
        "revenge",
        "revenue",
        "reverb",
        "revered",
        "reverence",
        "reverend",
        "reversal",
        "reverse",
        "reversing",
        "reversion",
        "revert",
        "revisable",
        "revise",
        "revision",
        "revisit",
        "revivable",
        "revival",
        "reviver",
        "reviving",
        "revocable",
        "revoke",
        "revolt",
        "revolver",
        "revolving",
        "reward",
        "rewash",
        "rewind",
        "rewire",
        "reword",
        "rework",
        "rewrap",
        "rewrite",
        "rhyme",
        "ribbon",
        "ribcage",
        "rice",
        "riches",
        "richly",
        "richness",
        "rickety",
        "ricotta",
        "riddance",
        "ridden",
        "ride",
        "riding",
        "rifling",
        "rift",
        "rigging",
        "rigid",
        "rigor",
        "rimless",
        "rimmed",
        "rind",
        "rink",
        "rinse",
        "rinsing",
        "riot",
        "ripcord",
        "ripeness",
        "ripening",
        "ripping",
        "ripple",
        "rippling",
        "riptide",
        "rise",
        "rising",
        "risk",
        "risotto",
        "ritalin",
        "ritzy",
        "rival",
        "riverbank",
        "riverbed",
        "riverboat",
        "riverside",
        "riveter",
        "riveting",
        "roamer",
        "roaming",
        "roast",
        "robbing",
        "robe",
        "robin",
        "robotics",
        "robust",
        "rockband",
        "rocker",
        "rocket",
        "rockfish",
        "rockiness",
        "rocking",
        "rocklike",
        "rockslide",
        "rockstar",
        "rocky",
        "rogue",
        "roman",
        "romp",
        "rope",
        "roping",
        "roster",
        "rosy",
        "rotten",
        "rotting",
        "rotunda",
        "roulette",
        "rounding",
        "roundish",
        "roundness",
        "roundup",
        "roundworm",
        "routine",
        "routing",
        "rover",
        "roving",
        "royal",
        "rubbed",
        "rubber",
        "rubbing",
        "rubble",
        "rubdown",
        "ruby",
        "ruckus",
        "rudder",
        "rug",
        "ruined",
        "rule",
        "rumble",
        "rumbling",
        "rummage",
        "rumor",
        "runaround",
        "rundown",
        "runner",
        "running",
        "runny",
        "runt",
        "runway",
        "rupture",
        "rural",
        "ruse",
        "rush",
        "rust",
        "rut",
        "sabbath",
        "sabotage",
        "sacrament",
        "sacred",
        "sacrifice",
        "sadden",
        "saddlebag",
        "saddled",
        "saddling",
        "sadly",
        "sadness",
        "safari",
        "safeguard",
        "safehouse",
        "safely",
        "safeness",
        "saffron",
        "saga",
        "sage",
        "sagging",
        "saggy",
        "said",
        "saint",
        "sake",
        "salad",
        "salami",
        "salaried",
        "salary",
        "saline",
        "salon",
        "saloon",
        "salsa",
        "salt",
        "salutary",
        "salute",
        "salvage",
        "salvaging",
        "salvation",
        "same",
        "sample",
        "sampling",
        "sanction",
        "sanctity",
        "sanctuary",
        "sandal",
        "sandbag",
        "sandbank",
        "sandbar",
        "sandblast",
        "sandbox",
        "sanded",
        "sandfish",
        "sanding",
        "sandlot",
        "sandpaper",
        "sandpit",
        "sandstone",
        "sandstorm",
        "sandworm",
        "sandy",
        "sanitary",
        "sanitizer",
        "sank",
        "santa",
        "sapling",
        "sappiness",
        "sappy",
        "sarcasm",
        "sarcastic",
        "sardine",
        "sash",
        "sasquatch",
        "sassy",
        "satchel",
        "satiable",
        "satin",
        "satirical",
        "satisfied",
        "satisfy",
        "saturate",
        "saturday",
        "sauciness",
        "saucy",
        "sauna",
        "savage",
        "savanna",
        "saved",
        "savings",
        "savior",
        "savor",
        "saxophone",
        "say",
        "scabbed",
        "scabby",
        "scalded",
        "scalding",
        "scale",
        "scaling",
        "scallion",
        "scallop",
        "scalping",
        "scam",
        "scandal",
        "scanner",
        "scanning",
        "scant",
        "scapegoat",
        "scarce",
        "scarcity",
        "scarecrow",
        "scared",
        "scarf",
        "scarily",
        "scariness",
        "scarring",
        "scary",
        "scavenger",
        "scenic",
        "schedule",
        "schematic",
        "scheme",
        "scheming",
        "schilling",
        "schnapps",
        "scholar",
        "science",
        "scientist",
        "scion",
        "scoff",
        "scolding",
        "scone",
        "scoop",
        "scooter",
        "scope",
        "scorch",
        "scorebook",
        "scorecard",
        "scored",
        "scoreless",
        "scorer",
        "scoring",
        "scorn",
        "scorpion",
        "scotch",
        "scoundrel",
        "scoured",
        "scouring",
        "scouting",
        "scouts",
        "scowling",
        "scrabble",
        "scraggly",
        "scrambled",
        "scrambler",
        "scrap",
        "scratch",
        "scrawny",
        "screen",
        "scribble",
        "scribe",
        "scribing",
        "scrimmage",
        "script",
        "scroll",
        "scrooge",
        "scrounger",
        "scrubbed",
        "scrubber",
        "scruffy",
        "scrunch",
        "scrutiny",
        "scuba",
        "scuff",
        "sculptor",
        "sculpture",
        "scurvy",
        "scuttle",
        "secluded",
        "secluding",
        "seclusion",
        "second",
        "secrecy",
        "secret",
        "sectional",
        "sector",
        "secular",
        "securely",
        "security",
        "sedan",
        "sedate",
        "sedation",
        "sedative",
        "sediment",
        "seduce",
        "seducing",
        "segment",
        "seismic",
        "seizing",
        "seldom",
        "selected",
        "selection",
        "selective",
        "selector",
        "self",
        "seltzer",
        "semantic",
        "semester",
        "semicolon",
        "semifinal",
        "seminar",
        "semisoft",
        "semisweet",
        "senate",
        "senator",
        "send",
        "senior",
        "senorita",
        "sensation",
        "sensitive",
        "sensitize",
        "sensually",
        "sensuous",
        "sepia",
        "september",
        "septic",
        "septum",
        "sequel",
        "sequence",
        "sequester",
        "series",
        "sermon",
        "serotonin",
        "serpent",
        "serrated",
        "serve",
        "service",
        "serving",
        "sesame",
        "sessions",
        "setback",
        "setting",
        "settle",
        "settling",
        "setup",
        "sevenfold",
        "seventeen",
        "seventh",
        "seventy",
        "severity",
        "shabby",
        "shack",
        "shaded",
        "shadily",
        "shadiness",
        "shading",
        "shadow",
        "shady",
        "shaft",
        "shakable",
        "shakily",
        "shakiness",
        "shaking",
        "shaky",
        "shale",
        "shallot",
        "shallow",
        "shame",
        "shampoo",
        "shamrock",
        "shank",
        "shanty",
        "shape",
        "shaping",
        "share",
        "sharpener",
        "sharper",
        "sharpie",
        "sharply",
        "sharpness",
        "shawl",
        "sheath",
        "shed",
        "sheep",
        "sheet",
        "shelf",
        "shell",
        "shelter",
        "shelve",
        "shelving",
        "sherry",
        "shield",
        "shifter",
        "shifting",
        "shiftless",
        "shifty",
        "shimmer",
        "shimmy",
        "shindig",
        "shine",
        "shingle",
        "shininess",
        "shining",
        "shiny",
        "ship",
        "shirt",
        "shivering",
        "shock",
        "shone",
        "shoplift",
        "shopper",
        "shopping",
        "shoptalk",
        "shore",
        "shortage",
        "shortcake",
        "shortcut",
        "shorten",
        "shorter",
        "shorthand",
        "shortlist",
        "shortly",
        "shortness",
        "shorts",
        "shortwave",
        "shorty",
        "shout",
        "shove",
        "showbiz",
        "showcase",
        "showdown",
        "shower",
        "showgirl",
        "showing",
        "showman",
        "shown",
        "showoff",
        "showpiece",
        "showplace",
        "showroom",
        "showy",
        "shrank",
        "shrapnel",
        "shredder",
        "shredding",
        "shrewdly",
        "shriek",
        "shrill",
        "shrimp",
        "shrine",
        "shrink",
        "shrivel",
        "shrouded",
        "shrubbery",
        "shrubs",
        "shrug",
        "shrunk",
        "shucking",
        "shudder",
        "shuffle",
        "shuffling",
        "shun",
        "shush",
        "shut",
        "shy",
        "siamese",
        "siberian",
        "sibling",
        "siding",
        "sierra",
        "siesta",
        "sift",
        "sighing",
        "silenced",
        "silencer",
        "silent",
        "silica",
        "silicon",
        "silk",
        "silliness",
        "silly",
        "silo",
        "silt",
        "silver",
        "similarly",
        "simile",
        "simmering",
        "simple",
        "simplify",
        "simply",
        "sincere",
        "sincerity",
        "singer",
        "singing",
        "single",
        "singular",
        "sinister",
        "sinless",
        "sinner",
        "sinuous",
        "sip",
        "siren",
        "sister",
        "sitcom",
        "sitter",
        "sitting",
        "situated",
        "situation",
        "sixfold",
        "sixteen",
        "sixth",
        "sixties",
        "sixtieth",
        "sixtyfold",
        "sizable",
        "sizably",
        "size",
        "sizing",
        "sizzle",
        "sizzling",
        "skater",
        "skating",
        "skedaddle",
        "skeletal",
        "skeleton",
        "skeptic",
        "sketch",
        "skewed",
        "skewer",
        "skid",
        "skied",
        "skier",
        "skies",
        "skiing",
        "skilled",
        "skillet",
        "skillful",
        "skimmed",
        "skimmer",
        "skimming",
        "skimpily",
        "skincare",
        "skinhead",
        "skinless",
        "skinning",
        "skinny",
        "skintight",
        "skipper",
        "skipping",
        "skirmish",
        "skirt",
        "skittle",
        "skydiver",
        "skylight",
        "skyline",
        "skype",
        "skyrocket",
        "skyward",
        "slab",
        "slacked",
        "slacker",
        "slacking",
        "slackness",
        "slacks",
        "slain",
        "slam",
        "slander",
        "slang",
        "slapping",
        "slapstick",
        "slashed",
        "slashing",
        "slate",
        "slather",
        "slaw",
        "sled",
        "sleek",
        "sleep",
        "sleet",
        "sleeve",
        "slept",
        "sliceable",
        "sliced",
        "slicer",
        "slicing",
        "slick",
        "slider",
        "slideshow",
        "sliding",
        "slighted",
        "slighting",
        "slightly",
        "slimness",
        "slimy",
        "slinging",
        "slingshot",
        "slinky",
        "slip",
        "slit",
        "sliver",
        "slobbery",
        "slogan",
        "sloped",
        "sloping",
        "sloppily",
        "sloppy",
        "slot",
        "slouching",
        "slouchy",
        "sludge",
        "slug",
        "slum",
        "slurp",
        "slush",
        "sly",
        "small",
        "smartly",
        "smartness",
        "smasher",
        "smashing",
        "smashup",
        "smell",
        "smelting",
        "smile",
        "smilingly",
        "smirk",
        "smite",
        "smith",
        "smitten",
        "smock",
        "smog",
        "smoked",
        "smokeless",
        "smokiness",
        "smoking",
        "smoky",
        "smolder",
        "smooth",
        "smother",
        "smudge",
        "smudgy",
        "smuggler",
        "smuggling",
        "smugly",
        "smugness",
        "snack",
        "snagged",
        "snaking",
        "snap",
        "snare",
        "snarl",
        "snazzy",
        "sneak",
        "sneer",
        "sneeze",
        "sneezing",
        "snide",
        "sniff",
        "snippet",
        "snipping",
        "snitch",
        "snooper",
        "snooze",
        "snore",
        "snoring",
        "snorkel",
        "snort",
        "snout",
        "snowbird",
        "snowboard",
        "snowbound",
        "snowcap",
        "snowdrift",
        "snowdrop",
        "snowfall",
        "snowfield",
        "snowflake",
        "snowiness",
        "snowless",
        "snowman",
        "snowplow",
        "snowshoe",
        "snowstorm",
        "snowsuit",
        "snowy",
        "snub",
        "snuff",
        "snuggle",
        "snugly",
        "snugness",
        "speak",
        "spearfish",
        "spearhead",
        "spearman",
        "spearmint",
        "species",
        "specimen",
        "specked",
        "speckled",
        "specks",
        "spectacle",
        "spectator",
        "spectrum",
        "speculate",
        "speech",
        "speed",
        "spellbind",
        "speller",
        "spelling",
        "spendable",
        "spender",
        "spending",
        "spent",
        "spew",
        "sphere",
        "spherical",
        "sphinx",
        "spider",
        "spied",
        "spiffy",
        "spill",
        "spilt",
        "spinach",
        "spinal",
        "spindle",
        "spinner",
        "spinning",
        "spinout",
        "spinster",
        "spiny",
        "spiral",
        "spirited",
        "spiritism",
        "spirits",
        "spiritual",
        "splashed",
        "splashing",
        "splashy",
        "splatter",
        "spleen",
        "splendid",
        "splendor",
        "splice",
        "splicing",
        "splinter",
        "splotchy",
        "splurge",
        "spoilage",
        "spoiled",
        "spoiler",
        "spoiling",
        "spoils",
        "spoken",
        "spokesman",
        "sponge",
        "spongy",
        "sponsor",
        "spoof",
        "spookily",
        "spooky",
        "spool",
        "spoon",
        "spore",
        "sporting",
        "sports",
        "sporty",
        "spotless",
        "spotlight",
        "spotted",
        "spotter",
        "spotting",
        "spotty",
        "spousal",
        "spouse",
        "spout",
        "sprain",
        "sprang",
        "sprawl",
        "spray",
        "spree",
        "sprig",
        "spring",
        "sprinkled",
        "sprinkler",
        "sprint",
        "sprite",
        "sprout",
        "spruce",
        "sprung",
        "spry",
        "spud",
        "spur",
        "sputter",
        "spyglass",
        "squabble",
        "squad",
        "squall",
        "squander",
        "squash",
        "squatted",
        "squatter",
        "squatting",
        "squeak",
        "squealer",
        "squealing",
        "squeamish",
        "squeegee",
        "squeeze",
        "squeezing",
        "squid",
        "squiggle",
        "squiggly",
        "squint",
        "squire",
        "squirt",
        "squishier",
        "squishy",
        "stability",
        "stabilize",
        "stable",
        "stack",
        "stadium",
        "staff",
        "stage",
        "staging",
        "stagnant",
        "stagnate",
        "stainable",
        "stained",
        "staining",
        "stainless",
        "stalemate",
        "staleness",
        "stalling",
        "stallion",
        "stamina",
        "stammer",
        "stamp",
        "stand",
        "stank",
        "staple",
        "stapling",
        "starboard",
        "starch",
        "stardom",
        "stardust",
        "starfish",
        "stargazer",
        "staring",
        "stark",
        "starless",
        "starlet",
        "starlight",
        "starlit",
        "starring",
        "starry",
        "starship",
        "starter",
        "starting",
        "startle",
        "startling",
        "startup",
        "starved",
        "starving",
        "stash",
        "state",
        "static",
        "statistic",
        "statue",
        "stature",
        "status",
        "statute",
        "statutory",
        "staunch",
        "stays",
        "steadfast",
        "steadier",
        "steadily",
        "steadying",
        "steam",
        "steed",
        "steep",
        "steerable",
        "steering",
        "steersman",
        "stegosaur",
        "stellar",
        "stem",
        "stench",
        "stencil",
        "step",
        "stereo",
        "sterile",
        "sterility",
        "sterilize",
        "sterling",
        "sternness",
        "sternum",
        "stew",
        "stick",
        "stiffen",
        "stiffly",
        "stiffness",
        "stifle",
        "stifling",
        "stillness",
        "stilt",
        "stimulant",
        "stimulate",
        "stimuli",
        "stimulus",
        "stinger",
        "stingily",
        "stinging",
        "stingray",
        "stingy",
        "stinking",
        "stinky",
        "stipend",
        "stipulate",
        "stir",
        "stitch",
        "stock",
        "stoic",
        "stoke",
        "stole",
        "stomp",
        "stonewall",
        "stoneware",
        "stonework",
        "stoning",
        "stony",
        "stood",
        "stooge",
        "stool",
        "stoop",
        "stoplight",
        "stoppable",
        "stoppage",
        "stopped",
        "stopper",
        "stopping",
        "stopwatch",
        "storable",
        "storage",
        "storeroom",
        "storewide",
        "storm",
        "stout",
        "stove",
        "stowaway",
        "stowing",
        "straddle",
        "straggler",
        "strained",
        "strainer",
        "straining",
        "strangely",
        "stranger",
        "strangle",
        "strategic",
        "strategy",
        "stratus",
        "straw",
        "stray",
        "streak",
        "stream",
        "street",
        "strength",
        "strenuous",
        "strep",
        "stress",
        "stretch",
        "strewn",
        "stricken",
        "strict",
        "stride",
        "strife",
        "strike",
        "striking",
        "strive",
        "striving",
        "strobe",
        "strode",
        "stroller",
        "strongbox",
        "strongly",
        "strongman",
        "struck",
        "structure",
        "strudel",
        "struggle",
        "strum",
        "strung",
        "strut",
        "stubbed",
        "stubble",
        "stubbly",
        "stubborn",
        "stucco",
        "stuck",
        "student",
        "studied",
        "studio",
        "study",
        "stuffed",
        "stuffing",
        "stuffy",
        "stumble",
        "stumbling",
        "stump",
        "stung",
        "stunned",
        "stunner",
        "stunning",
        "stunt",
        "stupor",
        "sturdily",
        "sturdy",
        "styling",
        "stylishly",
        "stylist",
        "stylized",
        "stylus",
        "suave",
        "subarctic",
        "subatomic",
        "subdivide",
        "subdued",
        "subduing",
        "subfloor",
        "subgroup",
        "subheader",
        "subject",
        "sublease",
        "sublet",
        "sublevel",
        "sublime",
        "submarine",
        "submerge",
        "submersed",
        "submitter",
        "subpanel",
        "subpar",
        "subplot",
        "subprime",
        "subscribe",
        "subscript",
        "subsector",
        "subside",
        "subsiding",
        "subsidize",
        "subsidy",
        "subsoil",
        "subsonic",
        "substance",
        "subsystem",
        "subtext",
        "subtitle",
        "subtly",
        "subtotal",
        "subtract",
        "subtype",
        "suburb",
        "subway",
        "subwoofer",
        "subzero",
        "succulent",
        "such",
        "suction",
        "sudden",
        "sudoku",
        "suds",
        "sufferer",
        "suffering",
        "suffice",
        "suffix",
        "suffocate",
        "suffrage",
        "sugar",
        "suggest",
        "suing",
        "suitable",
        "suitably",
        "suitcase",
        "suitor",
        "sulfate",
        "sulfide",
        "sulfite",
        "sulfur",
        "sulk",
        "sullen",
        "sulphate",
        "sulphuric",
        "sultry",
        "superbowl",
        "superglue",
        "superhero",
        "superior",
        "superjet",
        "superman",
        "supermom",
        "supernova",
        "supervise",
        "supper",
        "supplier",
        "supply",
        "support",
        "supremacy",
        "supreme",
        "surcharge",
        "surely",
        "sureness",
        "surface",
        "surfacing",
        "surfboard",
        "surfer",
        "surgery",
        "surgical",
        "surging",
        "surname",
        "surpass",
        "surplus",
        "surprise",
        "surreal",
        "surrender",
        "surrogate",
        "surround",
        "survey",
        "survival",
        "survive",
        "surviving",
        "survivor",
        "sushi",
        "suspect",
        "suspend",
        "suspense",
        "sustained",
        "sustainer",
        "swab",
        "swaddling",
        "swagger",
        "swampland",
        "swan",
        "swapping",
        "swarm",
        "sway",
        "swear",
        "sweat",
        "sweep",
        "swell",
        "swept",
        "swerve",
        "swifter",
        "swiftly",
        "swiftness",
        "swimmable",
        "swimmer",
        "swimming",
        "swimsuit",
        "swimwear",
        "swinger",
        "swinging",
        "swipe",
        "swirl",
        "switch",
        "swivel",
        "swizzle",
        "swooned",
        "swoop",
        "swoosh",
        "swore",
        "sworn",
        "swung",
        "sycamore",
        "sympathy",
        "symphonic",
        "symphony",
        "symptom",
        "synapse",
        "syndrome",
        "synergy",
        "synopses",
        "synopsis",
        "synthesis",
        "synthetic",
        "syrup",
        "system",
        "t-shirt",
        "tabasco",
        "tabby",
        "tableful",
        "tables",
        "tablet",
        "tableware",
        "tabloid",
        "tackiness",
        "tacking",
        "tackle",
        "tackling",
        "tacky",
        "taco",
        "tactful",
        "tactical",
        "tactics",
        "tactile",
        "tactless",
        "tadpole",
        "taekwondo",
        "tag",
        "tainted",
        "take",
        "taking",
        "talcum",
        "talisman",
        "tall",
        "talon",
        "tamale",
        "tameness",
        "tamer",
        "tamper",
        "tank",
        "tanned",
        "tannery",
        "tanning",
        "tantrum",
        "tapeless",
        "tapered",
        "tapering",
        "tapestry",
        "tapioca",
        "tapping",
        "taps",
        "tarantula",
        "target",
        "tarmac",
        "tarnish",
        "tarot",
        "tartar",
        "tartly",
        "tartness",
        "task",
        "tassel",
        "taste",
        "tastiness",
        "tasting",
        "tasty",
        "tattered",
        "tattle",
        "tattling",
        "tattoo",
        "taunt",
        "tavern",
        "thank",
        "that",
        "thaw",
        "theater",
        "theatrics",
        "thee",
        "theft",
        "theme",
        "theology",
        "theorize",
        "thermal",
        "thermos",
        "thesaurus",
        "these",
        "thesis",
        "thespian",
        "thicken",
        "thicket",
        "thickness",
        "thieving",
        "thievish",
        "thigh",
        "thimble",
        "thing",
        "think",
        "thinly",
        "thinner",
        "thinness",
        "thinning",
        "thirstily",
        "thirsting",
        "thirsty",
        "thirteen",
        "thirty",
        "thong",
        "thorn",
        "those",
        "thousand",
        "thrash",
        "thread",
        "threaten",
        "threefold",
        "thrift",
        "thrill",
        "thrive",
        "thriving",
        "throat",
        "throbbing",
        "throng",
        "throttle",
        "throwaway",
        "throwback",
        "thrower",
        "throwing",
        "thud",
        "thumb",
        "thumping",
        "thursday",
        "thus",
        "thwarting",
        "thyself",
        "tiara",
        "tibia",
        "tidal",
        "tidbit",
        "tidiness",
        "tidings",
        "tidy",
        "tiger",
        "tighten",
        "tightly",
        "tightness",
        "tightrope",
        "tightwad",
        "tigress",
        "tile",
        "tiling",
        "till",
        "tilt",
        "timid",
        "timing",
        "timothy",
        "tinderbox",
        "tinfoil",
        "tingle",
        "tingling",
        "tingly",
        "tinker",
        "tinkling",
        "tinsel",
        "tinsmith",
        "tint",
        "tinwork",
        "tiny",
        "tipoff",
        "tipped",
        "tipper",
        "tipping",
        "tiptoeing",
        "tiptop",
        "tiring",
        "tissue",
        "trace",
        "tracing",
        "track",
        "traction",
        "tractor",
        "trade",
        "trading",
        "tradition",
        "traffic",
        "tragedy",
        "trailing",
        "trailside",
        "train",
        "traitor",
        "trance",
        "tranquil",
        "transfer",
        "transform",
        "translate",
        "transpire",
        "transport",
        "transpose",
        "trapdoor",
        "trapeze",
        "trapezoid",
        "trapped",
        "trapper",
        "trapping",
        "traps",
        "trash",
        "travel",
        "traverse",
        "travesty",
        "tray",
        "treachery",
        "treading",
        "treadmill",
        "treason",
        "treat",
        "treble",
        "tree",
        "trekker",
        "tremble",
        "trembling",
        "tremor",
        "trench",
        "trend",
        "trespass",
        "triage",
        "trial",
        "triangle",
        "tribesman",
        "tribunal",
        "tribune",
        "tributary",
        "tribute",
        "triceps",
        "trickery",
        "trickily",
        "tricking",
        "trickle",
        "trickster",
        "tricky",
        "tricolor",
        "tricycle",
        "trident",
        "tried",
        "trifle",
        "trifocals",
        "trillion",
        "trilogy",
        "trimester",
        "trimmer",
        "trimming",
        "trimness",
        "trinity",
        "trio",
        "tripod",
        "tripping",
        "triumph",
        "trivial",
        "trodden",
        "trolling",
        "trombone",
        "trophy",
        "tropical",
        "tropics",
        "trouble",
        "troubling",
        "trough",
        "trousers",
        "trout",
        "trowel",
        "truce",
        "truck",
        "truffle",
        "trump",
        "trunks",
        "trustable",
        "trustee",
        "trustful",
        "trusting",
        "trustless",
        "truth",
        "try",
        "tubby",
        "tubeless",
        "tubular",
        "tucking",
        "tuesday",
        "tug",
        "tuition",
        "tulip",
        "tumble",
        "tumbling",
        "tummy",
        "turban",
        "turbine",
        "turbofan",
        "turbojet",
        "turbulent",
        "turf",
        "turkey",
        "turmoil",
        "turret",
        "turtle",
        "tusk",
        "tutor",
        "tutu",
        "tux",
        "tweak",
        "tweed",
        "tweet",
        "tweezers",
        "twelve",
        "twentieth",
        "twenty",
        "twerp",
        "twice",
        "twiddle",
        "twiddling",
        "twig",
        "twilight",
        "twine",
        "twins",
        "twirl",
        "twistable",
        "twisted",
        "twister",
        "twisting",
        "twisty",
        "twitch",
        "twitter",
        "tycoon",
        "tying",
        "tyke",
        "udder",
        "ultimate",
        "ultimatum",
        "ultra",
        "umbilical",
        "umbrella",
        "umpire",
        "unabashed",
        "unable",
        "unadorned",
        "unadvised",
        "unafraid",
        "unaired",
        "unaligned",
        "unaltered",
        "unarmored",
        "unashamed",
        "unaudited",
        "unawake",
        "unaware",
        "unbaked",
        "unbalance",
        "unbeaten",
        "unbend",
        "unbent",
        "unbiased",
        "unbitten",
        "unblended",
        "unblessed",
        "unblock",
        "unbolted",
        "unbounded",
        "unboxed",
        "unbraided",
        "unbridle",
        "unbroken",
        "unbuckled",
        "unbundle",
        "unburned",
        "unbutton",
        "uncanny",
        "uncapped",
        "uncaring",
        "uncertain",
        "unchain",
        "unchanged",
        "uncharted",
        "uncheck",
        "uncivil",
        "unclad",
        "unclaimed",
        "unclamped",
        "unclasp",
        "uncle",
        "unclip",
        "uncloak",
        "unclog",
        "unclothed",
        "uncoated",
        "uncoiled",
        "uncolored",
        "uncombed",
        "uncommon",
        "uncooked",
        "uncork",
        "uncorrupt",
        "uncounted",
        "uncouple",
        "uncouth",
        "uncover",
        "uncross",
        "uncrown",
        "uncrushed",
        "uncured",
        "uncurious",
        "uncurled",
        "uncut",
        "undamaged",
        "undated",
        "undaunted",
        "undead",
        "undecided",
        "undefined",
        "underage",
        "underarm",
        "undercoat",
        "undercook",
        "undercut",
        "underdog",
        "underdone",
        "underfed",
        "underfeed",
        "underfoot",
        "undergo",
        "undergrad",
        "underhand",
        "underline",
        "underling",
        "undermine",
        "undermost",
        "underpaid",
        "underpass",
        "underpay",
        "underrate",
        "undertake",
        "undertone",
        "undertook",
        "undertow",
        "underuse",
        "underwear",
        "underwent",
        "underwire",
        "undesired",
        "undiluted",
        "undivided",
        "undocked",
        "undoing",
        "undone",
        "undrafted",
        "undress",
        "undrilled",
        "undusted",
        "undying",
        "unearned",
        "unearth",
        "unease",
        "uneasily",
        "uneasy",
        "uneatable",
        "uneaten",
        "unedited",
        "unelected",
        "unending",
        "unengaged",
        "unenvied",
        "unequal",
        "unethical",
        "uneven",
        "unexpired",
        "unexposed",
        "unfailing",
        "unfair",
        "unfasten",
        "unfazed",
        "unfeeling",
        "unfiled",
        "unfilled",
        "unfitted",
        "unfitting",
        "unfixable",
        "unfixed",
        "unflawed",
        "unfocused",
        "unfold",
        "unfounded",
        "unframed",
        "unfreeze",
        "unfrosted",
        "unfrozen",
        "unfunded",
        "unglazed",
        "ungloved",
        "unglue",
        "ungodly",
        "ungraded",
        "ungreased",
        "unguarded",
        "unguided",
        "unhappily",
        "unhappy",
        "unharmed",
        "unhealthy",
        "unheard",
        "unhearing",
        "unheated",
        "unhelpful",
        "unhidden",
        "unhinge",
        "unhitched",
        "unholy",
        "unhook",
        "unicorn",
        "unicycle",
        "unified",
        "unifier",
        "uniformed",
        "uniformly",
        "unify",
        "unimpeded",
        "uninjured",
        "uninstall",
        "uninsured",
        "uninvited",
        "union",
        "uniquely",
        "unisexual",
        "unison",
        "unissued",
        "unit",
        "universal",
        "universe",
        "unjustly",
        "unkempt",
        "unkind",
        "unknotted",
        "unknowing",
        "unknown",
        "unlaced",
        "unlatch",
        "unlawful",
        "unleaded",
        "unlearned",
        "unleash",
        "unless",
        "unleveled",
        "unlighted",
        "unlikable",
        "unlimited",
        "unlined",
        "unlinked",
        "unlisted",
        "unlit",
        "unlivable",
        "unloaded",
        "unloader",
        "unlocked",
        "unlocking",
        "unlovable",
        "unloved",
        "unlovely",
        "unloving",
        "unluckily",
        "unlucky",
        "unmade",
        "unmanaged",
        "unmanned",
        "unmapped",
        "unmarked",
        "unmasked",
        "unmasking",
        "unmatched",
        "unmindful",
        "unmixable",
        "unmixed",
        "unmolded",
        "unmoral",
        "unmovable",
        "unmoved",
        "unmoving",
        "unnamable",
        "unnamed",
        "unnatural",
        "unneeded",
        "unnerve",
        "unnerving",
        "unnoticed",
        "unopened",
        "unopposed",
        "unpack",
        "unpadded",
        "unpaid",
        "unpainted",
        "unpaired",
        "unpaved",
        "unpeeled",
        "unpicked",
        "unpiloted",
        "unpinned",
        "unplanned",
        "unplanted",
        "unpleased",
        "unpledged",
        "unplowed",
        "unplug",
        "unpopular",
        "unproven",
        "unquote",
        "unranked",
        "unrated",
        "unraveled",
        "unreached",
        "unread",
        "unreal",
        "unreeling",
        "unrefined",
        "unrelated",
        "unrented",
        "unrest",
        "unretired",
        "unrevised",
        "unrigged",
        "unripe",
        "unrivaled",
        "unroasted",
        "unrobed",
        "unroll",
        "unruffled",
        "unruly",
        "unrushed",
        "unsaddle",
        "unsafe",
        "unsaid",
        "unsalted",
        "unsaved",
        "unsavory",
        "unscathed",
        "unscented",
        "unscrew",
        "unsealed",
        "unseated",
        "unsecured",
        "unseeing",
        "unseemly",
        "unseen",
        "unselect",
        "unselfish",
        "unsent",
        "unsettled",
        "unshackle",
        "unshaken",
        "unshaved",
        "unshaven",
        "unsheathe",
        "unshipped",
        "unsightly",
        "unsigned",
        "unskilled",
        "unsliced",
        "unsmooth",
        "unsnap",
        "unsocial",
        "unsoiled",
        "unsold",
        "unsolved",
        "unsorted",
        "unspoiled",
        "unspoken",
        "unstable",
        "unstaffed",
        "unstamped",
        "unsteady",
        "unsterile",
        "unstirred",
        "unstitch",
        "unstopped",
        "unstuck",
        "unstuffed",
        "unstylish",
        "unsubtle",
        "unsubtly",
        "unsuited",
        "unsure",
        "unsworn",
        "untagged",
        "untainted",
        "untaken",
        "untamed",
        "untangled",
        "untapped",
        "untaxed",
        "unthawed",
        "unthread",
        "untidy",
        "untie",
        "until",
        "untimed",
        "untimely",
        "untitled",
        "untoasted",
        "untold",
        "untouched",
        "untracked",
        "untrained",
        "untreated",
        "untried",
        "untrimmed",
        "untrue",
        "untruth",
        "unturned",
        "untwist",
        "untying",
        "unusable",
        "unused",
        "unusual",
        "unvalued",
        "unvaried",
        "unvarying",
        "unveiled",
        "unveiling",
        "unvented",
        "unviable",
        "unvisited",
        "unvocal",
        "unwanted",
        "unwarlike",
        "unwary",
        "unwashed",
        "unwatched",
        "unweave",
        "unwed",
        "unwelcome",
        "unwell",
        "unwieldy",
        "unwilling",
        "unwind",
        "unwired",
        "unwitting",
        "unwomanly",
        "unworldly",
        "unworn",
        "unworried",
        "unworthy",
        "unwound",
        "unwoven",
        "unwrapped",
        "unwritten",
        "unzip",
        "upbeat",
        "upchuck",
        "upcoming",
        "upcountry",
        "update",
        "upfront",
        "upgrade",
        "upheaval",
        "upheld",
        "uphill",
        "uphold",
        "uplifted",
        "uplifting",
        "upload",
        "upon",
        "upper",
        "upright",
        "uprising",
        "upriver",
        "uproar",
        "uproot",
        "upscale",
        "upside",
        "upstage",
        "upstairs",
        "upstart",
        "upstate",
        "upstream",
        "upstroke",
        "upswing",
        "uptake",
        "uptight",
        "uptown",
        "upturned",
        "upward",
        "upwind",
        "uranium",
        "urban",
        "urchin",
        "urethane",
        "urgency",
        "urgent",
        "urging",
        "urologist",
        "urology",
        "usable",
        "usage",
        "useable",
        "used",
        "uselessly",
        "user",
        "usher",
        "usual",
        "utensil",
        "utility",
        "utilize",
        "utmost",
        "utopia",
        "utter",
        "vacancy",
        "vacant",
        "vacate",
        "vacation",
        "vagabond",
        "vagrancy",
        "vagrantly",
        "vaguely",
        "vagueness",
        "valiant",
        "valid",
        "valium",
        "valley",
        "valuables",
        "value",
        "vanilla",
        "vanish",
        "vanity",
        "vanquish",
        "vantage",
        "vaporizer",
        "variable",
        "variably",
        "varied",
        "variety",
        "various",
        "varmint",
        "varnish",
        "varsity",
        "varying",
        "vascular",
        "vaseline",
        "vastly",
        "vastness",
        "veal",
        "vegan",
        "veggie",
        "vehicular",
        "velcro",
        "velocity",
        "velvet",
        "vendetta",
        "vending",
        "vendor",
        "veneering",
        "vengeful",
        "venomous",
        "ventricle",
        "venture",
        "venue",
        "venus",
        "verbalize",
        "verbally",
        "verbose",
        "verdict",
        "verify",
        "verse",
        "version",
        "versus",
        "vertebrae",
        "vertical",
        "vertigo",
        "very",
        "vessel",
        "vest",
        "veteran",
        "veto",
        "vexingly",
        "viability",
        "viable",
        "vibes",
        "vice",
        "vicinity",
        "victory",
        "video",
        "viewable",
        "viewer",
        "viewing",
        "viewless",
        "viewpoint",
        "vigorous",
        "village",
        "villain",
        "vindicate",
        "vineyard",
        "vintage",
        "violate",
        "violation",
        "violator",
        "violet",
        "violin",
        "viper",
        "viral",
        "virtual",
        "virtuous",
        "virus",
        "visa",
        "viscosity",
        "viscous",
        "viselike",
        "visible",
        "visibly",
        "vision",
        "visiting",
        "visitor",
        "visor",
        "vista",
        "vitality",
        "vitalize",
        "vitally",
        "vitamins",
        "vivacious",
        "vividly",
        "vividness",
        "vixen",
        "vocalist",
        "vocalize",
        "vocally",
        "vocation",
        "voice",
        "voicing",
        "void",
        "volatile",
        "volley",
        "voltage",
        "volumes",
        "voter",
        "voting",
        "voucher",
        "vowed",
        "vowel",
        "voyage",
        "wackiness",
        "wad",
        "wafer",
        "waffle",
        "waged",
        "wager",
        "wages",
        "waggle",
        "wagon",
        "wake",
        "waking",
        "walk",
        "walmart",
        "walnut",
        "walrus",
        "waltz",
        "wand",
        "wannabe",
        "wanted",
        "wanting",
        "wasabi",
        "washable",
        "washbasin",
        "washboard",
        "washbowl",
        "washcloth",
        "washday",
        "washed",
        "washer",
        "washhouse",
        "washing",
        "washout",
        "washroom",
        "washstand",
        "washtub",
        "wasp",
        "wasting",
        "watch",
        "water",
        "waviness",
        "waving",
        "wavy",
        "whacking",
        "whacky",
        "wham",
        "wharf",
        "wheat",
        "whenever",
        "whiff",
        "whimsical",
        "whinny",
        "whiny",
        "whisking",
        "whoever",
        "whole",
        "whomever",
        "whoopee",
        "whooping",
        "whoops",
        "why",
        "wick",
        "widely",
        "widen",
        "widget",
        "widow",
        "width",
        "wieldable",
        "wielder",
        "wife",
        "wifi",
        "wikipedia",
        "wildcard",
        "wildcat",
        "wilder",
        "wildfire",
        "wildfowl",
        "wildland",
        "wildlife",
        "wildly",
        "wildness",
        "willed",
        "willfully",
        "willing",
        "willow",
        "willpower",
        "wilt",
        "wimp",
        "wince",
        "wincing",
        "wind",
        "wing",
        "winking",
        "winner",
        "winnings",
        "winter",
        "wipe",
        "wired",
        "wireless",
        "wiring",
        "wiry",
        "wisdom",
        "wise",
        "wish",
        "wisplike",
        "wispy",
        "wistful",
        "wizard",
        "wobble",
        "wobbling",
        "wobbly",
        "wok",
        "wolf",
        "wolverine",
        "womanhood",
        "womankind",
        "womanless",
        "womanlike",
        "womanly",
        "womb",
        "woof",
        "wooing",
        "wool",
        "woozy",
        "word",
        "work",
        "worried",
        "worrier",
        "worrisome",
        "worry",
        "worsening",
        "worshiper",
        "worst",
        "wound",
        "woven",
        "wow",
        "wrangle",
        "wrath",
        "wreath",
        "wreckage",
        "wrecker",
        "wrecking",
        "wrench",
        "wriggle",
        "wriggly",
        "wrinkle",
        "wrinkly",
        "wrist",
        "writing",
        "written",
        "wrongdoer",
        "wronged",
        "wrongful",
        "wrongly",
        "wrongness",
        "wrought",
        "xbox",
        "xerox",
        "yahoo",
        "yam",
        "yanking",
        "yapping",
        "yard",
        "yarn",
        "yeah",
        "yearbook",
        "yearling",
        "yearly",
        "yearning",
        "yeast",
        "yelling",
        "yelp",
        "yen",
        "yesterday",
        "yiddish",
        "yield",
        "yin",
        "yippee",
        "yo-yo",
        "yodel",
        "yoga",
        "yogurt",
        "yonder",
        "yoyo",
        "yummy",
        "zap",
        "zealous",
        "zebra",
        "zen",
        "zeppelin",
        "zero",
        "zestfully",
        "zesty",
        "zigzagged",
        "zipfile",
        "zipping",
        "zippy",
        "zips",
        "zit",
        "zodiac",
        "zombie",
        "zone",
        "zoning",
        "zookeeper",
        "zoologist",
        "zoology",
        "zoom"
      ];
    }
  });

  // node_modules/ton-crypto/dist/passwords/newSecureWords.js
  var require_newSecureWords = __commonJS({
    "node_modules/ton-crypto/dist/passwords/newSecureWords.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.newSecureWords = void 0;
      var getSecureRandom_1 = require_getSecureRandom2();
      var wordlist_1 = require_wordlist();
      async function newSecureWords(size = 6) {
        let words = [];
        for (let i = 0; i < size; i++) {
          words.push(wordlist_1.wordlist[await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length)]);
        }
        return words;
      }
      exports.newSecureWords = newSecureWords;
    }
  });

  // node_modules/ton-crypto/dist/passwords/newSecurePassphrase.js
  var require_newSecurePassphrase = __commonJS({
    "node_modules/ton-crypto/dist/passwords/newSecurePassphrase.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.newSecurePassphrase = void 0;
      var __1 = require_dist();
      async function newSecurePassphrase(size = 6) {
        return (await (0, __1.newSecureWords)(size)).join("-");
      }
      exports.newSecurePassphrase = newSecurePassphrase;
    }
  });

  // node_modules/esbuild-plugin-polyfill-node/polyfills/empty.js
  var empty_exports = {};
  __export(empty_exports, {
    default: () => empty_default
  });
  var empty_default;
  var init_empty = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/empty.js"() {
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      empty_default = {};
    }
  });

  // node_modules/tweetnacl/nacl-fast.js
  var require_nacl_fast = __commonJS({
    "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      (function(nacl) {
        "use strict";
        var gf = function(init2) {
          var i, r = new Float64Array(16);
          if (init2)
            for (i = 0; i < init2.length; i++)
              r[i] = init2[i];
          return r;
        };
        var randombytes = function() {
          throw new Error("no PRNG");
        };
        var _0 = new Uint8Array(16);
        var _9 = new Uint8Array(32);
        _9[0] = 9;
        var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
        function ts64(x, i, h, l) {
          x[i] = h >> 24 & 255;
          x[i + 1] = h >> 16 & 255;
          x[i + 2] = h >> 8 & 255;
          x[i + 3] = h & 255;
          x[i + 4] = l >> 24 & 255;
          x[i + 5] = l >> 16 & 255;
          x[i + 6] = l >> 8 & 255;
          x[i + 7] = l & 255;
        }
        function vn(x, xi, y, yi, n) {
          var i, d = 0;
          for (i = 0; i < n; i++)
            d |= x[xi + i] ^ y[yi + i];
          return (1 & d - 1 >>> 8) - 1;
        }
        function crypto_verify_16(x, xi, y, yi) {
          return vn(x, xi, y, yi, 16);
        }
        function crypto_verify_32(x, xi, y, yi) {
          return vn(x, xi, y, yi, 32);
        }
        function core_salsa20(o, p, k, c) {
          var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
          var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
          for (var i = 0; i < 20; i += 2) {
            u = x0 + x12 | 0;
            x4 ^= u << 7 | u >>> 32 - 7;
            u = x4 + x0 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x4 | 0;
            x12 ^= u << 13 | u >>> 32 - 13;
            u = x12 + x8 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x1 | 0;
            x9 ^= u << 7 | u >>> 32 - 7;
            u = x9 + x5 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x9 | 0;
            x1 ^= u << 13 | u >>> 32 - 13;
            u = x1 + x13 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x6 | 0;
            x14 ^= u << 7 | u >>> 32 - 7;
            u = x14 + x10 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x14 | 0;
            x6 ^= u << 13 | u >>> 32 - 13;
            u = x6 + x2 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x11 | 0;
            x3 ^= u << 7 | u >>> 32 - 7;
            u = x3 + x15 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x3 | 0;
            x11 ^= u << 13 | u >>> 32 - 13;
            u = x11 + x7 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
            u = x0 + x3 | 0;
            x1 ^= u << 7 | u >>> 32 - 7;
            u = x1 + x0 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x1 | 0;
            x3 ^= u << 13 | u >>> 32 - 13;
            u = x3 + x2 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x4 | 0;
            x6 ^= u << 7 | u >>> 32 - 7;
            u = x6 + x5 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x6 | 0;
            x4 ^= u << 13 | u >>> 32 - 13;
            u = x4 + x7 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x9 | 0;
            x11 ^= u << 7 | u >>> 32 - 7;
            u = x11 + x10 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x11 | 0;
            x9 ^= u << 13 | u >>> 32 - 13;
            u = x9 + x8 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x14 | 0;
            x12 ^= u << 7 | u >>> 32 - 7;
            u = x12 + x15 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x12 | 0;
            x14 ^= u << 13 | u >>> 32 - 13;
            u = x14 + x13 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
          }
          x0 = x0 + j0 | 0;
          x1 = x1 + j1 | 0;
          x2 = x2 + j2 | 0;
          x3 = x3 + j3 | 0;
          x4 = x4 + j4 | 0;
          x5 = x5 + j5 | 0;
          x6 = x6 + j6 | 0;
          x7 = x7 + j7 | 0;
          x8 = x8 + j8 | 0;
          x9 = x9 + j9 | 0;
          x10 = x10 + j10 | 0;
          x11 = x11 + j11 | 0;
          x12 = x12 + j12 | 0;
          x13 = x13 + j13 | 0;
          x14 = x14 + j14 | 0;
          x15 = x15 + j15 | 0;
          o[0] = x0 >>> 0 & 255;
          o[1] = x0 >>> 8 & 255;
          o[2] = x0 >>> 16 & 255;
          o[3] = x0 >>> 24 & 255;
          o[4] = x1 >>> 0 & 255;
          o[5] = x1 >>> 8 & 255;
          o[6] = x1 >>> 16 & 255;
          o[7] = x1 >>> 24 & 255;
          o[8] = x2 >>> 0 & 255;
          o[9] = x2 >>> 8 & 255;
          o[10] = x2 >>> 16 & 255;
          o[11] = x2 >>> 24 & 255;
          o[12] = x3 >>> 0 & 255;
          o[13] = x3 >>> 8 & 255;
          o[14] = x3 >>> 16 & 255;
          o[15] = x3 >>> 24 & 255;
          o[16] = x4 >>> 0 & 255;
          o[17] = x4 >>> 8 & 255;
          o[18] = x4 >>> 16 & 255;
          o[19] = x4 >>> 24 & 255;
          o[20] = x5 >>> 0 & 255;
          o[21] = x5 >>> 8 & 255;
          o[22] = x5 >>> 16 & 255;
          o[23] = x5 >>> 24 & 255;
          o[24] = x6 >>> 0 & 255;
          o[25] = x6 >>> 8 & 255;
          o[26] = x6 >>> 16 & 255;
          o[27] = x6 >>> 24 & 255;
          o[28] = x7 >>> 0 & 255;
          o[29] = x7 >>> 8 & 255;
          o[30] = x7 >>> 16 & 255;
          o[31] = x7 >>> 24 & 255;
          o[32] = x8 >>> 0 & 255;
          o[33] = x8 >>> 8 & 255;
          o[34] = x8 >>> 16 & 255;
          o[35] = x8 >>> 24 & 255;
          o[36] = x9 >>> 0 & 255;
          o[37] = x9 >>> 8 & 255;
          o[38] = x9 >>> 16 & 255;
          o[39] = x9 >>> 24 & 255;
          o[40] = x10 >>> 0 & 255;
          o[41] = x10 >>> 8 & 255;
          o[42] = x10 >>> 16 & 255;
          o[43] = x10 >>> 24 & 255;
          o[44] = x11 >>> 0 & 255;
          o[45] = x11 >>> 8 & 255;
          o[46] = x11 >>> 16 & 255;
          o[47] = x11 >>> 24 & 255;
          o[48] = x12 >>> 0 & 255;
          o[49] = x12 >>> 8 & 255;
          o[50] = x12 >>> 16 & 255;
          o[51] = x12 >>> 24 & 255;
          o[52] = x13 >>> 0 & 255;
          o[53] = x13 >>> 8 & 255;
          o[54] = x13 >>> 16 & 255;
          o[55] = x13 >>> 24 & 255;
          o[56] = x14 >>> 0 & 255;
          o[57] = x14 >>> 8 & 255;
          o[58] = x14 >>> 16 & 255;
          o[59] = x14 >>> 24 & 255;
          o[60] = x15 >>> 0 & 255;
          o[61] = x15 >>> 8 & 255;
          o[62] = x15 >>> 16 & 255;
          o[63] = x15 >>> 24 & 255;
        }
        function core_hsalsa20(o, p, k, c) {
          var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
          var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
          for (var i = 0; i < 20; i += 2) {
            u = x0 + x12 | 0;
            x4 ^= u << 7 | u >>> 32 - 7;
            u = x4 + x0 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x4 | 0;
            x12 ^= u << 13 | u >>> 32 - 13;
            u = x12 + x8 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x1 | 0;
            x9 ^= u << 7 | u >>> 32 - 7;
            u = x9 + x5 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x9 | 0;
            x1 ^= u << 13 | u >>> 32 - 13;
            u = x1 + x13 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x6 | 0;
            x14 ^= u << 7 | u >>> 32 - 7;
            u = x14 + x10 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x14 | 0;
            x6 ^= u << 13 | u >>> 32 - 13;
            u = x6 + x2 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x11 | 0;
            x3 ^= u << 7 | u >>> 32 - 7;
            u = x3 + x15 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x3 | 0;
            x11 ^= u << 13 | u >>> 32 - 13;
            u = x11 + x7 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
            u = x0 + x3 | 0;
            x1 ^= u << 7 | u >>> 32 - 7;
            u = x1 + x0 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x1 | 0;
            x3 ^= u << 13 | u >>> 32 - 13;
            u = x3 + x2 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x4 | 0;
            x6 ^= u << 7 | u >>> 32 - 7;
            u = x6 + x5 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x6 | 0;
            x4 ^= u << 13 | u >>> 32 - 13;
            u = x4 + x7 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x9 | 0;
            x11 ^= u << 7 | u >>> 32 - 7;
            u = x11 + x10 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x11 | 0;
            x9 ^= u << 13 | u >>> 32 - 13;
            u = x9 + x8 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x14 | 0;
            x12 ^= u << 7 | u >>> 32 - 7;
            u = x12 + x15 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x12 | 0;
            x14 ^= u << 13 | u >>> 32 - 13;
            u = x14 + x13 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
          }
          o[0] = x0 >>> 0 & 255;
          o[1] = x0 >>> 8 & 255;
          o[2] = x0 >>> 16 & 255;
          o[3] = x0 >>> 24 & 255;
          o[4] = x5 >>> 0 & 255;
          o[5] = x5 >>> 8 & 255;
          o[6] = x5 >>> 16 & 255;
          o[7] = x5 >>> 24 & 255;
          o[8] = x10 >>> 0 & 255;
          o[9] = x10 >>> 8 & 255;
          o[10] = x10 >>> 16 & 255;
          o[11] = x10 >>> 24 & 255;
          o[12] = x15 >>> 0 & 255;
          o[13] = x15 >>> 8 & 255;
          o[14] = x15 >>> 16 & 255;
          o[15] = x15 >>> 24 & 255;
          o[16] = x6 >>> 0 & 255;
          o[17] = x6 >>> 8 & 255;
          o[18] = x6 >>> 16 & 255;
          o[19] = x6 >>> 24 & 255;
          o[20] = x7 >>> 0 & 255;
          o[21] = x7 >>> 8 & 255;
          o[22] = x7 >>> 16 & 255;
          o[23] = x7 >>> 24 & 255;
          o[24] = x8 >>> 0 & 255;
          o[25] = x8 >>> 8 & 255;
          o[26] = x8 >>> 16 & 255;
          o[27] = x8 >>> 24 & 255;
          o[28] = x9 >>> 0 & 255;
          o[29] = x9 >>> 8 & 255;
          o[30] = x9 >>> 16 & 255;
          o[31] = x9 >>> 24 & 255;
        }
        function crypto_core_salsa20(out, inp, k, c) {
          core_salsa20(out, inp, k, c);
        }
        function crypto_core_hsalsa20(out, inp, k, c) {
          core_hsalsa20(out, inp, k, c);
        }
        var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
        function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
          var z = new Uint8Array(16), x = new Uint8Array(64);
          var u, i;
          for (i = 0; i < 16; i++)
            z[i] = 0;
          for (i = 0; i < 8; i++)
            z[i] = n[i];
          while (b >= 64) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0; i < 64; i++)
              c[cpos + i] = m[mpos + i] ^ x[i];
            u = 1;
            for (i = 8; i < 16; i++) {
              u = u + (z[i] & 255) | 0;
              z[i] = u & 255;
              u >>>= 8;
            }
            b -= 64;
            cpos += 64;
            mpos += 64;
          }
          if (b > 0) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0; i < b; i++)
              c[cpos + i] = m[mpos + i] ^ x[i];
          }
          return 0;
        }
        function crypto_stream_salsa20(c, cpos, b, n, k) {
          var z = new Uint8Array(16), x = new Uint8Array(64);
          var u, i;
          for (i = 0; i < 16; i++)
            z[i] = 0;
          for (i = 0; i < 8; i++)
            z[i] = n[i];
          while (b >= 64) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0; i < 64; i++)
              c[cpos + i] = x[i];
            u = 1;
            for (i = 8; i < 16; i++) {
              u = u + (z[i] & 255) | 0;
              z[i] = u & 255;
              u >>>= 8;
            }
            b -= 64;
            cpos += 64;
          }
          if (b > 0) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0; i < b; i++)
              c[cpos + i] = x[i];
          }
          return 0;
        }
        function crypto_stream(c, cpos, d, n, k) {
          var s = new Uint8Array(32);
          crypto_core_hsalsa20(s, n, k, sigma);
          var sn = new Uint8Array(8);
          for (var i = 0; i < 8; i++)
            sn[i] = n[i + 16];
          return crypto_stream_salsa20(c, cpos, d, sn, s);
        }
        function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
          var s = new Uint8Array(32);
          crypto_core_hsalsa20(s, n, k, sigma);
          var sn = new Uint8Array(8);
          for (var i = 0; i < 8; i++)
            sn[i] = n[i + 16];
          return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
        }
        var poly1305 = function(key) {
          this.buffer = new Uint8Array(16);
          this.r = new Uint16Array(10);
          this.h = new Uint16Array(10);
          this.pad = new Uint16Array(8);
          this.leftover = 0;
          this.fin = 0;
          var t0, t1, t2, t3, t4, t5, t6, t7;
          t0 = key[0] & 255 | (key[1] & 255) << 8;
          this.r[0] = t0 & 8191;
          t1 = key[2] & 255 | (key[3] & 255) << 8;
          this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
          t2 = key[4] & 255 | (key[5] & 255) << 8;
          this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
          t3 = key[6] & 255 | (key[7] & 255) << 8;
          this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
          t4 = key[8] & 255 | (key[9] & 255) << 8;
          this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
          this.r[5] = t4 >>> 1 & 8190;
          t5 = key[10] & 255 | (key[11] & 255) << 8;
          this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
          t6 = key[12] & 255 | (key[13] & 255) << 8;
          this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
          t7 = key[14] & 255 | (key[15] & 255) << 8;
          this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
          this.r[9] = t7 >>> 5 & 127;
          this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
          this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
          this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
          this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
          this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
          this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
          this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
          this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
        };
        poly1305.prototype.blocks = function(m, mpos, bytes) {
          var hibit = this.fin ? 0 : 1 << 11;
          var t0, t1, t2, t3, t4, t5, t6, t7, c;
          var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
          var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
          var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
          while (bytes >= 16) {
            t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
            h0 += t0 & 8191;
            t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 8191;
            t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
            h2 += (t1 >>> 10 | t2 << 6) & 8191;
            t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
            h3 += (t2 >>> 7 | t3 << 9) & 8191;
            t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
            h4 += (t3 >>> 4 | t4 << 12) & 8191;
            h5 += t4 >>> 1 & 8191;
            t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 8191;
            t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 8191;
            t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 8191;
            h9 += t7 >>> 5 | hibit;
            c = 0;
            d0 = c;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c = d0 >>> 13;
            d0 &= 8191;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c += d0 >>> 13;
            d0 &= 8191;
            d1 = c;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c = d1 >>> 13;
            d1 &= 8191;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c += d1 >>> 13;
            d1 &= 8191;
            d2 = c;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c = d2 >>> 13;
            d2 &= 8191;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c += d2 >>> 13;
            d2 &= 8191;
            d3 = c;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c = d3 >>> 13;
            d3 &= 8191;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c += d3 >>> 13;
            d3 &= 8191;
            d4 = c;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c = d4 >>> 13;
            d4 &= 8191;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c += d4 >>> 13;
            d4 &= 8191;
            d5 = c;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c = d5 >>> 13;
            d5 &= 8191;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c += d5 >>> 13;
            d5 &= 8191;
            d6 = c;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c = d6 >>> 13;
            d6 &= 8191;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c += d6 >>> 13;
            d6 &= 8191;
            d7 = c;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c = d7 >>> 13;
            d7 &= 8191;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c += d7 >>> 13;
            d7 &= 8191;
            d8 = c;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c = d8 >>> 13;
            d8 &= 8191;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c += d8 >>> 13;
            d8 &= 8191;
            d9 = c;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c = d9 >>> 13;
            d9 &= 8191;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c += d9 >>> 13;
            d9 &= 8191;
            c = (c << 2) + c | 0;
            c = c + d0 | 0;
            d0 = c & 8191;
            c = c >>> 13;
            d1 += c;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
          }
          this.h[0] = h0;
          this.h[1] = h1;
          this.h[2] = h2;
          this.h[3] = h3;
          this.h[4] = h4;
          this.h[5] = h5;
          this.h[6] = h6;
          this.h[7] = h7;
          this.h[8] = h8;
          this.h[9] = h9;
        };
        poly1305.prototype.finish = function(mac, macpos) {
          var g = new Uint16Array(10);
          var c, mask, f, i;
          if (this.leftover) {
            i = this.leftover;
            this.buffer[i++] = 1;
            for (; i < 16; i++)
              this.buffer[i] = 0;
            this.fin = 1;
            this.blocks(this.buffer, 0, 16);
          }
          c = this.h[1] >>> 13;
          this.h[1] &= 8191;
          for (i = 2; i < 10; i++) {
            this.h[i] += c;
            c = this.h[i] >>> 13;
            this.h[i] &= 8191;
          }
          this.h[0] += c * 5;
          c = this.h[0] >>> 13;
          this.h[0] &= 8191;
          this.h[1] += c;
          c = this.h[1] >>> 13;
          this.h[1] &= 8191;
          this.h[2] += c;
          g[0] = this.h[0] + 5;
          c = g[0] >>> 13;
          g[0] &= 8191;
          for (i = 1; i < 10; i++) {
            g[i] = this.h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 8191;
          }
          g[9] -= 1 << 13;
          mask = (c ^ 1) - 1;
          for (i = 0; i < 10; i++)
            g[i] &= mask;
          mask = ~mask;
          for (i = 0; i < 10; i++)
            this.h[i] = this.h[i] & mask | g[i];
          this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
          this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
          this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
          this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
          this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
          this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
          this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
          this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
          f = this.h[0] + this.pad[0];
          this.h[0] = f & 65535;
          for (i = 1; i < 8; i++) {
            f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
            this.h[i] = f & 65535;
          }
          mac[macpos + 0] = this.h[0] >>> 0 & 255;
          mac[macpos + 1] = this.h[0] >>> 8 & 255;
          mac[macpos + 2] = this.h[1] >>> 0 & 255;
          mac[macpos + 3] = this.h[1] >>> 8 & 255;
          mac[macpos + 4] = this.h[2] >>> 0 & 255;
          mac[macpos + 5] = this.h[2] >>> 8 & 255;
          mac[macpos + 6] = this.h[3] >>> 0 & 255;
          mac[macpos + 7] = this.h[3] >>> 8 & 255;
          mac[macpos + 8] = this.h[4] >>> 0 & 255;
          mac[macpos + 9] = this.h[4] >>> 8 & 255;
          mac[macpos + 10] = this.h[5] >>> 0 & 255;
          mac[macpos + 11] = this.h[5] >>> 8 & 255;
          mac[macpos + 12] = this.h[6] >>> 0 & 255;
          mac[macpos + 13] = this.h[6] >>> 8 & 255;
          mac[macpos + 14] = this.h[7] >>> 0 & 255;
          mac[macpos + 15] = this.h[7] >>> 8 & 255;
        };
        poly1305.prototype.update = function(m, mpos, bytes) {
          var i, want;
          if (this.leftover) {
            want = 16 - this.leftover;
            if (want > bytes)
              want = bytes;
            for (i = 0; i < want; i++)
              this.buffer[this.leftover + i] = m[mpos + i];
            bytes -= want;
            mpos += want;
            this.leftover += want;
            if (this.leftover < 16)
              return;
            this.blocks(this.buffer, 0, 16);
            this.leftover = 0;
          }
          if (bytes >= 16) {
            want = bytes - bytes % 16;
            this.blocks(m, mpos, want);
            mpos += want;
            bytes -= want;
          }
          if (bytes) {
            for (i = 0; i < bytes; i++)
              this.buffer[this.leftover + i] = m[mpos + i];
            this.leftover += bytes;
          }
        };
        function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
          var s = new poly1305(k);
          s.update(m, mpos, n);
          s.finish(out, outpos);
          return 0;
        }
        function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
          var x = new Uint8Array(16);
          crypto_onetimeauth(x, 0, m, mpos, n, k);
          return crypto_verify_16(h, hpos, x, 0);
        }
        function crypto_secretbox(c, m, d, n, k) {
          var i;
          if (d < 32)
            return -1;
          crypto_stream_xor(c, 0, m, 0, d, n, k);
          crypto_onetimeauth(c, 16, c, 32, d - 32, c);
          for (i = 0; i < 16; i++)
            c[i] = 0;
          return 0;
        }
        function crypto_secretbox_open(m, c, d, n, k) {
          var i;
          var x = new Uint8Array(32);
          if (d < 32)
            return -1;
          crypto_stream(x, 0, 32, n, k);
          if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
            return -1;
          crypto_stream_xor(m, 0, c, 0, d, n, k);
          for (i = 0; i < 32; i++)
            m[i] = 0;
          return 0;
        }
        function set25519(r, a) {
          var i;
          for (i = 0; i < 16; i++)
            r[i] = a[i] | 0;
        }
        function car25519(o) {
          var i, v, c = 1;
          for (i = 0; i < 16; i++) {
            v = o[i] + c + 65535;
            c = Math.floor(v / 65536);
            o[i] = v - c * 65536;
          }
          o[0] += c - 1 + 37 * (c - 1);
        }
        function sel25519(p, q, b) {
          var t, c = ~(b - 1);
          for (var i = 0; i < 16; i++) {
            t = c & (p[i] ^ q[i]);
            p[i] ^= t;
            q[i] ^= t;
          }
        }
        function pack25519(o, n) {
          var i, j, b;
          var m = gf(), t = gf();
          for (i = 0; i < 16; i++)
            t[i] = n[i];
          car25519(t);
          car25519(t);
          car25519(t);
          for (j = 0; j < 2; j++) {
            m[0] = t[0] - 65517;
            for (i = 1; i < 15; i++) {
              m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
              m[i - 1] &= 65535;
            }
            m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
            b = m[15] >> 16 & 1;
            m[14] &= 65535;
            sel25519(t, m, 1 - b);
          }
          for (i = 0; i < 16; i++) {
            o[2 * i] = t[i] & 255;
            o[2 * i + 1] = t[i] >> 8;
          }
        }
        function neq25519(a, b) {
          var c = new Uint8Array(32), d = new Uint8Array(32);
          pack25519(c, a);
          pack25519(d, b);
          return crypto_verify_32(c, 0, d, 0);
        }
        function par25519(a) {
          var d = new Uint8Array(32);
          pack25519(d, a);
          return d[0] & 1;
        }
        function unpack25519(o, n) {
          var i;
          for (i = 0; i < 16; i++)
            o[i] = n[2 * i] + (n[2 * i + 1] << 8);
          o[15] &= 32767;
        }
        function A(o, a, b) {
          for (var i = 0; i < 16; i++)
            o[i] = a[i] + b[i];
        }
        function Z(o, a, b) {
          for (var i = 0; i < 16; i++)
            o[i] = a[i] - b[i];
        }
        function M(o, a, b) {
          var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
          v = a[0];
          t0 += v * b0;
          t1 += v * b1;
          t2 += v * b2;
          t3 += v * b3;
          t4 += v * b4;
          t5 += v * b5;
          t6 += v * b6;
          t7 += v * b7;
          t8 += v * b8;
          t9 += v * b9;
          t10 += v * b10;
          t11 += v * b11;
          t12 += v * b12;
          t13 += v * b13;
          t14 += v * b14;
          t15 += v * b15;
          v = a[1];
          t1 += v * b0;
          t2 += v * b1;
          t3 += v * b2;
          t4 += v * b3;
          t5 += v * b4;
          t6 += v * b5;
          t7 += v * b6;
          t8 += v * b7;
          t9 += v * b8;
          t10 += v * b9;
          t11 += v * b10;
          t12 += v * b11;
          t13 += v * b12;
          t14 += v * b13;
          t15 += v * b14;
          t16 += v * b15;
          v = a[2];
          t2 += v * b0;
          t3 += v * b1;
          t4 += v * b2;
          t5 += v * b3;
          t6 += v * b4;
          t7 += v * b5;
          t8 += v * b6;
          t9 += v * b7;
          t10 += v * b8;
          t11 += v * b9;
          t12 += v * b10;
          t13 += v * b11;
          t14 += v * b12;
          t15 += v * b13;
          t16 += v * b14;
          t17 += v * b15;
          v = a[3];
          t3 += v * b0;
          t4 += v * b1;
          t5 += v * b2;
          t6 += v * b3;
          t7 += v * b4;
          t8 += v * b5;
          t9 += v * b6;
          t10 += v * b7;
          t11 += v * b8;
          t12 += v * b9;
          t13 += v * b10;
          t14 += v * b11;
          t15 += v * b12;
          t16 += v * b13;
          t17 += v * b14;
          t18 += v * b15;
          v = a[4];
          t4 += v * b0;
          t5 += v * b1;
          t6 += v * b2;
          t7 += v * b3;
          t8 += v * b4;
          t9 += v * b5;
          t10 += v * b6;
          t11 += v * b7;
          t12 += v * b8;
          t13 += v * b9;
          t14 += v * b10;
          t15 += v * b11;
          t16 += v * b12;
          t17 += v * b13;
          t18 += v * b14;
          t19 += v * b15;
          v = a[5];
          t5 += v * b0;
          t6 += v * b1;
          t7 += v * b2;
          t8 += v * b3;
          t9 += v * b4;
          t10 += v * b5;
          t11 += v * b6;
          t12 += v * b7;
          t13 += v * b8;
          t14 += v * b9;
          t15 += v * b10;
          t16 += v * b11;
          t17 += v * b12;
          t18 += v * b13;
          t19 += v * b14;
          t20 += v * b15;
          v = a[6];
          t6 += v * b0;
          t7 += v * b1;
          t8 += v * b2;
          t9 += v * b3;
          t10 += v * b4;
          t11 += v * b5;
          t12 += v * b6;
          t13 += v * b7;
          t14 += v * b8;
          t15 += v * b9;
          t16 += v * b10;
          t17 += v * b11;
          t18 += v * b12;
          t19 += v * b13;
          t20 += v * b14;
          t21 += v * b15;
          v = a[7];
          t7 += v * b0;
          t8 += v * b1;
          t9 += v * b2;
          t10 += v * b3;
          t11 += v * b4;
          t12 += v * b5;
          t13 += v * b6;
          t14 += v * b7;
          t15 += v * b8;
          t16 += v * b9;
          t17 += v * b10;
          t18 += v * b11;
          t19 += v * b12;
          t20 += v * b13;
          t21 += v * b14;
          t22 += v * b15;
          v = a[8];
          t8 += v * b0;
          t9 += v * b1;
          t10 += v * b2;
          t11 += v * b3;
          t12 += v * b4;
          t13 += v * b5;
          t14 += v * b6;
          t15 += v * b7;
          t16 += v * b8;
          t17 += v * b9;
          t18 += v * b10;
          t19 += v * b11;
          t20 += v * b12;
          t21 += v * b13;
          t22 += v * b14;
          t23 += v * b15;
          v = a[9];
          t9 += v * b0;
          t10 += v * b1;
          t11 += v * b2;
          t12 += v * b3;
          t13 += v * b4;
          t14 += v * b5;
          t15 += v * b6;
          t16 += v * b7;
          t17 += v * b8;
          t18 += v * b9;
          t19 += v * b10;
          t20 += v * b11;
          t21 += v * b12;
          t22 += v * b13;
          t23 += v * b14;
          t24 += v * b15;
          v = a[10];
          t10 += v * b0;
          t11 += v * b1;
          t12 += v * b2;
          t13 += v * b3;
          t14 += v * b4;
          t15 += v * b5;
          t16 += v * b6;
          t17 += v * b7;
          t18 += v * b8;
          t19 += v * b9;
          t20 += v * b10;
          t21 += v * b11;
          t22 += v * b12;
          t23 += v * b13;
          t24 += v * b14;
          t25 += v * b15;
          v = a[11];
          t11 += v * b0;
          t12 += v * b1;
          t13 += v * b2;
          t14 += v * b3;
          t15 += v * b4;
          t16 += v * b5;
          t17 += v * b6;
          t18 += v * b7;
          t19 += v * b8;
          t20 += v * b9;
          t21 += v * b10;
          t22 += v * b11;
          t23 += v * b12;
          t24 += v * b13;
          t25 += v * b14;
          t26 += v * b15;
          v = a[12];
          t12 += v * b0;
          t13 += v * b1;
          t14 += v * b2;
          t15 += v * b3;
          t16 += v * b4;
          t17 += v * b5;
          t18 += v * b6;
          t19 += v * b7;
          t20 += v * b8;
          t21 += v * b9;
          t22 += v * b10;
          t23 += v * b11;
          t24 += v * b12;
          t25 += v * b13;
          t26 += v * b14;
          t27 += v * b15;
          v = a[13];
          t13 += v * b0;
          t14 += v * b1;
          t15 += v * b2;
          t16 += v * b3;
          t17 += v * b4;
          t18 += v * b5;
          t19 += v * b6;
          t20 += v * b7;
          t21 += v * b8;
          t22 += v * b9;
          t23 += v * b10;
          t24 += v * b11;
          t25 += v * b12;
          t26 += v * b13;
          t27 += v * b14;
          t28 += v * b15;
          v = a[14];
          t14 += v * b0;
          t15 += v * b1;
          t16 += v * b2;
          t17 += v * b3;
          t18 += v * b4;
          t19 += v * b5;
          t20 += v * b6;
          t21 += v * b7;
          t22 += v * b8;
          t23 += v * b9;
          t24 += v * b10;
          t25 += v * b11;
          t26 += v * b12;
          t27 += v * b13;
          t28 += v * b14;
          t29 += v * b15;
          v = a[15];
          t15 += v * b0;
          t16 += v * b1;
          t17 += v * b2;
          t18 += v * b3;
          t19 += v * b4;
          t20 += v * b5;
          t21 += v * b6;
          t22 += v * b7;
          t23 += v * b8;
          t24 += v * b9;
          t25 += v * b10;
          t26 += v * b11;
          t27 += v * b12;
          t28 += v * b13;
          t29 += v * b14;
          t30 += v * b15;
          t0 += 38 * t16;
          t1 += 38 * t17;
          t2 += 38 * t18;
          t3 += 38 * t19;
          t4 += 38 * t20;
          t5 += 38 * t21;
          t6 += 38 * t22;
          t7 += 38 * t23;
          t8 += 38 * t24;
          t9 += 38 * t25;
          t10 += 38 * t26;
          t11 += 38 * t27;
          t12 += 38 * t28;
          t13 += 38 * t29;
          t14 += 38 * t30;
          c = 1;
          v = t0 + c + 65535;
          c = Math.floor(v / 65536);
          t0 = v - c * 65536;
          v = t1 + c + 65535;
          c = Math.floor(v / 65536);
          t1 = v - c * 65536;
          v = t2 + c + 65535;
          c = Math.floor(v / 65536);
          t2 = v - c * 65536;
          v = t3 + c + 65535;
          c = Math.floor(v / 65536);
          t3 = v - c * 65536;
          v = t4 + c + 65535;
          c = Math.floor(v / 65536);
          t4 = v - c * 65536;
          v = t5 + c + 65535;
          c = Math.floor(v / 65536);
          t5 = v - c * 65536;
          v = t6 + c + 65535;
          c = Math.floor(v / 65536);
          t6 = v - c * 65536;
          v = t7 + c + 65535;
          c = Math.floor(v / 65536);
          t7 = v - c * 65536;
          v = t8 + c + 65535;
          c = Math.floor(v / 65536);
          t8 = v - c * 65536;
          v = t9 + c + 65535;
          c = Math.floor(v / 65536);
          t9 = v - c * 65536;
          v = t10 + c + 65535;
          c = Math.floor(v / 65536);
          t10 = v - c * 65536;
          v = t11 + c + 65535;
          c = Math.floor(v / 65536);
          t11 = v - c * 65536;
          v = t12 + c + 65535;
          c = Math.floor(v / 65536);
          t12 = v - c * 65536;
          v = t13 + c + 65535;
          c = Math.floor(v / 65536);
          t13 = v - c * 65536;
          v = t14 + c + 65535;
          c = Math.floor(v / 65536);
          t14 = v - c * 65536;
          v = t15 + c + 65535;
          c = Math.floor(v / 65536);
          t15 = v - c * 65536;
          t0 += c - 1 + 37 * (c - 1);
          c = 1;
          v = t0 + c + 65535;
          c = Math.floor(v / 65536);
          t0 = v - c * 65536;
          v = t1 + c + 65535;
          c = Math.floor(v / 65536);
          t1 = v - c * 65536;
          v = t2 + c + 65535;
          c = Math.floor(v / 65536);
          t2 = v - c * 65536;
          v = t3 + c + 65535;
          c = Math.floor(v / 65536);
          t3 = v - c * 65536;
          v = t4 + c + 65535;
          c = Math.floor(v / 65536);
          t4 = v - c * 65536;
          v = t5 + c + 65535;
          c = Math.floor(v / 65536);
          t5 = v - c * 65536;
          v = t6 + c + 65535;
          c = Math.floor(v / 65536);
          t6 = v - c * 65536;
          v = t7 + c + 65535;
          c = Math.floor(v / 65536);
          t7 = v - c * 65536;
          v = t8 + c + 65535;
          c = Math.floor(v / 65536);
          t8 = v - c * 65536;
          v = t9 + c + 65535;
          c = Math.floor(v / 65536);
          t9 = v - c * 65536;
          v = t10 + c + 65535;
          c = Math.floor(v / 65536);
          t10 = v - c * 65536;
          v = t11 + c + 65535;
          c = Math.floor(v / 65536);
          t11 = v - c * 65536;
          v = t12 + c + 65535;
          c = Math.floor(v / 65536);
          t12 = v - c * 65536;
          v = t13 + c + 65535;
          c = Math.floor(v / 65536);
          t13 = v - c * 65536;
          v = t14 + c + 65535;
          c = Math.floor(v / 65536);
          t14 = v - c * 65536;
          v = t15 + c + 65535;
          c = Math.floor(v / 65536);
          t15 = v - c * 65536;
          t0 += c - 1 + 37 * (c - 1);
          o[0] = t0;
          o[1] = t1;
          o[2] = t2;
          o[3] = t3;
          o[4] = t4;
          o[5] = t5;
          o[6] = t6;
          o[7] = t7;
          o[8] = t8;
          o[9] = t9;
          o[10] = t10;
          o[11] = t11;
          o[12] = t12;
          o[13] = t13;
          o[14] = t14;
          o[15] = t15;
        }
        function S(o, a) {
          M(o, a, a);
        }
        function inv25519(o, i) {
          var c = gf();
          var a;
          for (a = 0; a < 16; a++)
            c[a] = i[a];
          for (a = 253; a >= 0; a--) {
            S(c, c);
            if (a !== 2 && a !== 4)
              M(c, c, i);
          }
          for (a = 0; a < 16; a++)
            o[a] = c[a];
        }
        function pow2523(o, i) {
          var c = gf();
          var a;
          for (a = 0; a < 16; a++)
            c[a] = i[a];
          for (a = 250; a >= 0; a--) {
            S(c, c);
            if (a !== 1)
              M(c, c, i);
          }
          for (a = 0; a < 16; a++)
            o[a] = c[a];
        }
        function crypto_scalarmult(q, n, p) {
          var z = new Uint8Array(32);
          var x = new Float64Array(80), r, i;
          var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
          for (i = 0; i < 31; i++)
            z[i] = n[i];
          z[31] = n[31] & 127 | 64;
          z[0] &= 248;
          unpack25519(x, p);
          for (i = 0; i < 16; i++) {
            b[i] = x[i];
            d[i] = a[i] = c[i] = 0;
          }
          a[0] = d[0] = 1;
          for (i = 254; i >= 0; --i) {
            r = z[i >>> 3] >>> (i & 7) & 1;
            sel25519(a, b, r);
            sel25519(c, d, r);
            A(e, a, c);
            Z(a, a, c);
            A(c, b, d);
            Z(b, b, d);
            S(d, e);
            S(f, a);
            M(a, c, a);
            M(c, b, e);
            A(e, a, c);
            Z(a, a, c);
            S(b, a);
            Z(c, d, f);
            M(a, c, _121665);
            A(a, a, d);
            M(c, c, a);
            M(a, d, f);
            M(d, b, x);
            S(b, e);
            sel25519(a, b, r);
            sel25519(c, d, r);
          }
          for (i = 0; i < 16; i++) {
            x[i + 16] = a[i];
            x[i + 32] = c[i];
            x[i + 48] = b[i];
            x[i + 64] = d[i];
          }
          var x32 = x.subarray(32);
          var x16 = x.subarray(16);
          inv25519(x32, x32);
          M(x16, x16, x32);
          pack25519(q, x16);
          return 0;
        }
        function crypto_scalarmult_base(q, n) {
          return crypto_scalarmult(q, n, _9);
        }
        function crypto_box_keypair(y, x) {
          randombytes(x, 32);
          return crypto_scalarmult_base(y, x);
        }
        function crypto_box_beforenm(k, y, x) {
          var s = new Uint8Array(32);
          crypto_scalarmult(s, x, y);
          return crypto_core_hsalsa20(k, _0, s, sigma);
        }
        var crypto_box_afternm = crypto_secretbox;
        var crypto_box_open_afternm = crypto_secretbox_open;
        function crypto_box(c, m, d, n, y, x) {
          var k = new Uint8Array(32);
          crypto_box_beforenm(k, y, x);
          return crypto_box_afternm(c, m, d, n, k);
        }
        function crypto_box_open(m, c, d, n, y, x) {
          var k = new Uint8Array(32);
          crypto_box_beforenm(k, y, x);
          return crypto_box_open_afternm(m, c, d, n, k);
        }
        var K = [
          1116352408,
          3609767458,
          1899447441,
          602891725,
          3049323471,
          3964484399,
          3921009573,
          2173295548,
          961987163,
          4081628472,
          1508970993,
          3053834265,
          2453635748,
          2937671579,
          2870763221,
          3664609560,
          3624381080,
          2734883394,
          310598401,
          1164996542,
          607225278,
          1323610764,
          1426881987,
          3590304994,
          1925078388,
          4068182383,
          2162078206,
          991336113,
          2614888103,
          633803317,
          3248222580,
          3479774868,
          3835390401,
          2666613458,
          4022224774,
          944711139,
          264347078,
          2341262773,
          604807628,
          2007800933,
          770255983,
          1495990901,
          1249150122,
          1856431235,
          1555081692,
          3175218132,
          1996064986,
          2198950837,
          2554220882,
          3999719339,
          2821834349,
          766784016,
          2952996808,
          2566594879,
          3210313671,
          3203337956,
          3336571891,
          1034457026,
          3584528711,
          2466948901,
          113926993,
          3758326383,
          338241895,
          168717936,
          666307205,
          1188179964,
          773529912,
          1546045734,
          1294757372,
          1522805485,
          1396182291,
          2643833823,
          1695183700,
          2343527390,
          1986661051,
          1014477480,
          2177026350,
          1206759142,
          2456956037,
          344077627,
          2730485921,
          1290863460,
          2820302411,
          3158454273,
          3259730800,
          3505952657,
          3345764771,
          106217008,
          3516065817,
          3606008344,
          3600352804,
          1432725776,
          4094571909,
          1467031594,
          275423344,
          851169720,
          430227734,
          3100823752,
          506948616,
          1363258195,
          659060556,
          3750685593,
          883997877,
          3785050280,
          958139571,
          3318307427,
          1322822218,
          3812723403,
          1537002063,
          2003034995,
          1747873779,
          3602036899,
          1955562222,
          1575990012,
          2024104815,
          1125592928,
          2227730452,
          2716904306,
          2361852424,
          442776044,
          2428436474,
          593698344,
          2756734187,
          3733110249,
          3204031479,
          2999351573,
          3329325298,
          3815920427,
          3391569614,
          3928383900,
          3515267271,
          566280711,
          3940187606,
          3454069534,
          4118630271,
          4000239992,
          116418474,
          1914138554,
          174292421,
          2731055270,
          289380356,
          3203993006,
          460393269,
          320620315,
          685471733,
          587496836,
          852142971,
          1086792851,
          1017036298,
          365543100,
          1126000580,
          2618297676,
          1288033470,
          3409855158,
          1501505948,
          4234509866,
          1607167915,
          987167468,
          1816402316,
          1246189591
        ];
        function crypto_hashblocks_hl(hh, hl, m, n) {
          var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
          var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
          var pos = 0;
          while (n >= 128) {
            for (i = 0; i < 16; i++) {
              j = 8 * i + pos;
              wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
              wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
            }
            for (i = 0; i < 80; i++) {
              bh0 = ah0;
              bh1 = ah1;
              bh2 = ah2;
              bh3 = ah3;
              bh4 = ah4;
              bh5 = ah5;
              bh6 = ah6;
              bh7 = ah7;
              bl0 = al0;
              bl1 = al1;
              bl2 = al2;
              bl3 = al3;
              bl4 = al4;
              bl5 = al5;
              bl6 = al6;
              bl7 = al7;
              h = ah7;
              l = al7;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
              l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = ah4 & ah5 ^ ~ah4 & ah6;
              l = al4 & al5 ^ ~al4 & al6;
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = K[i * 2];
              l = K[i * 2 + 1];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = wh[i % 16];
              l = wl[i % 16];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              th = c & 65535 | d << 16;
              tl = a & 65535 | b << 16;
              h = th;
              l = tl;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
              l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
              l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              bh7 = c & 65535 | d << 16;
              bl7 = a & 65535 | b << 16;
              h = bh3;
              l = bl3;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = th;
              l = tl;
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              bh3 = c & 65535 | d << 16;
              bl3 = a & 65535 | b << 16;
              ah1 = bh0;
              ah2 = bh1;
              ah3 = bh2;
              ah4 = bh3;
              ah5 = bh4;
              ah6 = bh5;
              ah7 = bh6;
              ah0 = bh7;
              al1 = bl0;
              al2 = bl1;
              al3 = bl2;
              al4 = bl3;
              al5 = bl4;
              al6 = bl5;
              al7 = bl6;
              al0 = bl7;
              if (i % 16 === 15) {
                for (j = 0; j < 16; j++) {
                  h = wh[j];
                  l = wl[j];
                  a = l & 65535;
                  b = l >>> 16;
                  c = h & 65535;
                  d = h >>> 16;
                  h = wh[(j + 9) % 16];
                  l = wl[(j + 9) % 16];
                  a += l & 65535;
                  b += l >>> 16;
                  c += h & 65535;
                  d += h >>> 16;
                  th = wh[(j + 1) % 16];
                  tl = wl[(j + 1) % 16];
                  h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                  l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                  a += l & 65535;
                  b += l >>> 16;
                  c += h & 65535;
                  d += h >>> 16;
                  th = wh[(j + 14) % 16];
                  tl = wl[(j + 14) % 16];
                  h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                  l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                  a += l & 65535;
                  b += l >>> 16;
                  c += h & 65535;
                  d += h >>> 16;
                  b += a >>> 16;
                  c += b >>> 16;
                  d += c >>> 16;
                  wh[j] = c & 65535 | d << 16;
                  wl[j] = a & 65535 | b << 16;
                }
              }
            }
            h = ah0;
            l = al0;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[0];
            l = hl[0];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[0] = ah0 = c & 65535 | d << 16;
            hl[0] = al0 = a & 65535 | b << 16;
            h = ah1;
            l = al1;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[1];
            l = hl[1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[1] = ah1 = c & 65535 | d << 16;
            hl[1] = al1 = a & 65535 | b << 16;
            h = ah2;
            l = al2;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[2];
            l = hl[2];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[2] = ah2 = c & 65535 | d << 16;
            hl[2] = al2 = a & 65535 | b << 16;
            h = ah3;
            l = al3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[3];
            l = hl[3];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[3] = ah3 = c & 65535 | d << 16;
            hl[3] = al3 = a & 65535 | b << 16;
            h = ah4;
            l = al4;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[4];
            l = hl[4];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[4] = ah4 = c & 65535 | d << 16;
            hl[4] = al4 = a & 65535 | b << 16;
            h = ah5;
            l = al5;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[5];
            l = hl[5];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[5] = ah5 = c & 65535 | d << 16;
            hl[5] = al5 = a & 65535 | b << 16;
            h = ah6;
            l = al6;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[6];
            l = hl[6];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[6] = ah6 = c & 65535 | d << 16;
            hl[6] = al6 = a & 65535 | b << 16;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[7];
            l = hl[7];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[7] = ah7 = c & 65535 | d << 16;
            hl[7] = al7 = a & 65535 | b << 16;
            pos += 128;
            n -= 128;
          }
          return n;
        }
        function crypto_hash(out, m, n) {
          var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
          hh[0] = 1779033703;
          hh[1] = 3144134277;
          hh[2] = 1013904242;
          hh[3] = 2773480762;
          hh[4] = 1359893119;
          hh[5] = 2600822924;
          hh[6] = 528734635;
          hh[7] = 1541459225;
          hl[0] = 4089235720;
          hl[1] = 2227873595;
          hl[2] = 4271175723;
          hl[3] = 1595750129;
          hl[4] = 2917565137;
          hl[5] = 725511199;
          hl[6] = 4215389547;
          hl[7] = 327033209;
          crypto_hashblocks_hl(hh, hl, m, n);
          n %= 128;
          for (i = 0; i < n; i++)
            x[i] = m[b - n + i];
          x[n] = 128;
          n = 256 - 128 * (n < 112 ? 1 : 0);
          x[n - 9] = 0;
          ts64(x, n - 8, b / 536870912 | 0, b << 3);
          crypto_hashblocks_hl(hh, hl, x, n);
          for (i = 0; i < 8; i++)
            ts64(out, 8 * i, hh[i], hl[i]);
          return 0;
        }
        function add(p, q) {
          var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
          Z(a, p[1], p[0]);
          Z(t, q[1], q[0]);
          M(a, a, t);
          A(b, p[0], p[1]);
          A(t, q[0], q[1]);
          M(b, b, t);
          M(c, p[3], q[3]);
          M(c, c, D2);
          M(d, p[2], q[2]);
          A(d, d, d);
          Z(e, b, a);
          Z(f, d, c);
          A(g, d, c);
          A(h, b, a);
          M(p[0], e, f);
          M(p[1], h, g);
          M(p[2], g, f);
          M(p[3], e, h);
        }
        function cswap(p, q, b) {
          var i;
          for (i = 0; i < 4; i++) {
            sel25519(p[i], q[i], b);
          }
        }
        function pack(r, p) {
          var tx = gf(), ty = gf(), zi = gf();
          inv25519(zi, p[2]);
          M(tx, p[0], zi);
          M(ty, p[1], zi);
          pack25519(r, ty);
          r[31] ^= par25519(tx) << 7;
        }
        function scalarmult(p, q, s) {
          var b, i;
          set25519(p[0], gf0);
          set25519(p[1], gf1);
          set25519(p[2], gf1);
          set25519(p[3], gf0);
          for (i = 255; i >= 0; --i) {
            b = s[i / 8 | 0] >> (i & 7) & 1;
            cswap(p, q, b);
            add(q, p);
            add(p, p);
            cswap(p, q, b);
          }
        }
        function scalarbase(p, s) {
          var q = [gf(), gf(), gf(), gf()];
          set25519(q[0], X);
          set25519(q[1], Y);
          set25519(q[2], gf1);
          M(q[3], X, Y);
          scalarmult(p, q, s);
        }
        function crypto_sign_keypair(pk, sk, seeded) {
          var d = new Uint8Array(64);
          var p = [gf(), gf(), gf(), gf()];
          var i;
          if (!seeded)
            randombytes(sk, 32);
          crypto_hash(d, sk, 32);
          d[0] &= 248;
          d[31] &= 127;
          d[31] |= 64;
          scalarbase(p, d);
          pack(pk, p);
          for (i = 0; i < 32; i++)
            sk[i + 32] = pk[i];
          return 0;
        }
        var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
        function modL(r, x) {
          var carry, i, j, k;
          for (i = 63; i >= 32; --i) {
            carry = 0;
            for (j = i - 32, k = i - 12; j < k; ++j) {
              x[j] += carry - 16 * x[i] * L[j - (i - 32)];
              carry = Math.floor((x[j] + 128) / 256);
              x[j] -= carry * 256;
            }
            x[j] += carry;
            x[i] = 0;
          }
          carry = 0;
          for (j = 0; j < 32; j++) {
            x[j] += carry - (x[31] >> 4) * L[j];
            carry = x[j] >> 8;
            x[j] &= 255;
          }
          for (j = 0; j < 32; j++)
            x[j] -= carry * L[j];
          for (i = 0; i < 32; i++) {
            x[i + 1] += x[i] >> 8;
            r[i] = x[i] & 255;
          }
        }
        function reduce(r) {
          var x = new Float64Array(64), i;
          for (i = 0; i < 64; i++)
            x[i] = r[i];
          for (i = 0; i < 64; i++)
            r[i] = 0;
          modL(r, x);
        }
        function crypto_sign(sm, m, n, sk) {
          var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
          var i, j, x = new Float64Array(64);
          var p = [gf(), gf(), gf(), gf()];
          crypto_hash(d, sk, 32);
          d[0] &= 248;
          d[31] &= 127;
          d[31] |= 64;
          var smlen = n + 64;
          for (i = 0; i < n; i++)
            sm[64 + i] = m[i];
          for (i = 0; i < 32; i++)
            sm[32 + i] = d[32 + i];
          crypto_hash(r, sm.subarray(32), n + 32);
          reduce(r);
          scalarbase(p, r);
          pack(sm, p);
          for (i = 32; i < 64; i++)
            sm[i] = sk[i];
          crypto_hash(h, sm, n + 64);
          reduce(h);
          for (i = 0; i < 64; i++)
            x[i] = 0;
          for (i = 0; i < 32; i++)
            x[i] = r[i];
          for (i = 0; i < 32; i++) {
            for (j = 0; j < 32; j++) {
              x[i + j] += h[i] * d[j];
            }
          }
          modL(sm.subarray(32), x);
          return smlen;
        }
        function unpackneg(r, p) {
          var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
          set25519(r[2], gf1);
          unpack25519(r[1], p);
          S(num, r[1]);
          M(den, num, D);
          Z(num, num, r[2]);
          A(den, r[2], den);
          S(den2, den);
          S(den4, den2);
          M(den6, den4, den2);
          M(t, den6, num);
          M(t, t, den);
          pow2523(t, t);
          M(t, t, num);
          M(t, t, den);
          M(t, t, den);
          M(r[0], t, den);
          S(chk, r[0]);
          M(chk, chk, den);
          if (neq25519(chk, num))
            M(r[0], r[0], I);
          S(chk, r[0]);
          M(chk, chk, den);
          if (neq25519(chk, num))
            return -1;
          if (par25519(r[0]) === p[31] >> 7)
            Z(r[0], gf0, r[0]);
          M(r[3], r[0], r[1]);
          return 0;
        }
        function crypto_sign_open(m, sm, n, pk) {
          var i;
          var t = new Uint8Array(32), h = new Uint8Array(64);
          var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
          if (n < 64)
            return -1;
          if (unpackneg(q, pk))
            return -1;
          for (i = 0; i < n; i++)
            m[i] = sm[i];
          for (i = 0; i < 32; i++)
            m[i + 32] = pk[i];
          crypto_hash(h, m, n);
          reduce(h);
          scalarmult(p, q, h);
          scalarbase(q, sm.subarray(32));
          add(p, q);
          pack(t, p);
          n -= 64;
          if (crypto_verify_32(sm, 0, t, 0)) {
            for (i = 0; i < n; i++)
              m[i] = 0;
            return -1;
          }
          for (i = 0; i < n; i++)
            m[i] = sm[i + 64];
          return n;
        }
        var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
        nacl.lowlevel = {
          crypto_core_hsalsa20,
          crypto_stream_xor,
          crypto_stream,
          crypto_stream_salsa20_xor,
          crypto_stream_salsa20,
          crypto_onetimeauth,
          crypto_onetimeauth_verify,
          crypto_verify_16,
          crypto_verify_32,
          crypto_secretbox,
          crypto_secretbox_open,
          crypto_scalarmult,
          crypto_scalarmult_base,
          crypto_box_beforenm,
          crypto_box_afternm,
          crypto_box,
          crypto_box_open,
          crypto_box_keypair,
          crypto_hash,
          crypto_sign,
          crypto_sign_keypair,
          crypto_sign_open,
          crypto_secretbox_KEYBYTES,
          crypto_secretbox_NONCEBYTES,
          crypto_secretbox_ZEROBYTES,
          crypto_secretbox_BOXZEROBYTES,
          crypto_scalarmult_BYTES,
          crypto_scalarmult_SCALARBYTES,
          crypto_box_PUBLICKEYBYTES,
          crypto_box_SECRETKEYBYTES,
          crypto_box_BEFORENMBYTES,
          crypto_box_NONCEBYTES,
          crypto_box_ZEROBYTES,
          crypto_box_BOXZEROBYTES,
          crypto_sign_BYTES,
          crypto_sign_PUBLICKEYBYTES,
          crypto_sign_SECRETKEYBYTES,
          crypto_sign_SEEDBYTES,
          crypto_hash_BYTES,
          gf,
          D,
          L,
          pack25519,
          unpack25519,
          M,
          A,
          S,
          Z,
          pow2523,
          add,
          set25519,
          modL,
          scalarmult,
          scalarbase
        };
        function checkLengths(k, n) {
          if (k.length !== crypto_secretbox_KEYBYTES)
            throw new Error("bad key size");
          if (n.length !== crypto_secretbox_NONCEBYTES)
            throw new Error("bad nonce size");
        }
        function checkBoxLengths(pk, sk) {
          if (pk.length !== crypto_box_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          if (sk.length !== crypto_box_SECRETKEYBYTES)
            throw new Error("bad secret key size");
        }
        function checkArrayTypes() {
          for (var i = 0; i < arguments.length; i++) {
            if (!(arguments[i] instanceof Uint8Array))
              throw new TypeError("unexpected type, use Uint8Array");
          }
        }
        function cleanup(arr) {
          for (var i = 0; i < arr.length; i++)
            arr[i] = 0;
        }
        nacl.randomBytes = function(n) {
          var b = new Uint8Array(n);
          randombytes(b, n);
          return b;
        };
        nacl.secretbox = function(msg, nonce, key) {
          checkArrayTypes(msg, nonce, key);
          checkLengths(key, nonce);
          var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
          var c = new Uint8Array(m.length);
          for (var i = 0; i < msg.length; i++)
            m[i + crypto_secretbox_ZEROBYTES] = msg[i];
          crypto_secretbox(c, m, m.length, nonce, key);
          return c.subarray(crypto_secretbox_BOXZEROBYTES);
        };
        nacl.secretbox.open = function(box, nonce, key) {
          checkArrayTypes(box, nonce, key);
          checkLengths(key, nonce);
          var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
          var m = new Uint8Array(c.length);
          for (var i = 0; i < box.length; i++)
            c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
          if (c.length < 32)
            return null;
          if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
            return null;
          return m.subarray(crypto_secretbox_ZEROBYTES);
        };
        nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
        nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
        nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
        nacl.scalarMult = function(n, p) {
          checkArrayTypes(n, p);
          if (n.length !== crypto_scalarmult_SCALARBYTES)
            throw new Error("bad n size");
          if (p.length !== crypto_scalarmult_BYTES)
            throw new Error("bad p size");
          var q = new Uint8Array(crypto_scalarmult_BYTES);
          crypto_scalarmult(q, n, p);
          return q;
        };
        nacl.scalarMult.base = function(n) {
          checkArrayTypes(n);
          if (n.length !== crypto_scalarmult_SCALARBYTES)
            throw new Error("bad n size");
          var q = new Uint8Array(crypto_scalarmult_BYTES);
          crypto_scalarmult_base(q, n);
          return q;
        };
        nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
        nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
        nacl.box = function(msg, nonce, publicKey, secretKey) {
          var k = nacl.box.before(publicKey, secretKey);
          return nacl.secretbox(msg, nonce, k);
        };
        nacl.box.before = function(publicKey, secretKey) {
          checkArrayTypes(publicKey, secretKey);
          checkBoxLengths(publicKey, secretKey);
          var k = new Uint8Array(crypto_box_BEFORENMBYTES);
          crypto_box_beforenm(k, publicKey, secretKey);
          return k;
        };
        nacl.box.after = nacl.secretbox;
        nacl.box.open = function(msg, nonce, publicKey, secretKey) {
          var k = nacl.box.before(publicKey, secretKey);
          return nacl.secretbox.open(msg, nonce, k);
        };
        nacl.box.open.after = nacl.secretbox.open;
        nacl.box.keyPair = function() {
          var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
          crypto_box_keypair(pk, sk);
          return { publicKey: pk, secretKey: sk };
        };
        nacl.box.keyPair.fromSecretKey = function(secretKey) {
          checkArrayTypes(secretKey);
          if (secretKey.length !== crypto_box_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
          crypto_scalarmult_base(pk, secretKey);
          return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
        };
        nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
        nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
        nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
        nacl.box.nonceLength = crypto_box_NONCEBYTES;
        nacl.box.overheadLength = nacl.secretbox.overheadLength;
        nacl.sign = function(msg, secretKey) {
          checkArrayTypes(msg, secretKey);
          if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
          crypto_sign(signedMsg, msg, msg.length, secretKey);
          return signedMsg;
        };
        nacl.sign.open = function(signedMsg, publicKey) {
          checkArrayTypes(signedMsg, publicKey);
          if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          var tmp = new Uint8Array(signedMsg.length);
          var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
          if (mlen < 0)
            return null;
          var m = new Uint8Array(mlen);
          for (var i = 0; i < m.length; i++)
            m[i] = tmp[i];
          return m;
        };
        nacl.sign.detached = function(msg, secretKey) {
          var signedMsg = nacl.sign(msg, secretKey);
          var sig = new Uint8Array(crypto_sign_BYTES);
          for (var i = 0; i < sig.length; i++)
            sig[i] = signedMsg[i];
          return sig;
        };
        nacl.sign.detached.verify = function(msg, sig, publicKey) {
          checkArrayTypes(msg, sig, publicKey);
          if (sig.length !== crypto_sign_BYTES)
            throw new Error("bad signature size");
          if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
          var m = new Uint8Array(crypto_sign_BYTES + msg.length);
          var i;
          for (i = 0; i < crypto_sign_BYTES; i++)
            sm[i] = sig[i];
          for (i = 0; i < msg.length; i++)
            sm[i + crypto_sign_BYTES] = msg[i];
          return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
        };
        nacl.sign.keyPair = function() {
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
          crypto_sign_keypair(pk, sk);
          return { publicKey: pk, secretKey: sk };
        };
        nacl.sign.keyPair.fromSecretKey = function(secretKey) {
          checkArrayTypes(secretKey);
          if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          for (var i = 0; i < pk.length; i++)
            pk[i] = secretKey[32 + i];
          return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
        };
        nacl.sign.keyPair.fromSeed = function(seed) {
          checkArrayTypes(seed);
          if (seed.length !== crypto_sign_SEEDBYTES)
            throw new Error("bad seed size");
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
          for (var i = 0; i < 32; i++)
            sk[i] = seed[i];
          crypto_sign_keypair(pk, sk, true);
          return { publicKey: pk, secretKey: sk };
        };
        nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
        nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
        nacl.sign.seedLength = crypto_sign_SEEDBYTES;
        nacl.sign.signatureLength = crypto_sign_BYTES;
        nacl.hash = function(msg) {
          checkArrayTypes(msg);
          var h = new Uint8Array(crypto_hash_BYTES);
          crypto_hash(h, msg, msg.length);
          return h;
        };
        nacl.hash.hashLength = crypto_hash_BYTES;
        nacl.verify = function(x, y) {
          checkArrayTypes(x, y);
          if (x.length === 0 || y.length === 0)
            return false;
          if (x.length !== y.length)
            return false;
          return vn(x, 0, y, 0, x.length) === 0 ? true : false;
        };
        nacl.setPRNG = function(fn) {
          randombytes = fn;
        };
        (function() {
          var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
          if (crypto2 && crypto2.getRandomValues) {
            var QUOTA = 65536;
            nacl.setPRNG(function(x, n) {
              var i, v = new Uint8Array(n);
              for (i = 0; i < n; i += QUOTA) {
                crypto2.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
              }
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          } else if (typeof __require !== "undefined") {
            crypto2 = (init_empty(), __toCommonJS(empty_exports));
            if (crypto2 && crypto2.randomBytes) {
              nacl.setPRNG(function(x, n) {
                var i, v = crypto2.randomBytes(n);
                for (i = 0; i < n; i++)
                  x[i] = v[i];
                cleanup(v);
              });
            }
          }
        })();
      })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
    }
  });

  // node_modules/ton-crypto/dist/utils/binary.js
  var require_binary = __commonJS({
    "node_modules/ton-crypto/dist/utils/binary.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bitsToBytes = exports.bytesToBits = exports.lpad = void 0;
      function lpad(str, padString, length) {
        while (str.length < length) {
          str = padString + str;
        }
        return str;
      }
      exports.lpad = lpad;
      function bytesToBits(bytes) {
        let res = "";
        for (let i = 0; i < bytes.length; i++) {
          let x = bytes.at(i);
          res += lpad(x.toString(2), "0", 8);
        }
        return res;
      }
      exports.bytesToBits = bytesToBits;
      function bitsToBytes(src) {
        if (src.length % 8 !== 0) {
          throw Error("Uneven bits");
        }
        let res = [];
        while (src.length > 0) {
          res.push(parseInt(src.slice(0, 8), 2));
          src = src.slice(8);
        }
        return Buffer2.from(res);
      }
      exports.bitsToBytes = bitsToBytes;
    }
  });

  // node_modules/ton-crypto/dist/mnemonic/wordlist.js
  var require_wordlist2 = __commonJS({
    "node_modules/ton-crypto/dist/mnemonic/wordlist.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.wordlist = void 0;
      var EN = [
        "abandon",
        "ability",
        "able",
        "about",
        "above",
        "absent",
        "absorb",
        "abstract",
        "absurd",
        "abuse",
        "access",
        "accident",
        "account",
        "accuse",
        "achieve",
        "acid",
        "acoustic",
        "acquire",
        "across",
        "act",
        "action",
        "actor",
        "actress",
        "actual",
        "adapt",
        "add",
        "addict",
        "address",
        "adjust",
        "admit",
        "adult",
        "advance",
        "advice",
        "aerobic",
        "affair",
        "afford",
        "afraid",
        "again",
        "age",
        "agent",
        "agree",
        "ahead",
        "aim",
        "air",
        "airport",
        "aisle",
        "alarm",
        "album",
        "alcohol",
        "alert",
        "alien",
        "all",
        "alley",
        "allow",
        "almost",
        "alone",
        "alpha",
        "already",
        "also",
        "alter",
        "always",
        "amateur",
        "amazing",
        "among",
        "amount",
        "amused",
        "analyst",
        "anchor",
        "ancient",
        "anger",
        "angle",
        "angry",
        "animal",
        "ankle",
        "announce",
        "annual",
        "another",
        "answer",
        "antenna",
        "antique",
        "anxiety",
        "any",
        "apart",
        "apology",
        "appear",
        "apple",
        "approve",
        "april",
        "arch",
        "arctic",
        "area",
        "arena",
        "argue",
        "arm",
        "armed",
        "armor",
        "army",
        "around",
        "arrange",
        "arrest",
        "arrive",
        "arrow",
        "art",
        "artefact",
        "artist",
        "artwork",
        "ask",
        "aspect",
        "assault",
        "asset",
        "assist",
        "assume",
        "asthma",
        "athlete",
        "atom",
        "attack",
        "attend",
        "attitude",
        "attract",
        "auction",
        "audit",
        "august",
        "aunt",
        "author",
        "auto",
        "autumn",
        "average",
        "avocado",
        "avoid",
        "awake",
        "aware",
        "away",
        "awesome",
        "awful",
        "awkward",
        "axis",
        "baby",
        "bachelor",
        "bacon",
        "badge",
        "bag",
        "balance",
        "balcony",
        "ball",
        "bamboo",
        "banana",
        "banner",
        "bar",
        "barely",
        "bargain",
        "barrel",
        "base",
        "basic",
        "basket",
        "battle",
        "beach",
        "bean",
        "beauty",
        "because",
        "become",
        "beef",
        "before",
        "begin",
        "behave",
        "behind",
        "believe",
        "below",
        "belt",
        "bench",
        "benefit",
        "best",
        "betray",
        "better",
        "between",
        "beyond",
        "bicycle",
        "bid",
        "bike",
        "bind",
        "biology",
        "bird",
        "birth",
        "bitter",
        "black",
        "blade",
        "blame",
        "blanket",
        "blast",
        "bleak",
        "bless",
        "blind",
        "blood",
        "blossom",
        "blouse",
        "blue",
        "blur",
        "blush",
        "board",
        "boat",
        "body",
        "boil",
        "bomb",
        "bone",
        "bonus",
        "book",
        "boost",
        "border",
        "boring",
        "borrow",
        "boss",
        "bottom",
        "bounce",
        "box",
        "boy",
        "bracket",
        "brain",
        "brand",
        "brass",
        "brave",
        "bread",
        "breeze",
        "brick",
        "bridge",
        "brief",
        "bright",
        "bring",
        "brisk",
        "broccoli",
        "broken",
        "bronze",
        "broom",
        "brother",
        "brown",
        "brush",
        "bubble",
        "buddy",
        "budget",
        "buffalo",
        "build",
        "bulb",
        "bulk",
        "bullet",
        "bundle",
        "bunker",
        "burden",
        "burger",
        "burst",
        "bus",
        "business",
        "busy",
        "butter",
        "buyer",
        "buzz",
        "cabbage",
        "cabin",
        "cable",
        "cactus",
        "cage",
        "cake",
        "call",
        "calm",
        "camera",
        "camp",
        "can",
        "canal",
        "cancel",
        "candy",
        "cannon",
        "canoe",
        "canvas",
        "canyon",
        "capable",
        "capital",
        "captain",
        "car",
        "carbon",
        "card",
        "cargo",
        "carpet",
        "carry",
        "cart",
        "case",
        "cash",
        "casino",
        "castle",
        "casual",
        "cat",
        "catalog",
        "catch",
        "category",
        "cattle",
        "caught",
        "cause",
        "caution",
        "cave",
        "ceiling",
        "celery",
        "cement",
        "census",
        "century",
        "cereal",
        "certain",
        "chair",
        "chalk",
        "champion",
        "change",
        "chaos",
        "chapter",
        "charge",
        "chase",
        "chat",
        "cheap",
        "check",
        "cheese",
        "chef",
        "cherry",
        "chest",
        "chicken",
        "chief",
        "child",
        "chimney",
        "choice",
        "choose",
        "chronic",
        "chuckle",
        "chunk",
        "churn",
        "cigar",
        "cinnamon",
        "circle",
        "citizen",
        "city",
        "civil",
        "claim",
        "clap",
        "clarify",
        "claw",
        "clay",
        "clean",
        "clerk",
        "clever",
        "click",
        "client",
        "cliff",
        "climb",
        "clinic",
        "clip",
        "clock",
        "clog",
        "close",
        "cloth",
        "cloud",
        "clown",
        "club",
        "clump",
        "cluster",
        "clutch",
        "coach",
        "coast",
        "coconut",
        "code",
        "coffee",
        "coil",
        "coin",
        "collect",
        "color",
        "column",
        "combine",
        "come",
        "comfort",
        "comic",
        "common",
        "company",
        "concert",
        "conduct",
        "confirm",
        "congress",
        "connect",
        "consider",
        "control",
        "convince",
        "cook",
        "cool",
        "copper",
        "copy",
        "coral",
        "core",
        "corn",
        "correct",
        "cost",
        "cotton",
        "couch",
        "country",
        "couple",
        "course",
        "cousin",
        "cover",
        "coyote",
        "crack",
        "cradle",
        "craft",
        "cram",
        "crane",
        "crash",
        "crater",
        "crawl",
        "crazy",
        "cream",
        "credit",
        "creek",
        "crew",
        "cricket",
        "crime",
        "crisp",
        "critic",
        "crop",
        "cross",
        "crouch",
        "crowd",
        "crucial",
        "cruel",
        "cruise",
        "crumble",
        "crunch",
        "crush",
        "cry",
        "crystal",
        "cube",
        "culture",
        "cup",
        "cupboard",
        "curious",
        "current",
        "curtain",
        "curve",
        "cushion",
        "custom",
        "cute",
        "cycle",
        "dad",
        "damage",
        "damp",
        "dance",
        "danger",
        "daring",
        "dash",
        "daughter",
        "dawn",
        "day",
        "deal",
        "debate",
        "debris",
        "decade",
        "december",
        "decide",
        "decline",
        "decorate",
        "decrease",
        "deer",
        "defense",
        "define",
        "defy",
        "degree",
        "delay",
        "deliver",
        "demand",
        "demise",
        "denial",
        "dentist",
        "deny",
        "depart",
        "depend",
        "deposit",
        "depth",
        "deputy",
        "derive",
        "describe",
        "desert",
        "design",
        "desk",
        "despair",
        "destroy",
        "detail",
        "detect",
        "develop",
        "device",
        "devote",
        "diagram",
        "dial",
        "diamond",
        "diary",
        "dice",
        "diesel",
        "diet",
        "differ",
        "digital",
        "dignity",
        "dilemma",
        "dinner",
        "dinosaur",
        "direct",
        "dirt",
        "disagree",
        "discover",
        "disease",
        "dish",
        "dismiss",
        "disorder",
        "display",
        "distance",
        "divert",
        "divide",
        "divorce",
        "dizzy",
        "doctor",
        "document",
        "dog",
        "doll",
        "dolphin",
        "domain",
        "donate",
        "donkey",
        "donor",
        "door",
        "dose",
        "double",
        "dove",
        "draft",
        "dragon",
        "drama",
        "drastic",
        "draw",
        "dream",
        "dress",
        "drift",
        "drill",
        "drink",
        "drip",
        "drive",
        "drop",
        "drum",
        "dry",
        "duck",
        "dumb",
        "dune",
        "during",
        "dust",
        "dutch",
        "duty",
        "dwarf",
        "dynamic",
        "eager",
        "eagle",
        "early",
        "earn",
        "earth",
        "easily",
        "east",
        "easy",
        "echo",
        "ecology",
        "economy",
        "edge",
        "edit",
        "educate",
        "effort",
        "egg",
        "eight",
        "either",
        "elbow",
        "elder",
        "electric",
        "elegant",
        "element",
        "elephant",
        "elevator",
        "elite",
        "else",
        "embark",
        "embody",
        "embrace",
        "emerge",
        "emotion",
        "employ",
        "empower",
        "empty",
        "enable",
        "enact",
        "end",
        "endless",
        "endorse",
        "enemy",
        "energy",
        "enforce",
        "engage",
        "engine",
        "enhance",
        "enjoy",
        "enlist",
        "enough",
        "enrich",
        "enroll",
        "ensure",
        "enter",
        "entire",
        "entry",
        "envelope",
        "episode",
        "equal",
        "equip",
        "era",
        "erase",
        "erode",
        "erosion",
        "error",
        "erupt",
        "escape",
        "essay",
        "essence",
        "estate",
        "eternal",
        "ethics",
        "evidence",
        "evil",
        "evoke",
        "evolve",
        "exact",
        "example",
        "excess",
        "exchange",
        "excite",
        "exclude",
        "excuse",
        "execute",
        "exercise",
        "exhaust",
        "exhibit",
        "exile",
        "exist",
        "exit",
        "exotic",
        "expand",
        "expect",
        "expire",
        "explain",
        "expose",
        "express",
        "extend",
        "extra",
        "eye",
        "eyebrow",
        "fabric",
        "face",
        "faculty",
        "fade",
        "faint",
        "faith",
        "fall",
        "false",
        "fame",
        "family",
        "famous",
        "fan",
        "fancy",
        "fantasy",
        "farm",
        "fashion",
        "fat",
        "fatal",
        "father",
        "fatigue",
        "fault",
        "favorite",
        "feature",
        "february",
        "federal",
        "fee",
        "feed",
        "feel",
        "female",
        "fence",
        "festival",
        "fetch",
        "fever",
        "few",
        "fiber",
        "fiction",
        "field",
        "figure",
        "file",
        "film",
        "filter",
        "final",
        "find",
        "fine",
        "finger",
        "finish",
        "fire",
        "firm",
        "first",
        "fiscal",
        "fish",
        "fit",
        "fitness",
        "fix",
        "flag",
        "flame",
        "flash",
        "flat",
        "flavor",
        "flee",
        "flight",
        "flip",
        "float",
        "flock",
        "floor",
        "flower",
        "fluid",
        "flush",
        "fly",
        "foam",
        "focus",
        "fog",
        "foil",
        "fold",
        "follow",
        "food",
        "foot",
        "force",
        "forest",
        "forget",
        "fork",
        "fortune",
        "forum",
        "forward",
        "fossil",
        "foster",
        "found",
        "fox",
        "fragile",
        "frame",
        "frequent",
        "fresh",
        "friend",
        "fringe",
        "frog",
        "front",
        "frost",
        "frown",
        "frozen",
        "fruit",
        "fuel",
        "fun",
        "funny",
        "furnace",
        "fury",
        "future",
        "gadget",
        "gain",
        "galaxy",
        "gallery",
        "game",
        "gap",
        "garage",
        "garbage",
        "garden",
        "garlic",
        "garment",
        "gas",
        "gasp",
        "gate",
        "gather",
        "gauge",
        "gaze",
        "general",
        "genius",
        "genre",
        "gentle",
        "genuine",
        "gesture",
        "ghost",
        "giant",
        "gift",
        "giggle",
        "ginger",
        "giraffe",
        "girl",
        "give",
        "glad",
        "glance",
        "glare",
        "glass",
        "glide",
        "glimpse",
        "globe",
        "gloom",
        "glory",
        "glove",
        "glow",
        "glue",
        "goat",
        "goddess",
        "gold",
        "good",
        "goose",
        "gorilla",
        "gospel",
        "gossip",
        "govern",
        "gown",
        "grab",
        "grace",
        "grain",
        "grant",
        "grape",
        "grass",
        "gravity",
        "great",
        "green",
        "grid",
        "grief",
        "grit",
        "grocery",
        "group",
        "grow",
        "grunt",
        "guard",
        "guess",
        "guide",
        "guilt",
        "guitar",
        "gun",
        "gym",
        "habit",
        "hair",
        "half",
        "hammer",
        "hamster",
        "hand",
        "happy",
        "harbor",
        "hard",
        "harsh",
        "harvest",
        "hat",
        "have",
        "hawk",
        "hazard",
        "head",
        "health",
        "heart",
        "heavy",
        "hedgehog",
        "height",
        "hello",
        "helmet",
        "help",
        "hen",
        "hero",
        "hidden",
        "high",
        "hill",
        "hint",
        "hip",
        "hire",
        "history",
        "hobby",
        "hockey",
        "hold",
        "hole",
        "holiday",
        "hollow",
        "home",
        "honey",
        "hood",
        "hope",
        "horn",
        "horror",
        "horse",
        "hospital",
        "host",
        "hotel",
        "hour",
        "hover",
        "hub",
        "huge",
        "human",
        "humble",
        "humor",
        "hundred",
        "hungry",
        "hunt",
        "hurdle",
        "hurry",
        "hurt",
        "husband",
        "hybrid",
        "ice",
        "icon",
        "idea",
        "identify",
        "idle",
        "ignore",
        "ill",
        "illegal",
        "illness",
        "image",
        "imitate",
        "immense",
        "immune",
        "impact",
        "impose",
        "improve",
        "impulse",
        "inch",
        "include",
        "income",
        "increase",
        "index",
        "indicate",
        "indoor",
        "industry",
        "infant",
        "inflict",
        "inform",
        "inhale",
        "inherit",
        "initial",
        "inject",
        "injury",
        "inmate",
        "inner",
        "innocent",
        "input",
        "inquiry",
        "insane",
        "insect",
        "inside",
        "inspire",
        "install",
        "intact",
        "interest",
        "into",
        "invest",
        "invite",
        "involve",
        "iron",
        "island",
        "isolate",
        "issue",
        "item",
        "ivory",
        "jacket",
        "jaguar",
        "jar",
        "jazz",
        "jealous",
        "jeans",
        "jelly",
        "jewel",
        "job",
        "join",
        "joke",
        "journey",
        "joy",
        "judge",
        "juice",
        "jump",
        "jungle",
        "junior",
        "junk",
        "just",
        "kangaroo",
        "keen",
        "keep",
        "ketchup",
        "key",
        "kick",
        "kid",
        "kidney",
        "kind",
        "kingdom",
        "kiss",
        "kit",
        "kitchen",
        "kite",
        "kitten",
        "kiwi",
        "knee",
        "knife",
        "knock",
        "know",
        "lab",
        "label",
        "labor",
        "ladder",
        "lady",
        "lake",
        "lamp",
        "language",
        "laptop",
        "large",
        "later",
        "latin",
        "laugh",
        "laundry",
        "lava",
        "law",
        "lawn",
        "lawsuit",
        "layer",
        "lazy",
        "leader",
        "leaf",
        "learn",
        "leave",
        "lecture",
        "left",
        "leg",
        "legal",
        "legend",
        "leisure",
        "lemon",
        "lend",
        "length",
        "lens",
        "leopard",
        "lesson",
        "letter",
        "level",
        "liar",
        "liberty",
        "library",
        "license",
        "life",
        "lift",
        "light",
        "like",
        "limb",
        "limit",
        "link",
        "lion",
        "liquid",
        "list",
        "little",
        "live",
        "lizard",
        "load",
        "loan",
        "lobster",
        "local",
        "lock",
        "logic",
        "lonely",
        "long",
        "loop",
        "lottery",
        "loud",
        "lounge",
        "love",
        "loyal",
        "lucky",
        "luggage",
        "lumber",
        "lunar",
        "lunch",
        "luxury",
        "lyrics",
        "machine",
        "mad",
        "magic",
        "magnet",
        "maid",
        "mail",
        "main",
        "major",
        "make",
        "mammal",
        "man",
        "manage",
        "mandate",
        "mango",
        "mansion",
        "manual",
        "maple",
        "marble",
        "march",
        "margin",
        "marine",
        "market",
        "marriage",
        "mask",
        "mass",
        "master",
        "match",
        "material",
        "math",
        "matrix",
        "matter",
        "maximum",
        "maze",
        "meadow",
        "mean",
        "measure",
        "meat",
        "mechanic",
        "medal",
        "media",
        "melody",
        "melt",
        "member",
        "memory",
        "mention",
        "menu",
        "mercy",
        "merge",
        "merit",
        "merry",
        "mesh",
        "message",
        "metal",
        "method",
        "middle",
        "midnight",
        "milk",
        "million",
        "mimic",
        "mind",
        "minimum",
        "minor",
        "minute",
        "miracle",
        "mirror",
        "misery",
        "miss",
        "mistake",
        "mix",
        "mixed",
        "mixture",
        "mobile",
        "model",
        "modify",
        "mom",
        "moment",
        "monitor",
        "monkey",
        "monster",
        "month",
        "moon",
        "moral",
        "more",
        "morning",
        "mosquito",
        "mother",
        "motion",
        "motor",
        "mountain",
        "mouse",
        "move",
        "movie",
        "much",
        "muffin",
        "mule",
        "multiply",
        "muscle",
        "museum",
        "mushroom",
        "music",
        "must",
        "mutual",
        "myself",
        "mystery",
        "myth",
        "naive",
        "name",
        "napkin",
        "narrow",
        "nasty",
        "nation",
        "nature",
        "near",
        "neck",
        "need",
        "negative",
        "neglect",
        "neither",
        "nephew",
        "nerve",
        "nest",
        "net",
        "network",
        "neutral",
        "never",
        "news",
        "next",
        "nice",
        "night",
        "noble",
        "noise",
        "nominee",
        "noodle",
        "normal",
        "north",
        "nose",
        "notable",
        "note",
        "nothing",
        "notice",
        "novel",
        "now",
        "nuclear",
        "number",
        "nurse",
        "nut",
        "oak",
        "obey",
        "object",
        "oblige",
        "obscure",
        "observe",
        "obtain",
        "obvious",
        "occur",
        "ocean",
        "october",
        "odor",
        "off",
        "offer",
        "office",
        "often",
        "oil",
        "okay",
        "old",
        "olive",
        "olympic",
        "omit",
        "once",
        "one",
        "onion",
        "online",
        "only",
        "open",
        "opera",
        "opinion",
        "oppose",
        "option",
        "orange",
        "orbit",
        "orchard",
        "order",
        "ordinary",
        "organ",
        "orient",
        "original",
        "orphan",
        "ostrich",
        "other",
        "outdoor",
        "outer",
        "output",
        "outside",
        "oval",
        "oven",
        "over",
        "own",
        "owner",
        "oxygen",
        "oyster",
        "ozone",
        "pact",
        "paddle",
        "page",
        "pair",
        "palace",
        "palm",
        "panda",
        "panel",
        "panic",
        "panther",
        "paper",
        "parade",
        "parent",
        "park",
        "parrot",
        "party",
        "pass",
        "patch",
        "path",
        "patient",
        "patrol",
        "pattern",
        "pause",
        "pave",
        "payment",
        "peace",
        "peanut",
        "pear",
        "peasant",
        "pelican",
        "pen",
        "penalty",
        "pencil",
        "people",
        "pepper",
        "perfect",
        "permit",
        "person",
        "pet",
        "phone",
        "photo",
        "phrase",
        "physical",
        "piano",
        "picnic",
        "picture",
        "piece",
        "pig",
        "pigeon",
        "pill",
        "pilot",
        "pink",
        "pioneer",
        "pipe",
        "pistol",
        "pitch",
        "pizza",
        "place",
        "planet",
        "plastic",
        "plate",
        "play",
        "please",
        "pledge",
        "pluck",
        "plug",
        "plunge",
        "poem",
        "poet",
        "point",
        "polar",
        "pole",
        "police",
        "pond",
        "pony",
        "pool",
        "popular",
        "portion",
        "position",
        "possible",
        "post",
        "potato",
        "pottery",
        "poverty",
        "powder",
        "power",
        "practice",
        "praise",
        "predict",
        "prefer",
        "prepare",
        "present",
        "pretty",
        "prevent",
        "price",
        "pride",
        "primary",
        "print",
        "priority",
        "prison",
        "private",
        "prize",
        "problem",
        "process",
        "produce",
        "profit",
        "program",
        "project",
        "promote",
        "proof",
        "property",
        "prosper",
        "protect",
        "proud",
        "provide",
        "public",
        "pudding",
        "pull",
        "pulp",
        "pulse",
        "pumpkin",
        "punch",
        "pupil",
        "puppy",
        "purchase",
        "purity",
        "purpose",
        "purse",
        "push",
        "put",
        "puzzle",
        "pyramid",
        "quality",
        "quantum",
        "quarter",
        "question",
        "quick",
        "quit",
        "quiz",
        "quote",
        "rabbit",
        "raccoon",
        "race",
        "rack",
        "radar",
        "radio",
        "rail",
        "rain",
        "raise",
        "rally",
        "ramp",
        "ranch",
        "random",
        "range",
        "rapid",
        "rare",
        "rate",
        "rather",
        "raven",
        "raw",
        "razor",
        "ready",
        "real",
        "reason",
        "rebel",
        "rebuild",
        "recall",
        "receive",
        "recipe",
        "record",
        "recycle",
        "reduce",
        "reflect",
        "reform",
        "refuse",
        "region",
        "regret",
        "regular",
        "reject",
        "relax",
        "release",
        "relief",
        "rely",
        "remain",
        "remember",
        "remind",
        "remove",
        "render",
        "renew",
        "rent",
        "reopen",
        "repair",
        "repeat",
        "replace",
        "report",
        "require",
        "rescue",
        "resemble",
        "resist",
        "resource",
        "response",
        "result",
        "retire",
        "retreat",
        "return",
        "reunion",
        "reveal",
        "review",
        "reward",
        "rhythm",
        "rib",
        "ribbon",
        "rice",
        "rich",
        "ride",
        "ridge",
        "rifle",
        "right",
        "rigid",
        "ring",
        "riot",
        "ripple",
        "risk",
        "ritual",
        "rival",
        "river",
        "road",
        "roast",
        "robot",
        "robust",
        "rocket",
        "romance",
        "roof",
        "rookie",
        "room",
        "rose",
        "rotate",
        "rough",
        "round",
        "route",
        "royal",
        "rubber",
        "rude",
        "rug",
        "rule",
        "run",
        "runway",
        "rural",
        "sad",
        "saddle",
        "sadness",
        "safe",
        "sail",
        "salad",
        "salmon",
        "salon",
        "salt",
        "salute",
        "same",
        "sample",
        "sand",
        "satisfy",
        "satoshi",
        "sauce",
        "sausage",
        "save",
        "say",
        "scale",
        "scan",
        "scare",
        "scatter",
        "scene",
        "scheme",
        "school",
        "science",
        "scissors",
        "scorpion",
        "scout",
        "scrap",
        "screen",
        "script",
        "scrub",
        "sea",
        "search",
        "season",
        "seat",
        "second",
        "secret",
        "section",
        "security",
        "seed",
        "seek",
        "segment",
        "select",
        "sell",
        "seminar",
        "senior",
        "sense",
        "sentence",
        "series",
        "service",
        "session",
        "settle",
        "setup",
        "seven",
        "shadow",
        "shaft",
        "shallow",
        "share",
        "shed",
        "shell",
        "sheriff",
        "shield",
        "shift",
        "shine",
        "ship",
        "shiver",
        "shock",
        "shoe",
        "shoot",
        "shop",
        "short",
        "shoulder",
        "shove",
        "shrimp",
        "shrug",
        "shuffle",
        "shy",
        "sibling",
        "sick",
        "side",
        "siege",
        "sight",
        "sign",
        "silent",
        "silk",
        "silly",
        "silver",
        "similar",
        "simple",
        "since",
        "sing",
        "siren",
        "sister",
        "situate",
        "six",
        "size",
        "skate",
        "sketch",
        "ski",
        "skill",
        "skin",
        "skirt",
        "skull",
        "slab",
        "slam",
        "sleep",
        "slender",
        "slice",
        "slide",
        "slight",
        "slim",
        "slogan",
        "slot",
        "slow",
        "slush",
        "small",
        "smart",
        "smile",
        "smoke",
        "smooth",
        "snack",
        "snake",
        "snap",
        "sniff",
        "snow",
        "soap",
        "soccer",
        "social",
        "sock",
        "soda",
        "soft",
        "solar",
        "soldier",
        "solid",
        "solution",
        "solve",
        "someone",
        "song",
        "soon",
        "sorry",
        "sort",
        "soul",
        "sound",
        "soup",
        "source",
        "south",
        "space",
        "spare",
        "spatial",
        "spawn",
        "speak",
        "special",
        "speed",
        "spell",
        "spend",
        "sphere",
        "spice",
        "spider",
        "spike",
        "spin",
        "spirit",
        "split",
        "spoil",
        "sponsor",
        "spoon",
        "sport",
        "spot",
        "spray",
        "spread",
        "spring",
        "spy",
        "square",
        "squeeze",
        "squirrel",
        "stable",
        "stadium",
        "staff",
        "stage",
        "stairs",
        "stamp",
        "stand",
        "start",
        "state",
        "stay",
        "steak",
        "steel",
        "stem",
        "step",
        "stereo",
        "stick",
        "still",
        "sting",
        "stock",
        "stomach",
        "stone",
        "stool",
        "story",
        "stove",
        "strategy",
        "street",
        "strike",
        "strong",
        "struggle",
        "student",
        "stuff",
        "stumble",
        "style",
        "subject",
        "submit",
        "subway",
        "success",
        "such",
        "sudden",
        "suffer",
        "sugar",
        "suggest",
        "suit",
        "summer",
        "sun",
        "sunny",
        "sunset",
        "super",
        "supply",
        "supreme",
        "sure",
        "surface",
        "surge",
        "surprise",
        "surround",
        "survey",
        "suspect",
        "sustain",
        "swallow",
        "swamp",
        "swap",
        "swarm",
        "swear",
        "sweet",
        "swift",
        "swim",
        "swing",
        "switch",
        "sword",
        "symbol",
        "symptom",
        "syrup",
        "system",
        "table",
        "tackle",
        "tag",
        "tail",
        "talent",
        "talk",
        "tank",
        "tape",
        "target",
        "task",
        "taste",
        "tattoo",
        "taxi",
        "teach",
        "team",
        "tell",
        "ten",
        "tenant",
        "tennis",
        "tent",
        "term",
        "test",
        "text",
        "thank",
        "that",
        "theme",
        "then",
        "theory",
        "there",
        "they",
        "thing",
        "this",
        "thought",
        "three",
        "thrive",
        "throw",
        "thumb",
        "thunder",
        "ticket",
        "tide",
        "tiger",
        "tilt",
        "timber",
        "time",
        "tiny",
        "tip",
        "tired",
        "tissue",
        "title",
        "toast",
        "tobacco",
        "today",
        "toddler",
        "toe",
        "together",
        "toilet",
        "token",
        "tomato",
        "tomorrow",
        "tone",
        "tongue",
        "tonight",
        "tool",
        "tooth",
        "top",
        "topic",
        "topple",
        "torch",
        "tornado",
        "tortoise",
        "toss",
        "total",
        "tourist",
        "toward",
        "tower",
        "town",
        "toy",
        "track",
        "trade",
        "traffic",
        "tragic",
        "train",
        "transfer",
        "trap",
        "trash",
        "travel",
        "tray",
        "treat",
        "tree",
        "trend",
        "trial",
        "tribe",
        "trick",
        "trigger",
        "trim",
        "trip",
        "trophy",
        "trouble",
        "truck",
        "true",
        "truly",
        "trumpet",
        "trust",
        "truth",
        "try",
        "tube",
        "tuition",
        "tumble",
        "tuna",
        "tunnel",
        "turkey",
        "turn",
        "turtle",
        "twelve",
        "twenty",
        "twice",
        "twin",
        "twist",
        "two",
        "type",
        "typical",
        "ugly",
        "umbrella",
        "unable",
        "unaware",
        "uncle",
        "uncover",
        "under",
        "undo",
        "unfair",
        "unfold",
        "unhappy",
        "uniform",
        "unique",
        "unit",
        "universe",
        "unknown",
        "unlock",
        "until",
        "unusual",
        "unveil",
        "update",
        "upgrade",
        "uphold",
        "upon",
        "upper",
        "upset",
        "urban",
        "urge",
        "usage",
        "use",
        "used",
        "useful",
        "useless",
        "usual",
        "utility",
        "vacant",
        "vacuum",
        "vague",
        "valid",
        "valley",
        "valve",
        "van",
        "vanish",
        "vapor",
        "various",
        "vast",
        "vault",
        "vehicle",
        "velvet",
        "vendor",
        "venture",
        "venue",
        "verb",
        "verify",
        "version",
        "very",
        "vessel",
        "veteran",
        "viable",
        "vibrant",
        "vicious",
        "victory",
        "video",
        "view",
        "village",
        "vintage",
        "violin",
        "virtual",
        "virus",
        "visa",
        "visit",
        "visual",
        "vital",
        "vivid",
        "vocal",
        "voice",
        "void",
        "volcano",
        "volume",
        "vote",
        "voyage",
        "wage",
        "wagon",
        "wait",
        "walk",
        "wall",
        "walnut",
        "want",
        "warfare",
        "warm",
        "warrior",
        "wash",
        "wasp",
        "waste",
        "water",
        "wave",
        "way",
        "wealth",
        "weapon",
        "wear",
        "weasel",
        "weather",
        "web",
        "wedding",
        "weekend",
        "weird",
        "welcome",
        "west",
        "wet",
        "whale",
        "what",
        "wheat",
        "wheel",
        "when",
        "where",
        "whip",
        "whisper",
        "wide",
        "width",
        "wife",
        "wild",
        "will",
        "win",
        "window",
        "wine",
        "wing",
        "wink",
        "winner",
        "winter",
        "wire",
        "wisdom",
        "wise",
        "wish",
        "witness",
        "wolf",
        "woman",
        "wonder",
        "wood",
        "wool",
        "word",
        "work",
        "world",
        "worry",
        "worth",
        "wrap",
        "wreck",
        "wrestle",
        "wrist",
        "write",
        "wrong",
        "yard",
        "year",
        "yellow",
        "you",
        "young",
        "youth",
        "zebra",
        "zero",
        "zone",
        "zoo"
      ];
      exports.wordlist = EN;
    }
  });

  // node_modules/ton-crypto/dist/mnemonic/mnemonic.js
  var require_mnemonic = __commonJS({
    "node_modules/ton-crypto/dist/mnemonic/mnemonic.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __importDefault2 = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mnemonicFromRandomSeed = exports.mnemonicIndexesToBytes = exports.bytesToMnemonics = exports.bytesToMnemonicIndexes = exports.mnemonicNew = exports.mnemonicValidate = exports.mnemonicToHDSeed = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicToSeed = exports.mnemonicToEntropy = void 0;
      var tweetnacl_1 = __importDefault2(require_nacl_fast());
      var getSecureRandom_1 = require_getSecureRandom2();
      var hmac_sha512_1 = require_hmac_sha5122();
      var pbkdf2_sha512_1 = require_pbkdf2_sha5122();
      var binary_1 = require_binary();
      var wordlist_1 = require_wordlist2();
      var PBKDF_ITERATIONS = 1e5;
      async function isPasswordNeeded(mnemonicArray) {
        const passlessEntropy = await mnemonicToEntropy(mnemonicArray);
        return await isPasswordSeed(passlessEntropy) && !await isBasicSeed(passlessEntropy);
      }
      function normalizeMnemonic(src) {
        return src.map((v) => v.toLowerCase().trim());
      }
      async function isBasicSeed(entropy) {
        const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON seed version", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64);
        return seed[0] == 0;
      }
      async function isPasswordSeed(entropy) {
        const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON fast seed version", 1, 64);
        return seed[0] == 1;
      }
      async function mnemonicToEntropy(mnemonicArray, password) {
        return await (0, hmac_sha512_1.hmac_sha512)(mnemonicArray.join(" "), password && password.length > 0 ? password : "");
      }
      exports.mnemonicToEntropy = mnemonicToEntropy;
      async function mnemonicToSeed(mnemonicArray, seed, password) {
        const entropy = await mnemonicToEntropy(mnemonicArray, password);
        return await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, seed, PBKDF_ITERATIONS, 64);
      }
      exports.mnemonicToSeed = mnemonicToSeed;
      async function mnemonicToPrivateKey(mnemonicArray, password) {
        mnemonicArray = normalizeMnemonic(mnemonicArray);
        const seed = await mnemonicToSeed(mnemonicArray, "TON default seed", password);
        let keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seed.slice(0, 32));
        return {
          publicKey: Buffer2.from(keyPair.publicKey),
          secretKey: Buffer2.from(keyPair.secretKey)
        };
      }
      exports.mnemonicToPrivateKey = mnemonicToPrivateKey;
      async function mnemonicToWalletKey(mnemonicArray, password) {
        let seedPk = await mnemonicToPrivateKey(mnemonicArray, password);
        let seedSecret = seedPk.secretKey.slice(0, 32);
        const keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seedSecret);
        return {
          publicKey: Buffer2.from(keyPair.publicKey),
          secretKey: Buffer2.from(keyPair.secretKey)
        };
      }
      exports.mnemonicToWalletKey = mnemonicToWalletKey;
      async function mnemonicToHDSeed(mnemonicArray, password) {
        mnemonicArray = normalizeMnemonic(mnemonicArray);
        return await mnemonicToSeed(mnemonicArray, "TON HD Keys seed", password);
      }
      exports.mnemonicToHDSeed = mnemonicToHDSeed;
      async function mnemonicValidate(mnemonicArray, password) {
        mnemonicArray = normalizeMnemonic(mnemonicArray);
        for (let word of mnemonicArray) {
          if (wordlist_1.wordlist.indexOf(word) < 0) {
            return false;
          }
        }
        if (password && password.length > 0) {
          if (!await isPasswordNeeded(mnemonicArray)) {
            return false;
          }
        }
        return await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password));
      }
      exports.mnemonicValidate = mnemonicValidate;
      async function mnemonicNew(wordsCount = 24, password) {
        let mnemonicArray = [];
        while (true) {
          mnemonicArray = [];
          for (let i = 0; i < wordsCount; i++) {
            let ind = await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);
            mnemonicArray.push(wordlist_1.wordlist[ind]);
          }
          if (password && password.length > 0) {
            if (!await isPasswordNeeded(mnemonicArray)) {
              continue;
            }
          }
          if (!await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password))) {
            continue;
          }
          break;
        }
        return mnemonicArray;
      }
      exports.mnemonicNew = mnemonicNew;
      function bytesToMnemonicIndexes(src, wordsCount) {
        let bits = (0, binary_1.bytesToBits)(src);
        let indexes = [];
        for (let i = 0; i < wordsCount; i++) {
          let sl = bits.slice(i * 11, i * 11 + 11);
          indexes.push(parseInt(sl, 2));
        }
        return indexes;
      }
      exports.bytesToMnemonicIndexes = bytesToMnemonicIndexes;
      function bytesToMnemonics(src, wordsCount) {
        let mnemonics = bytesToMnemonicIndexes(src, wordsCount);
        let res = [];
        for (let m of mnemonics) {
          res.push(wordlist_1.wordlist[m]);
        }
        return res;
      }
      exports.bytesToMnemonics = bytesToMnemonics;
      function mnemonicIndexesToBytes(src) {
        let res = "";
        for (let s of src) {
          if (!Number.isSafeInteger(s)) {
            throw Error("Invalid input");
          }
          if (s < 0 || s >= 2028) {
            throw Error("Invalid input");
          }
          res += (0, binary_1.lpad)(s.toString(2), "0", 11);
        }
        while (res.length % 8 !== 0) {
          res = res + "0";
        }
        return (0, binary_1.bitsToBytes)(res);
      }
      exports.mnemonicIndexesToBytes = mnemonicIndexesToBytes;
      async function mnemonicFromRandomSeed(seed, wordsCount = 24, password) {
        const bytesLength = Math.ceil(wordsCount * 11 / 8);
        let currentSeed = seed;
        while (true) {
          let entropy = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(currentSeed, "TON mnemonic seed", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), bytesLength);
          let mnemonics = bytesToMnemonics(entropy, wordsCount);
          if (await mnemonicValidate(mnemonics, password)) {
            return mnemonics;
          }
          currentSeed = entropy;
        }
      }
      exports.mnemonicFromRandomSeed = mnemonicFromRandomSeed;
    }
  });

  // node_modules/ton-crypto/dist/primitives/nacl.js
  var require_nacl = __commonJS({
    "node_modules/ton-crypto/dist/primitives/nacl.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __importDefault2 = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.openBox = exports.sealBox = exports.signVerify = exports.sign = exports.keyPairFromSeed = exports.keyPairFromSecretKey = void 0;
      var tweetnacl_1 = __importDefault2(require_nacl_fast());
      function keyPairFromSecretKey(secretKey) {
        let res = tweetnacl_1.default.sign.keyPair.fromSecretKey(new Uint8Array(secretKey));
        return {
          publicKey: Buffer2.from(res.publicKey),
          secretKey: Buffer2.from(res.secretKey)
        };
      }
      exports.keyPairFromSecretKey = keyPairFromSecretKey;
      function keyPairFromSeed(secretKey) {
        let res = tweetnacl_1.default.sign.keyPair.fromSeed(new Uint8Array(secretKey));
        return {
          publicKey: Buffer2.from(res.publicKey),
          secretKey: Buffer2.from(res.secretKey)
        };
      }
      exports.keyPairFromSeed = keyPairFromSeed;
      function sign(data, secretKey) {
        return Buffer2.from(tweetnacl_1.default.sign.detached(new Uint8Array(data), new Uint8Array(secretKey)));
      }
      exports.sign = sign;
      function signVerify(data, signature, publicKey) {
        return tweetnacl_1.default.sign.detached.verify(new Uint8Array(data), new Uint8Array(signature), new Uint8Array(publicKey));
      }
      exports.signVerify = signVerify;
      function sealBox(data, nonce, key) {
        return Buffer2.from(tweetnacl_1.default.secretbox(data, nonce, key));
      }
      exports.sealBox = sealBox;
      function openBox(data, nonce, key) {
        let res = tweetnacl_1.default.secretbox.open(data, nonce, key);
        if (!res) {
          return null;
        }
        return Buffer2.from(res);
      }
      exports.openBox = openBox;
    }
  });

  // node_modules/ton-crypto/dist/hd/ed25519.js
  var require_ed25519 = __commonJS({
    "node_modules/ton-crypto/dist/hd/ed25519.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.deriveEd25519Path = exports.deriveED25519HardenedKey = exports.getED25519MasterKeyFromSeed = void 0;
      var hmac_sha512_1 = require_hmac_sha5122();
      var ED25519_CURVE = "ed25519 seed";
      var HARDENED_OFFSET = 2147483648;
      async function getED25519MasterKeyFromSeed(seed) {
        const I = await (0, hmac_sha512_1.hmac_sha512)(ED25519_CURVE, seed);
        const IL = I.slice(0, 32);
        const IR = I.slice(32);
        return {
          key: IL,
          chainCode: IR
        };
      }
      exports.getED25519MasterKeyFromSeed = getED25519MasterKeyFromSeed;
      async function deriveED25519HardenedKey(parent, index) {
        if (index >= HARDENED_OFFSET) {
          throw Error("Key index must be less than offset");
        }
        const indexBuffer = Buffer2.alloc(4);
        indexBuffer.writeUInt32BE(index + HARDENED_OFFSET, 0);
        const data = Buffer2.concat([Buffer2.alloc(1, 0), parent.key, indexBuffer]);
        const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
        const IL = I.slice(0, 32);
        const IR = I.slice(32);
        return {
          key: IL,
          chainCode: IR
        };
      }
      exports.deriveED25519HardenedKey = deriveED25519HardenedKey;
      async function deriveEd25519Path(seed, path) {
        let state = await getED25519MasterKeyFromSeed(seed);
        let remaining = [...path];
        while (remaining.length > 0) {
          let index = remaining[0];
          remaining = remaining.slice(1);
          state = await deriveED25519HardenedKey(state, index);
        }
        return state.key;
      }
      exports.deriveEd25519Path = deriveEd25519Path;
    }
  });

  // node_modules/ton-crypto/dist/hd/symmetric.js
  var require_symmetric = __commonJS({
    "node_modules/ton-crypto/dist/hd/symmetric.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.deriveSymmetricPath = exports.deriveSymmetricHardenedKey = exports.getSymmetricMasterKeyFromSeed = void 0;
      var hmac_sha512_1 = require_hmac_sha5122();
      var SYMMETRIC_SEED = "Symmetric key seed";
      async function getSymmetricMasterKeyFromSeed(seed) {
        const I = await (0, hmac_sha512_1.hmac_sha512)(SYMMETRIC_SEED, seed);
        const IL = I.slice(32);
        const IR = I.slice(0, 32);
        return {
          key: IL,
          chainCode: IR
        };
      }
      exports.getSymmetricMasterKeyFromSeed = getSymmetricMasterKeyFromSeed;
      async function deriveSymmetricHardenedKey(parent, offset) {
        const data = Buffer2.concat([Buffer2.alloc(1, 0), Buffer2.from(offset)]);
        const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
        const IL = I.slice(32);
        const IR = I.slice(0, 32);
        return {
          key: IL,
          chainCode: IR
        };
      }
      exports.deriveSymmetricHardenedKey = deriveSymmetricHardenedKey;
      async function deriveSymmetricPath(seed, path) {
        let state = await getSymmetricMasterKeyFromSeed(seed);
        let remaining = [...path];
        while (remaining.length > 0) {
          let index = remaining[0];
          remaining = remaining.slice(1);
          state = await deriveSymmetricHardenedKey(state, index);
        }
        return state.key;
      }
      exports.deriveSymmetricPath = deriveSymmetricPath;
    }
  });

  // node_modules/ton-crypto/dist/hd/mnemonics.js
  var require_mnemonics = __commonJS({
    "node_modules/ton-crypto/dist/hd/mnemonics.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.deriveMnemonicsPath = exports.deriveMnemonicHardenedKey = exports.getMnemonicsMasterKeyFromSeed = void 0;
      var mnemonic_1 = require_mnemonic();
      var hmac_sha512_1 = require_hmac_sha5122();
      var HARDENED_OFFSET = 2147483648;
      var MNEMONICS_SEED = "TON Mnemonics HD seed";
      async function getMnemonicsMasterKeyFromSeed(seed) {
        const I = await (0, hmac_sha512_1.hmac_sha512)(MNEMONICS_SEED, seed);
        const IL = I.slice(0, 32);
        const IR = I.slice(32);
        return {
          key: IL,
          chainCode: IR
        };
      }
      exports.getMnemonicsMasterKeyFromSeed = getMnemonicsMasterKeyFromSeed;
      async function deriveMnemonicHardenedKey(parent, index) {
        if (index >= HARDENED_OFFSET) {
          throw Error("Key index must be less than offset");
        }
        const indexBuffer = Buffer2.alloc(4);
        indexBuffer.writeUInt32BE(index + HARDENED_OFFSET, 0);
        const data = Buffer2.concat([Buffer2.alloc(1, 0), parent.key, indexBuffer]);
        const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
        const IL = I.slice(0, 32);
        const IR = I.slice(32);
        return {
          key: IL,
          chainCode: IR
        };
      }
      exports.deriveMnemonicHardenedKey = deriveMnemonicHardenedKey;
      async function deriveMnemonicsPath(seed, path, wordsCount = 24, password) {
        let state = await getMnemonicsMasterKeyFromSeed(seed);
        let remaining = [...path];
        while (remaining.length > 0) {
          let index = remaining[0];
          remaining = remaining.slice(1);
          state = await deriveMnemonicHardenedKey(state, index);
        }
        return await (0, mnemonic_1.mnemonicFromRandomSeed)(state.key, wordsCount, password);
      }
      exports.deriveMnemonicsPath = deriveMnemonicsPath;
    }
  });

  // node_modules/ton-crypto/dist/index.js
  var require_dist = __commonJS({
    "node_modules/ton-crypto/dist/index.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getMnemonicsMasterKeyFromSeed = exports.deriveMnemonicHardenedKey = exports.deriveMnemonicsPath = exports.deriveSymmetricPath = exports.deriveSymmetricHardenedKey = exports.getSymmetricMasterKeyFromSeed = exports.deriveEd25519Path = exports.deriveED25519HardenedKey = exports.getED25519MasterKeyFromSeed = exports.signVerify = exports.sign = exports.keyPairFromSecretKey = exports.keyPairFromSeed = exports.openBox = exports.sealBox = exports.mnemonicWordList = exports.mnemonicToHDSeed = exports.mnemonicToSeed = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicValidate = exports.mnemonicNew = exports.newSecurePassphrase = exports.newSecureWords = exports.getSecureRandomNumber = exports.getSecureRandomWords = exports.getSecureRandomBytes = exports.hmac_sha512 = exports.pbkdf2_sha512 = exports.sha512_sync = exports.sha512 = exports.sha256_sync = exports.sha256 = void 0;
      var sha256_1 = require_sha2562();
      Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
        return sha256_1.sha256;
      } });
      Object.defineProperty(exports, "sha256_sync", { enumerable: true, get: function() {
        return sha256_1.sha256_sync;
      } });
      var sha512_1 = require_sha5122();
      Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
        return sha512_1.sha512;
      } });
      Object.defineProperty(exports, "sha512_sync", { enumerable: true, get: function() {
        return sha512_1.sha512_sync;
      } });
      var pbkdf2_sha512_1 = require_pbkdf2_sha5122();
      Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
        return pbkdf2_sha512_1.pbkdf2_sha512;
      } });
      var hmac_sha512_1 = require_hmac_sha5122();
      Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
        return hmac_sha512_1.hmac_sha512;
      } });
      var getSecureRandom_1 = require_getSecureRandom2();
      Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
        return getSecureRandom_1.getSecureRandomBytes;
      } });
      Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
        return getSecureRandom_1.getSecureRandomWords;
      } });
      Object.defineProperty(exports, "getSecureRandomNumber", { enumerable: true, get: function() {
        return getSecureRandom_1.getSecureRandomNumber;
      } });
      var newSecureWords_1 = require_newSecureWords();
      Object.defineProperty(exports, "newSecureWords", { enumerable: true, get: function() {
        return newSecureWords_1.newSecureWords;
      } });
      var newSecurePassphrase_1 = require_newSecurePassphrase();
      Object.defineProperty(exports, "newSecurePassphrase", { enumerable: true, get: function() {
        return newSecurePassphrase_1.newSecurePassphrase;
      } });
      var mnemonic_1 = require_mnemonic();
      Object.defineProperty(exports, "mnemonicNew", { enumerable: true, get: function() {
        return mnemonic_1.mnemonicNew;
      } });
      Object.defineProperty(exports, "mnemonicValidate", { enumerable: true, get: function() {
        return mnemonic_1.mnemonicValidate;
      } });
      Object.defineProperty(exports, "mnemonicToPrivateKey", { enumerable: true, get: function() {
        return mnemonic_1.mnemonicToPrivateKey;
      } });
      Object.defineProperty(exports, "mnemonicToWalletKey", { enumerable: true, get: function() {
        return mnemonic_1.mnemonicToWalletKey;
      } });
      Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
        return mnemonic_1.mnemonicToSeed;
      } });
      Object.defineProperty(exports, "mnemonicToHDSeed", { enumerable: true, get: function() {
        return mnemonic_1.mnemonicToHDSeed;
      } });
      var wordlist_1 = require_wordlist2();
      Object.defineProperty(exports, "mnemonicWordList", { enumerable: true, get: function() {
        return wordlist_1.wordlist;
      } });
      var nacl_1 = require_nacl();
      Object.defineProperty(exports, "sealBox", { enumerable: true, get: function() {
        return nacl_1.sealBox;
      } });
      Object.defineProperty(exports, "openBox", { enumerable: true, get: function() {
        return nacl_1.openBox;
      } });
      var nacl_2 = require_nacl();
      Object.defineProperty(exports, "keyPairFromSeed", { enumerable: true, get: function() {
        return nacl_2.keyPairFromSeed;
      } });
      Object.defineProperty(exports, "keyPairFromSecretKey", { enumerable: true, get: function() {
        return nacl_2.keyPairFromSecretKey;
      } });
      Object.defineProperty(exports, "sign", { enumerable: true, get: function() {
        return nacl_2.sign;
      } });
      Object.defineProperty(exports, "signVerify", { enumerable: true, get: function() {
        return nacl_2.signVerify;
      } });
      var ed25519_1 = require_ed25519();
      Object.defineProperty(exports, "getED25519MasterKeyFromSeed", { enumerable: true, get: function() {
        return ed25519_1.getED25519MasterKeyFromSeed;
      } });
      Object.defineProperty(exports, "deriveED25519HardenedKey", { enumerable: true, get: function() {
        return ed25519_1.deriveED25519HardenedKey;
      } });
      Object.defineProperty(exports, "deriveEd25519Path", { enumerable: true, get: function() {
        return ed25519_1.deriveEd25519Path;
      } });
      var symmetric_1 = require_symmetric();
      Object.defineProperty(exports, "getSymmetricMasterKeyFromSeed", { enumerable: true, get: function() {
        return symmetric_1.getSymmetricMasterKeyFromSeed;
      } });
      Object.defineProperty(exports, "deriveSymmetricHardenedKey", { enumerable: true, get: function() {
        return symmetric_1.deriveSymmetricHardenedKey;
      } });
      Object.defineProperty(exports, "deriveSymmetricPath", { enumerable: true, get: function() {
        return symmetric_1.deriveSymmetricPath;
      } });
      var mnemonics_1 = require_mnemonics();
      Object.defineProperty(exports, "deriveMnemonicsPath", { enumerable: true, get: function() {
        return mnemonics_1.deriveMnemonicsPath;
      } });
      Object.defineProperty(exports, "deriveMnemonicHardenedKey", { enumerable: true, get: function() {
        return mnemonics_1.deriveMnemonicHardenedKey;
      } });
      Object.defineProperty(exports, "getMnemonicsMasterKeyFromSeed", { enumerable: true, get: function() {
        return mnemonics_1.getMnemonicsMasterKeyFromSeed;
      } });
    }
  });

  // node_modules/ton-core/dist/boc/cell/wonderCalculator.js
  var require_wonderCalculator = __commonJS({
    "node_modules/ton-core/dist/boc/cell/wonderCalculator.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.wonderCalculator = void 0;
      var BitString_1 = require_BitString();
      var CellType_1 = require_CellType();
      var LevelMask_1 = require_LevelMask();
      var exoticPruned_1 = require_exoticPruned();
      var exoticMerkleProof_1 = require_exoticMerkleProof();
      var descriptor_1 = require_descriptor();
      var ton_crypto_1 = require_dist();
      var exoticMerkleUpdate_1 = require_exoticMerkleUpdate();
      function wonderCalculator(type, bits, refs) {
        let levelMask;
        let pruned = null;
        if (type === CellType_1.CellType.Ordinary) {
          let mask = 0;
          for (let r of refs) {
            mask = mask | r.mask.value;
          }
          levelMask = new LevelMask_1.LevelMask(mask);
        } else if (type === CellType_1.CellType.PrunedBranch) {
          pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
          levelMask = new LevelMask_1.LevelMask(pruned.mask);
        } else if (type === CellType_1.CellType.MerkleProof) {
          let loaded = (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
          levelMask = new LevelMask_1.LevelMask(refs[0].mask.value >> 1);
        } else if (type === CellType_1.CellType.MerkleUpdate) {
          let loaded = (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
          levelMask = new LevelMask_1.LevelMask((refs[0].mask.value | refs[1].mask.value) >> 1);
        } else {
          throw new Error("Unsupported exotic type");
        }
        let depths = [];
        let hashes = [];
        let hashCount = type === CellType_1.CellType.PrunedBranch ? 1 : levelMask.hashCount;
        let totalHashCount = levelMask.hashCount;
        let hashIOffset = totalHashCount - hashCount;
        for (let levelI = 0, hashI = 0; levelI <= levelMask.level; levelI++) {
          if (!levelMask.isSignificant(levelI)) {
            continue;
          }
          if (hashI < hashIOffset) {
            hashI++;
            continue;
          }
          let currentBits;
          if (hashI === hashIOffset) {
            if (!(levelI === 0 || type === CellType_1.CellType.PrunedBranch)) {
              throw Error("Invalid");
            }
            currentBits = bits;
          } else {
            if (!(levelI !== 0 && type !== CellType_1.CellType.PrunedBranch)) {
              throw Error("Invalid: " + levelI + ", " + type);
            }
            currentBits = new BitString_1.BitString(hashes[hashI - hashIOffset - 1], 0, 256);
          }
          let currentDepth = 0;
          for (let c of refs) {
            let childDepth;
            if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
              childDepth = c.depth(levelI + 1);
            } else {
              childDepth = c.depth(levelI);
            }
            currentDepth = Math.max(currentDepth, childDepth);
          }
          if (refs.length > 0) {
            currentDepth++;
          }
          let repr = (0, descriptor_1.getRepr)(currentBits, refs, levelI, type);
          let hash = (0, ton_crypto_1.sha256_sync)(repr);
          let destI = hashI - hashIOffset;
          depths[destI] = currentDepth;
          hashes[destI] = hash;
          hashI++;
        }
        let resolvedHashes = [];
        let resolvedDepths = [];
        if (pruned) {
          for (let i = 0; i < 4; i++) {
            const { hashIndex } = levelMask.apply(i);
            const { hashIndex: thisHashIndex } = levelMask;
            if (hashIndex !== thisHashIndex) {
              resolvedHashes.push(pruned.pruned[hashIndex].hash);
              resolvedDepths.push(pruned.pruned[hashIndex].depth);
            } else {
              resolvedHashes.push(hashes[0]);
              resolvedDepths.push(depths[0]);
            }
          }
        } else {
          for (let i = 0; i < 4; i++) {
            resolvedHashes.push(hashes[levelMask.apply(i).hashIndex]);
            resolvedDepths.push(depths[levelMask.apply(i).hashIndex]);
          }
        }
        return {
          mask: levelMask,
          hashes: resolvedHashes,
          depths: resolvedDepths
        };
      }
      exports.wonderCalculator = wonderCalculator;
    }
  });

  // node_modules/ton-core/dist/boc/cell/utils/topologicalSort.js
  var require_topologicalSort = __commonJS({
    "node_modules/ton-core/dist/boc/cell/utils/topologicalSort.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.topologicalSort = void 0;
      function topologicalSort(src) {
        let pending = [src];
        let allCells = /* @__PURE__ */ new Map();
        let notPermCells = /* @__PURE__ */ new Set();
        let sorted = [];
        while (pending.length > 0) {
          const cells = [...pending];
          pending = [];
          for (let cell of cells) {
            const hash = cell.hash().toString("hex");
            if (allCells.has(hash)) {
              continue;
            }
            notPermCells.add(hash);
            allCells.set(hash, { cell, refs: cell.refs.map((v) => v.hash().toString("hex")) });
            for (let r of cell.refs) {
              pending.push(r);
            }
          }
        }
        let tempMark = /* @__PURE__ */ new Set();
        function visit(hash) {
          if (!notPermCells.has(hash)) {
            return;
          }
          if (tempMark.has(hash)) {
            throw Error("Not a DAG");
          }
          tempMark.add(hash);
          for (let c of allCells.get(hash).refs) {
            visit(c);
          }
          sorted.unshift(hash);
          tempMark.delete(hash);
          notPermCells.delete(hash);
        }
        while (notPermCells.size > 0) {
          const id = Array.from(notPermCells)[0];
          visit(id);
        }
        let indexes = /* @__PURE__ */ new Map();
        for (let i = 0; i < sorted.length; i++) {
          indexes.set(sorted[i], i);
        }
        let result = [];
        for (let ent of sorted) {
          const rrr = allCells.get(ent);
          result.push({ cell: rrr.cell, refs: rrr.refs.map((v) => indexes.get(v)) });
        }
        return result;
      }
      exports.topologicalSort = topologicalSort;
    }
  });

  // node_modules/ton-core/dist/utils/bitsForNumber.js
  var require_bitsForNumber = __commonJS({
    "node_modules/ton-core/dist/utils/bitsForNumber.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bitsForNumber = void 0;
      function bitsForNumber(src, mode) {
        let v = BigInt(src);
        if (mode === "int") {
          if (v === 0n || v === -1n) {
            return 1;
          }
          let v2 = v > 0 ? v : -v;
          return v2.toString(2).length + 1;
        } else if (mode === "uint") {
          if (v < 0) {
            throw Error(`value is negative. Got ${src}`);
          }
          return v.toString(2).length;
        } else {
          throw Error(`invalid mode. Got ${mode}`);
        }
      }
      exports.bitsForNumber = bitsForNumber;
    }
  });

  // node_modules/ton-core/dist/utils/crc32c.js
  var require_crc32c = __commonJS({
    "node_modules/ton-core/dist/utils/crc32c.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crc32c = void 0;
      var POLY = 2197175160;
      function crc32c(source) {
        let crc = 0 ^ 4294967295;
        for (let n = 0; n < source.length; n++) {
          crc ^= source[n];
          crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
          crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
          crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
          crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
          crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
          crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
          crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
          crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        }
        crc = crc ^ 4294967295;
        let res = Buffer2.alloc(4);
        res.writeInt32LE(crc);
        return res;
      }
      exports.crc32c = crc32c;
    }
  });

  // node_modules/ton-core/dist/boc/cell/serialization.js
  var require_serialization = __commonJS({
    "node_modules/ton-core/dist/boc/cell/serialization.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.serializeBoc = exports.deserializeBoc = exports.parseBoc = void 0;
      var BitReader_1 = require_BitReader();
      var BitString_1 = require_BitString();
      var Cell_1 = require_Cell();
      var topologicalSort_1 = require_topologicalSort();
      var bitsForNumber_1 = require_bitsForNumber();
      var BitBuilder_1 = require_BitBuilder();
      var descriptor_1 = require_descriptor();
      var paddedBits_1 = require_paddedBits();
      var crc32c_1 = require_crc32c();
      function readCell(reader, sizeBytes) {
        const d1 = reader.loadUint(8);
        const refsCount = d1 % 8;
        const exotic = !!(d1 & 8);
        const d2 = reader.loadUint(8);
        const dataBytesize = Math.ceil(d2 / 2);
        const paddingAdded = !!(d2 % 2);
        let bits = BitString_1.BitString.EMPTY;
        if (dataBytesize > 0) {
          if (paddingAdded) {
            bits = reader.loadPaddedBits(dataBytesize * 8);
          } else {
            bits = reader.loadBits(dataBytesize * 8);
          }
        }
        let refs = [];
        for (let i = 0; i < refsCount; i++) {
          refs.push(reader.loadUint(sizeBytes * 8));
        }
        return {
          bits,
          refs,
          exotic
        };
      }
      function calcCellSize(cell, sizeBytes) {
        return 2 + Math.ceil(cell.bits.length / 8) + cell.refs.length * sizeBytes;
      }
      function parseBoc(src) {
        let reader = new BitReader_1.BitReader(new BitString_1.BitString(src, 0, src.length * 8));
        let magic = reader.loadUint(32);
        if (magic === 1761568243) {
          let size = reader.loadUint(8);
          let offBytes = reader.loadUint(8);
          let cells = reader.loadUint(size * 8);
          let roots = reader.loadUint(size * 8);
          let absent = reader.loadUint(size * 8);
          let totalCellSize = reader.loadUint(offBytes * 8);
          let index = reader.loadBuffer(cells * offBytes);
          let cellData = reader.loadBuffer(totalCellSize);
          return {
            size,
            offBytes,
            cells,
            roots,
            absent,
            totalCellSize,
            index,
            cellData,
            root: [0]
          };
        } else if (magic === 2898503464) {
          let size = reader.loadUint(8);
          let offBytes = reader.loadUint(8);
          let cells = reader.loadUint(size * 8);
          let roots = reader.loadUint(size * 8);
          let absent = reader.loadUint(size * 8);
          let totalCellSize = reader.loadUint(offBytes * 8);
          let index = reader.loadBuffer(cells * offBytes);
          let cellData = reader.loadBuffer(totalCellSize);
          let crc32 = reader.loadBuffer(4);
          if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
            throw Error("Invalid CRC32C");
          }
          return {
            size,
            offBytes,
            cells,
            roots,
            absent,
            totalCellSize,
            index,
            cellData,
            root: [0]
          };
        } else if (magic === 3052313714) {
          let hasIdx = reader.loadUint(1);
          let hasCrc32c = reader.loadUint(1);
          let hasCacheBits = reader.loadUint(1);
          let flags = reader.loadUint(2);
          let size = reader.loadUint(3);
          let offBytes = reader.loadUint(8);
          let cells = reader.loadUint(size * 8);
          let roots = reader.loadUint(size * 8);
          let absent = reader.loadUint(size * 8);
          let totalCellSize = reader.loadUint(offBytes * 8);
          let root = [];
          for (let i = 0; i < roots; i++) {
            root.push(reader.loadUint(size * 8));
          }
          let index = null;
          if (hasIdx) {
            index = reader.loadBuffer(cells * offBytes);
          }
          let cellData = reader.loadBuffer(totalCellSize);
          if (hasCrc32c) {
            let crc32 = reader.loadBuffer(4);
            if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
              throw Error("Invalid CRC32C");
            }
          }
          return {
            size,
            offBytes,
            cells,
            roots,
            absent,
            totalCellSize,
            index,
            cellData,
            root
          };
        } else {
          throw Error("Invalid magic");
        }
      }
      exports.parseBoc = parseBoc;
      function deserializeBoc(src) {
        let boc = parseBoc(src);
        let reader = new BitReader_1.BitReader(new BitString_1.BitString(boc.cellData, 0, boc.cellData.length * 8));
        let cells = [];
        for (let i = 0; i < boc.cells; i++) {
          let cll = readCell(reader, boc.size);
          cells.push({ ...cll, result: null });
        }
        for (let i = cells.length - 1; i >= 0; i--) {
          if (cells[i].result) {
            throw Error("Impossible");
          }
          let refs = [];
          for (let r of cells[i].refs) {
            if (!cells[r].result) {
              throw Error("Invalid BOC file");
            }
            refs.push(cells[r].result);
          }
          cells[i].result = new Cell_1.Cell({ bits: cells[i].bits, refs, exotic: cells[i].exotic });
        }
        let roots = [];
        for (let i = 0; i < boc.root.length; i++) {
          roots.push(cells[boc.root[i]].result);
        }
        return roots;
      }
      exports.deserializeBoc = deserializeBoc;
      function writeCellToBuilder(cell, refs, sizeBytes, to) {
        let d1 = (0, descriptor_1.getRefsDescriptor)(cell.refs, cell.level(), cell.type);
        let d2 = (0, descriptor_1.getBitsDescriptor)(cell.bits);
        to.writeUint(d1, 8);
        to.writeUint(d2, 8);
        to.writeBuffer((0, paddedBits_1.bitsToPaddedBuffer)(cell.bits));
        for (let r of refs) {
          to.writeUint(r, sizeBytes * 8);
        }
      }
      function serializeBoc(root, opts) {
        let allCells = (0, topologicalSort_1.topologicalSort)(root);
        let cellsNum = allCells.length;
        let has_idx = opts.idx;
        let has_crc32c = opts.crc32;
        let has_cache_bits = false;
        let flags = 0;
        let sizeBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(cellsNum, "uint") / 8), 1);
        let totalCellSize = 0;
        let index = [];
        for (let c of allCells) {
          let sz = calcCellSize(c.cell, sizeBytes);
          index.push(totalCellSize);
          totalCellSize += sz;
        }
        let offsetBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(totalCellSize, "uint") / 8), 1);
        let totalSize = (4 + // magic
        1 + // flags and s_bytes
        1 + // offset_bytes
        3 * sizeBytes + // cells_num, roots, complete
        offsetBytes + // full_size
        1 * sizeBytes + (has_idx ? cellsNum * offsetBytes : 0) + totalCellSize + (has_crc32c ? 4 : 0)) * 8;
        let builder = new BitBuilder_1.BitBuilder(totalSize);
        builder.writeUint(3052313714, 32);
        builder.writeBit(has_idx);
        builder.writeBit(has_crc32c);
        builder.writeBit(has_cache_bits);
        builder.writeUint(flags, 2);
        builder.writeUint(sizeBytes, 3);
        builder.writeUint(offsetBytes, 8);
        builder.writeUint(cellsNum, sizeBytes * 8);
        builder.writeUint(1, sizeBytes * 8);
        builder.writeUint(0, sizeBytes * 8);
        builder.writeUint(totalCellSize, offsetBytes * 8);
        builder.writeUint(0, sizeBytes * 8);
        if (has_idx) {
          for (let i = 0; i < cellsNum; i++) {
            builder.writeUint(index[i], offsetBytes * 8);
          }
        }
        for (let i = 0; i < cellsNum; i++) {
          writeCellToBuilder(allCells[i].cell, allCells[i].refs, sizeBytes, builder);
        }
        if (has_crc32c) {
          let crc32 = (0, crc32c_1.crc32c)(builder.buffer());
          builder.writeBuffer(crc32);
        }
        let res = builder.buffer();
        if (res.length !== totalSize / 8) {
          throw Error("Internal error");
        }
        return res;
      }
      exports.serializeBoc = serializeBoc;
    }
  });

  // node_modules/ton-core/dist/boc/Cell.js
  var require_Cell = __commonJS({
    "node_modules/ton-core/dist/boc/Cell.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __importDefault2 = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Cell = void 0;
      var symbol_inspect_1 = __importDefault2(require_symbol());
      var BitString_1 = require_BitString();
      var CellType_1 = require_CellType();
      var Slice_1 = require_Slice();
      var resolveExotic_1 = require_resolveExotic();
      var wonderCalculator_1 = require_wonderCalculator();
      var serialization_1 = require_serialization();
      var BitReader_1 = require_BitReader();
      var Builder_1 = require_Builder();
      var Cell2 = class {
        /**
         * Deserialize cells from BOC
         * @param src source buffer
         * @returns array of cells
         */
        static fromBoc(src) {
          return (0, serialization_1.deserializeBoc)(src);
        }
        /**
         * Helper class that deserializes a single cell from BOC in base64
         * @param src source string
         */
        static fromBase64(src) {
          let parsed = Cell2.fromBoc(Buffer2.from(src, "base64"));
          if (parsed.length !== 1) {
            throw new Error("Deserialized more than one cell");
          }
          return parsed[0];
        }
        constructor(opts) {
          this._hashes = [];
          this._depths = [];
          this.beginParse = (allowExotic = false) => {
            if (this.isExotic && !allowExotic) {
              throw new Error("Exotic cells cannot be parsed");
            }
            return new Slice_1.Slice(new BitReader_1.BitReader(this.bits), this.refs);
          };
          this.hash = (level = 3) => {
            return this._hashes[Math.min(this._hashes.length - 1, level)];
          };
          this.depth = (level = 3) => {
            return this._depths[Math.min(this._depths.length - 1, level)];
          };
          this.level = () => {
            return this.mask.level;
          };
          this.equals = (other) => {
            return this.hash().equals(other.hash());
          };
          this[_a] = () => this.toString();
          let bits = BitString_1.BitString.EMPTY;
          if (opts && opts.bits) {
            bits = opts.bits;
          }
          let refs = [];
          if (opts && opts.refs) {
            refs = [...opts.refs];
          }
          let hashes;
          let depths;
          let mask;
          let type = CellType_1.CellType.Ordinary;
          if (opts && opts.exotic) {
            let resolved = (0, resolveExotic_1.resolveExotic)(bits, refs);
            let wonders = (0, wonderCalculator_1.wonderCalculator)(resolved.type, bits, refs);
            mask = wonders.mask;
            depths = wonders.depths;
            hashes = wonders.hashes;
            type = resolved.type;
          } else {
            if (refs.length > 4) {
              throw new Error("Invalid number of references");
            }
            if (bits.length > 1023) {
              throw new Error(`Bits overflow: ${bits.length} > 1023`);
            }
            let wonders = (0, wonderCalculator_1.wonderCalculator)(CellType_1.CellType.Ordinary, bits, refs);
            mask = wonders.mask;
            depths = wonders.depths;
            hashes = wonders.hashes;
            type = CellType_1.CellType.Ordinary;
          }
          this.type = type;
          this.bits = bits;
          this.refs = refs;
          this.mask = mask;
          this._depths = depths;
          this._hashes = hashes;
          Object.freeze(this);
          Object.freeze(this.refs);
          Object.freeze(this.bits);
          Object.freeze(this.mask);
          Object.freeze(this._depths);
          Object.freeze(this._hashes);
        }
        /**
         * Check if cell is exotic
         */
        get isExotic() {
          return this.type !== CellType_1.CellType.Ordinary;
        }
        /**
         * Serializes cell to BOC
         * @param opts options
         */
        toBoc(opts) {
          let idx = opts && opts.idx !== null && opts.idx !== void 0 ? opts.idx : false;
          let crc32 = opts && opts.crc32 !== null && opts.crc32 !== void 0 ? opts.crc32 : true;
          return (0, serialization_1.serializeBoc)(this, { idx, crc32 });
        }
        /**
         * Format cell to string
         * @param indent indentation
         * @returns string representation
         */
        toString(indent) {
          let id = indent || "";
          let t = "x";
          if (this.isExotic) {
            if (this.type === CellType_1.CellType.MerkleProof) {
              t = "p";
            } else if (this.type === CellType_1.CellType.MerkleUpdate) {
              t = "u";
            } else if (this.type === CellType_1.CellType.PrunedBranch) {
              t = "p";
            }
          }
          let s = id + (this.isExotic ? t : "x") + "{" + this.bits.toString() + "}";
          for (let k in this.refs) {
            const i = this.refs[k];
            s += "\n" + i.toString(id + " ");
          }
          return s;
        }
        /**
         * Covnert cell to slice
         * @returns slice
         */
        asSlice() {
          return this.beginParse();
        }
        /**
         * Convert cell to a builder that has this cell stored
         * @returns builder
         */
        asBuilder() {
          return (0, Builder_1.beginCell)().storeSlice(this.asSlice());
        }
      };
      exports.Cell = Cell2;
      _a = symbol_inspect_1.default;
      Cell2.EMPTY = new Cell2();
    }
  });

  // node_modules/ton-core/dist/boc/Builder.js
  var require_Builder = __commonJS({
    "node_modules/ton-core/dist/boc/Builder.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Builder = exports.beginCell = void 0;
      var BitBuilder_1 = require_BitBuilder();
      var Cell_1 = require_Cell();
      var strings_1 = require_strings();
      function beginCell() {
        return new Builder();
      }
      exports.beginCell = beginCell;
      var Builder = class {
        constructor() {
          this._bits = new BitBuilder_1.BitBuilder();
          this._refs = [];
        }
        /**
         * Bits written so far
         */
        get bits() {
          return this._bits.length;
        }
        /**
         * References written so far
         */
        get refs() {
          return this._refs.length;
        }
        /**
         * Available bits
         */
        get availableBits() {
          return 1023 - this.bits;
        }
        /**
         * Available references
         */
        get availableRefs() {
          return 4 - this.refs;
        }
        /**
         * Write a single bit
         * @param value bit to write, true or positive number for 1, false or zero or negative for 0
         * @returns this builder
         */
        storeBit(value) {
          this._bits.writeBit(value);
          return this;
        }
        /**
         * Write bits from BitString
         * @param src source bits
         * @returns this builder
         */
        storeBits(src) {
          this._bits.writeBits(src);
          return this;
        }
        /**
         * Store Buffer
         * @param src source buffer
         * @param bytes optional number of bytes to write
         * @returns this builder
         */
        storeBuffer(src, bytes) {
          if (bytes !== void 0 && bytes !== null) {
            if (src.length !== bytes) {
              throw Error(`Buffer length ${src.length} is not equal to ${bytes}`);
            }
          }
          this._bits.writeBuffer(src);
          return this;
        }
        /**
         * Store Maybe Buffer
         * @param src source buffer or null
         * @param bytes optional number of bytes to write
         * @returns this builder
         */
        storeMaybeBuffer(src, bytes) {
          if (src !== null) {
            this.storeBit(1);
            this.storeBuffer(src, bytes);
          } else {
            this.storeBit(0);
          }
          return this;
        }
        /**
         * Store uint value
         * @param value value as bigint or number
         * @param bits number of bits to write
         * @returns this builder
         */
        storeUint(value, bits) {
          this._bits.writeUint(value, bits);
          return this;
        }
        /**
         * Store maybe uint value
         * @param value value as bigint or number, null or undefined
         * @param bits number of bits to write
         * @returns this builder
         */
        storeMaybeUint(value, bits) {
          if (value !== null && value !== void 0) {
            this.storeBit(1);
            this.storeUint(value, bits);
          } else {
            this.storeBit(0);
          }
          return this;
        }
        /**
         * Store int value
         * @param value value as bigint or number
         * @param bits number of bits to write
         * @returns this builder
         */
        storeInt(value, bits) {
          this._bits.writeInt(value, bits);
          return this;
        }
        /**
         * Store maybe int value
         * @param value value as bigint or number, null or undefined
         * @param bits number of bits to write
         * @returns this builder
         */
        storeMaybeInt(value, bits) {
          if (value !== null && value !== void 0) {
            this.storeBit(1);
            this.storeInt(value, bits);
          } else {
            this.storeBit(0);
          }
          return this;
        }
        /**
         * Store varuint value
         * @param value value as bigint or number
         * @param bits number of bits to write to header
         * @returns this builder
         */
        storeVarUint(value, bits) {
          this._bits.writeVarUint(value, bits);
          return this;
        }
        /**
         * Store maybe varuint value
         * @param value value as bigint or number, null or undefined
         * @param bits number of bits to write to header
         * @returns this builder
         */
        storeMaybeVarUint(value, bits) {
          if (value !== null && value !== void 0) {
            this.storeBit(1);
            this.storeVarUint(value, bits);
          } else {
            this.storeBit(0);
          }
          return this;
        }
        /**
         * Store varint value
         * @param value value as bigint or number
         * @param bits number of bits to write to header
         * @returns this builder
         */
        storeVarInt(value, bits) {
          this._bits.writeVarInt(value, bits);
          return this;
        }
        /**
         * Store maybe varint value
         * @param value value as bigint or number, null or undefined
         * @param bits number of bits to write to header
         * @returns this builder
         */
        storeMaybeVarInt(value, bits) {
          if (value !== null && value !== void 0) {
            this.storeBit(1);
            this.storeVarInt(value, bits);
          } else {
            this.storeBit(0);
          }
          return this;
        }
        /**
         * Store coins value
         * @param amount amount of coins
         * @returns this builder
         */
        storeCoins(amount) {
          this._bits.writeCoins(amount);
          return this;
        }
        /**
         * Store maybe coins value
         * @param amount amount of coins, null or undefined
         * @returns this builder
         */
        storeMaybeCoins(amount) {
          if (amount !== null && amount !== void 0) {
            this.storeBit(1);
            this.storeCoins(amount);
          } else {
            this.storeBit(0);
          }
          return this;
        }
        /**
         * Store address
         * @param addres address to store
         * @returns this builder
         */
        storeAddress(address) {
          this._bits.writeAddress(address);
          return this;
        }
        /**
         * Store reference
         * @param cell cell or builder to store
         * @returns this builder
         */
        storeRef(cell) {
          if (this._refs.length >= 4) {
            throw new Error("Too many references");
          }
          if (cell instanceof Cell_1.Cell) {
            this._refs.push(cell);
          } else if (cell instanceof Builder) {
            this._refs.push(cell.endCell());
          } else {
            throw new Error("Invalid argument");
          }
          return this;
        }
        /**
         * Store reference if not null
         * @param cell cell or builder to store
         * @returns this builder
         */
        storeMaybeRef(cell) {
          if (cell) {
            this.storeBit(1);
            this.storeRef(cell);
          } else {
            this.storeBit(0);
          }
          return this;
        }
        /**
         * Store slice it in this builder
         * @param src source slice
         */
        storeSlice(src) {
          let c = src.clone();
          if (c.remainingBits > 0) {
            this.storeBits(c.loadBits(c.remainingBits));
          }
          while (c.remainingRefs > 0) {
            this.storeRef(c.loadRef());
          }
          return this;
        }
        /**
         * Store slice in this builder if not null
         * @param src source slice
         */
        storeMaybeSlice(src) {
          if (src) {
            this.storeBit(1);
            this.storeSlice(src);
          } else {
            this.storeBit(0);
          }
          return this;
        }
        /**
         * Store builder
         * @param src builder to store
         * @returns this builder
         */
        storeBuilder(src) {
          return this.storeSlice(src.endCell().beginParse());
        }
        /**
         * Store builder if not null
         * @param src builder to store
         * @returns this builder
         */
        storeMaybeBuilder(src) {
          if (src) {
            this.storeBit(1);
            this.storeBuilder(src);
          } else {
            this.storeBit(0);
          }
          return this;
        }
        /**
         * Store writer or builder
         * @param writer writer or builder to store
         * @returns this builder
         */
        storeWritable(writer) {
          if (typeof writer === "object") {
            writer.writeTo(this);
          } else {
            writer(this);
          }
          return this;
        }
        /**
         * Store writer or builder if not null
         * @param writer writer or builder to store
         * @returns this builder
         */
        storeMaybeWritable(writer) {
          if (writer) {
            this.storeBit(1);
            this.storeWritable(writer);
          } else {
            this.storeBit(0);
          }
          return this;
        }
        /**
         * Store object in this builder
         * @param writer Writable or writer functuin
         */
        store(writer) {
          this.storeWritable(writer);
          return this;
        }
        /**
         * Store string tail
         * @param src source string
         * @returns this builder
         */
        storeStringTail(src) {
          (0, strings_1.writeString)(src, this);
          return this;
        }
        /**
         * Store string tail
         * @param src source string
         * @returns this builder
         */
        storeMaybeStringTail(src) {
          if (src !== null && src !== void 0) {
            this.storeBit(1);
            (0, strings_1.writeString)(src, this);
          } else {
            this.storeBit(0);
          }
          return this;
        }
        /**
         * Store string tail in ref
         * @param src source string
         * @returns this builder
         */
        storeStringRefTail(src) {
          this.storeRef(beginCell().storeStringTail(src));
          return this;
        }
        /**
         * Store maybe string tail in ref
         * @param src source string
         * @returns this builder
         */
        storeMaybeStringRefTail(src) {
          if (src !== null && src !== void 0) {
            this.storeBit(1);
            this.storeStringRefTail(src);
          } else {
            this.storeBit(0);
          }
          return this;
        }
        /**
         * Store dictionary in this builder
         * @param dict dictionary to store
         * @returns this builder
         */
        storeDict(dict, key, value) {
          if (dict) {
            dict.store(this, key, value);
          } else {
            this.storeBit(0);
          }
          return this;
        }
        /**
         * Store dictionary in this builder directly
         * @param dict dictionary to store
         * @returns this builder
         */
        storeDictDirect(dict, key, value) {
          dict.storeDirect(this, key, value);
          return this;
        }
        /**
         * Complete cell
         * @returns cell
         */
        endCell() {
          return new Cell_1.Cell({
            bits: this._bits.build(),
            refs: this._refs
          });
        }
        /**
         * Convert to cell
         * @returns cell
         */
        asCell() {
          return this.endCell();
        }
        /**
         * Convert to slice
         * @returns slice
         */
        asSlice() {
          return this.endCell().beginParse();
        }
      };
      exports.Builder = Builder;
    }
  });

  // node_modules/ton-core/dist/types/SimpleLibrary.js
  var require_SimpleLibrary = __commonJS({
    "node_modules/ton-core/dist/types/SimpleLibrary.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SimpleLibraryValue = exports.storeSimpleLibrary = exports.loadSimpleLibrary = void 0;
      function loadSimpleLibrary(slice2) {
        return {
          public: slice2.loadBit(),
          root: slice2.loadRef()
        };
      }
      exports.loadSimpleLibrary = loadSimpleLibrary;
      function storeSimpleLibrary(src) {
        return (builder) => {
          builder.storeBit(src.public);
          builder.storeRef(src.root);
        };
      }
      exports.storeSimpleLibrary = storeSimpleLibrary;
      exports.SimpleLibraryValue = {
        serialize(src, builder) {
          storeSimpleLibrary(src)(builder);
        },
        parse(src) {
          return loadSimpleLibrary(src);
        }
      };
    }
  });

  // node_modules/ton-core/dist/types/TickTock.js
  var require_TickTock = __commonJS({
    "node_modules/ton-core/dist/types/TickTock.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeTickTock = exports.loadTickTock = void 0;
      function loadTickTock(slice2) {
        return {
          tick: slice2.loadBit(),
          tock: slice2.loadBit()
        };
      }
      exports.loadTickTock = loadTickTock;
      function storeTickTock(src) {
        return (builder) => {
          builder.storeBit(src.tick);
          builder.storeBit(src.tock);
        };
      }
      exports.storeTickTock = storeTickTock;
    }
  });

  // node_modules/ton-core/dist/types/StateInit.js
  var require_StateInit = __commonJS({
    "node_modules/ton-core/dist/types/StateInit.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeStateInit = exports.loadStateInit = void 0;
      var Dictionary_1 = require_Dictionary();
      var SimpleLibrary_1 = require_SimpleLibrary();
      var TickTock_1 = require_TickTock();
      function loadStateInit(slice2) {
        let splitDepth;
        if (slice2.loadBit()) {
          splitDepth = slice2.loadUint(5);
        }
        let special;
        if (slice2.loadBit()) {
          special = (0, TickTock_1.loadTickTock)(slice2);
        }
        let code = slice2.loadMaybeRef();
        let data = slice2.loadMaybeRef();
        let libraries = slice2.loadDict(Dictionary_1.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
        if (libraries.size === 0) {
          libraries = void 0;
        }
        return {
          splitDepth,
          special,
          code,
          data,
          libraries
        };
      }
      exports.loadStateInit = loadStateInit;
      function storeStateInit(src) {
        return (builder) => {
          if (src.splitDepth !== null && src.splitDepth !== void 0) {
            builder.storeBit(true);
            builder.storeUint(src.splitDepth, 5);
          } else {
            builder.storeBit(false);
          }
          if (src.special !== null && src.special !== void 0) {
            builder.storeBit(true);
            builder.store((0, TickTock_1.storeTickTock)(src.special));
          } else {
            builder.storeBit(false);
          }
          builder.storeMaybeRef(src.code);
          builder.storeMaybeRef(src.data);
          builder.storeDict(src.libraries);
        };
      }
      exports.storeStateInit = storeStateInit;
    }
  });

  // node_modules/ton-core/dist/address/contractAddress.js
  var require_contractAddress = __commonJS({
    "node_modules/ton-core/dist/address/contractAddress.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.contractAddress = void 0;
      var Builder_1 = require_Builder();
      var StateInit_1 = require_StateInit();
      var Address_1 = require_Address();
      function contractAddress(workchain, init2) {
        let hash = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(init2)).endCell().hash();
        return new Address_1.Address(workchain, hash);
      }
      exports.contractAddress = contractAddress;
    }
  });

  // node_modules/ton-core/dist/tuple/tuple.js
  var require_tuple = __commonJS({
    "node_modules/ton-core/dist/tuple/tuple.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseTuple = exports.serializeTuple = void 0;
      var Builder_1 = require_Builder();
      var INT64_MIN = BigInt("-9223372036854775808");
      var INT64_MAX = BigInt("9223372036854775807");
      function serializeTupleItem(src, builder) {
        if (src.type === "null") {
          builder.storeUint(0, 8);
        } else if (src.type === "int") {
          if (src.value <= INT64_MAX && src.value >= INT64_MIN) {
            builder.storeUint(1, 8);
            builder.storeInt(src.value, 64);
          } else {
            builder.storeUint(256, 15);
            builder.storeInt(src.value, 257);
          }
        } else if (src.type === "nan") {
          builder.storeInt(767, 16);
        } else if (src.type === "cell") {
          builder.storeUint(3, 8);
          builder.storeRef(src.cell);
        } else if (src.type === "slice") {
          builder.storeUint(4, 8);
          builder.storeUint(0, 10);
          builder.storeUint(src.cell.bits.length, 10);
          builder.storeUint(0, 3);
          builder.storeUint(src.cell.refs.length, 3);
          builder.storeRef(src.cell);
        } else if (src.type === "builder") {
          builder.storeUint(5, 8);
          builder.storeRef(src.cell);
        } else if (src.type === "tuple") {
          let head = null;
          let tail = null;
          for (let i = 0; i < src.items.length; i++) {
            let s = head;
            head = tail;
            tail = s;
            if (i > 1) {
              head = (0, Builder_1.beginCell)().storeRef(tail).storeRef(head).endCell();
            }
            let bc = (0, Builder_1.beginCell)();
            serializeTupleItem(src.items[i], bc);
            tail = bc.endCell();
          }
          builder.storeUint(7, 8);
          builder.storeUint(src.items.length, 16);
          if (head) {
            builder.storeRef(head);
          }
          if (tail) {
            builder.storeRef(tail);
          }
        } else {
          throw Error("Invalid value");
        }
      }
      function parseStackItem(cs) {
        let kind = cs.loadUint(8);
        if (kind === 0) {
          return { type: "null" };
        } else if (kind === 1) {
          return { type: "int", value: cs.loadIntBig(64) };
        } else if (kind === 2) {
          if (cs.loadUint(7) === 0) {
            return { type: "int", value: cs.loadIntBig(257) };
          } else {
            cs.loadBit();
            return { type: "nan" };
          }
        } else if (kind === 3) {
          return { type: "cell", cell: cs.loadRef() };
        } else if (kind === 4) {
          let startBits = cs.loadUint(10);
          let endBits = cs.loadUint(10);
          let startRefs = cs.loadUint(3);
          let endRefs = cs.loadUint(3);
          let rs = cs.loadRef().beginParse();
          rs.skip(startBits);
          let dt = rs.loadBits(endBits - startBits);
          let builder = (0, Builder_1.beginCell)().storeBits(dt);
          if (startRefs < endRefs) {
            for (let i = 0; i < startRefs; i++) {
              rs.loadRef();
            }
            for (let i = 0; i < endRefs - startRefs; i++) {
              builder.storeRef(rs.loadRef());
            }
          }
          return { type: "slice", cell: builder.endCell() };
        } else if (kind === 5) {
          return { type: "builder", cell: cs.loadRef() };
        } else if (kind === 7) {
          let length = cs.loadUint(16);
          let items = [];
          if (length > 1) {
            let head = cs.loadRef().beginParse();
            let tail = cs.loadRef().beginParse();
            items.unshift(parseStackItem(tail));
            for (let i = 0; i < length - 2; i++) {
              let ohead = head;
              head = ohead.loadRef().beginParse();
              tail = ohead.loadRef().beginParse();
              items.unshift(parseStackItem(tail));
            }
            items.unshift(parseStackItem(head));
          } else if (length === 1) {
            items.push(parseStackItem(cs.loadRef().beginParse()));
          }
          return { type: "tuple", items };
        } else {
          throw Error("Unsupported stack item");
        }
      }
      function serializeTupleTail(src, builder) {
        if (src.length > 0) {
          let tail = (0, Builder_1.beginCell)();
          serializeTupleTail(src.slice(0, src.length - 1), tail);
          builder.storeRef(tail.endCell());
          serializeTupleItem(src[src.length - 1], builder);
        }
      }
      function serializeTuple(src) {
        let builder = (0, Builder_1.beginCell)();
        builder.storeUint(src.length, 24);
        let r = [...src];
        serializeTupleTail(r, builder);
        return builder.endCell();
      }
      exports.serializeTuple = serializeTuple;
      function parseTuple(src) {
        let res = [];
        let cs = src.beginParse();
        let size = cs.loadUint(24);
        for (let i = 0; i < size; i++) {
          let next = cs.loadRef();
          res.unshift(parseStackItem(cs));
          cs = next.beginParse();
        }
        return res;
      }
      exports.parseTuple = parseTuple;
    }
  });

  // node_modules/ton-core/dist/tuple/reader.js
  var require_reader = __commonJS({
    "node_modules/ton-core/dist/tuple/reader.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TupleReader = void 0;
      var TupleReader2 = class {
        constructor(items) {
          this.items = [...items];
        }
        get remaining() {
          return this.items.length;
        }
        peek() {
          if (this.items.length === 0) {
            throw Error("EOF");
          }
          return this.items[0];
        }
        pop() {
          if (this.items.length === 0) {
            throw Error("EOF");
          }
          let res = this.items[0];
          this.items.splice(0, 1);
          return res;
        }
        readBigNumber() {
          let popped = this.pop();
          if (popped.type !== "int") {
            throw Error("Not a number");
          }
          return popped.value;
        }
        readBigNumberOpt() {
          let popped = this.pop();
          if (popped.type === "null") {
            return null;
          }
          if (popped.type !== "int") {
            throw Error("Not a number");
          }
          return popped.value;
        }
        readNumber() {
          return Number(this.readBigNumber());
        }
        readNumberOpt() {
          let r = this.readBigNumberOpt();
          if (r !== null) {
            return Number(r);
          } else {
            return null;
          }
        }
        readBoolean() {
          let res = this.readNumber();
          return res === 0 ? false : true;
        }
        readBooleanOpt() {
          let res = this.readNumberOpt();
          if (res !== null) {
            return res === 0 ? false : true;
          } else {
            return null;
          }
        }
        readAddress() {
          let r = this.readCell().beginParse().loadAddress();
          if (r !== null) {
            return r;
          } else {
            throw Error("Not an address");
          }
        }
        readAddressOpt() {
          let r = this.readCellOpt();
          if (r !== null) {
            return r.beginParse().loadMaybeAddress();
          } else {
            return null;
          }
        }
        readCell() {
          let popped = this.pop();
          if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
            throw Error("Not a cell: " + popped.type);
          }
          return popped.cell;
        }
        readCellOpt() {
          let popped = this.pop();
          if (popped.type === "null") {
            return null;
          }
          if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
            throw Error("Not a cell");
          }
          return popped.cell;
        }
        readTuple() {
          let popped = this.pop();
          if (popped.type !== "tuple") {
            throw Error("Not a number");
          }
          return new TupleReader2(popped.items);
        }
        readTupleOpt() {
          let popped = this.pop();
          if (popped.type === "null") {
            return null;
          }
          if (popped.type !== "tuple") {
            throw Error("Not a number");
          }
          return new TupleReader2(popped.items);
        }
        readBuffer() {
          let s = this.readCell().beginParse();
          if (s.remainingRefs !== 0) {
            throw Error("Not a buffer");
          }
          if (s.remainingBits % 8 !== 0) {
            throw Error("Not a buffer");
          }
          return s.loadBuffer(s.remainingBits / 8);
        }
        readBufferOpt() {
          let popped = this.peek();
          if (popped.type === "null") {
            return null;
          }
          let s = this.readCell().beginParse();
          if (s.remainingRefs !== 0) {
            throw Error("Not a buffer");
          }
          if (s.remainingBits % 8 !== 0) {
            throw Error("Not a buffer");
          }
          return s.loadBuffer(s.remainingBits / 8);
        }
        readString() {
          let s = this.readCell().beginParse();
          return s.loadStringTail();
        }
        readStringOpt() {
          let popped = this.peek();
          if (popped.type === "null") {
            return null;
          }
          let s = this.readCell().beginParse();
          return s.loadStringTail();
        }
      };
      exports.TupleReader = TupleReader2;
    }
  });

  // node_modules/ton-core/dist/tuple/builder.js
  var require_builder = __commonJS({
    "node_modules/ton-core/dist/tuple/builder.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TupleBuilder = void 0;
      var Builder_1 = require_Builder();
      var Cell_1 = require_Cell();
      var Slice_1 = require_Slice();
      var TupleBuilder = class {
        constructor() {
          this._tuple = [];
        }
        writeNumber(v) {
          if (v === null || v === void 0) {
            this._tuple.push({ type: "null" });
          } else {
            this._tuple.push({ type: "int", value: BigInt(v) });
          }
        }
        writeBoolean(v) {
          if (v === null || v === void 0) {
            this._tuple.push({ type: "null" });
          } else {
            this._tuple.push({ type: "int", value: v ? -1n : 0n });
          }
        }
        writeBuffer(v) {
          if (v === null || v === void 0) {
            this._tuple.push({ type: "null" });
          } else {
            this._tuple.push({ type: "slice", cell: (0, Builder_1.beginCell)().storeBuffer(v).endCell() });
          }
        }
        writeString(v) {
          if (v === null || v === void 0) {
            this._tuple.push({ type: "null" });
          } else {
            this._tuple.push({ type: "slice", cell: (0, Builder_1.beginCell)().storeStringTail(v).endCell() });
          }
        }
        writeCell(v) {
          if (v === null || v === void 0) {
            this._tuple.push({ type: "null" });
          } else {
            if (v instanceof Cell_1.Cell) {
              this._tuple.push({ type: "cell", cell: v });
            } else if (v instanceof Slice_1.Slice) {
              this._tuple.push({ type: "cell", cell: v.asCell() });
            }
          }
        }
        writeSlice(v) {
          if (v === null || v === void 0) {
            this._tuple.push({ type: "null" });
          } else {
            if (v instanceof Cell_1.Cell) {
              this._tuple.push({ type: "slice", cell: v });
            } else if (v instanceof Slice_1.Slice) {
              this._tuple.push({ type: "slice", cell: v.asCell() });
            }
          }
        }
        writeBuilder(v) {
          if (v === null || v === void 0) {
            this._tuple.push({ type: "null" });
          } else {
            if (v instanceof Cell_1.Cell) {
              this._tuple.push({ type: "builder", cell: v });
            } else if (v instanceof Slice_1.Slice) {
              this._tuple.push({ type: "builder", cell: v.asCell() });
            }
          }
        }
        writeTuple(v) {
          if (v === null || v === void 0) {
            this._tuple.push({ type: "null" });
          } else {
            this._tuple.push({ type: "tuple", items: v });
          }
        }
        writeAddress(v) {
          if (v === null || v === void 0) {
            this._tuple.push({ type: "null" });
          } else {
            this._tuple.push({ type: "slice", cell: (0, Builder_1.beginCell)().storeAddress(v).endCell() });
          }
        }
        build() {
          return [...this._tuple];
        }
      };
      exports.TupleBuilder = TupleBuilder;
    }
  });

  // node_modules/ton-core/dist/utils/convert.js
  var require_convert = __commonJS({
    "node_modules/ton-core/dist/utils/convert.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromNano = exports.toNano = void 0;
      function toNano(src) {
        if (typeof src === "bigint") {
          return src * 1000000000n;
        } else if (typeof src === "number") {
          return BigInt(src) * 1000000000n;
        } else {
          let neg = false;
          while (src.startsWith("-")) {
            neg = !neg;
            src = src.slice(1);
          }
          if (src === ".") {
            throw Error("Invalid number");
          }
          let parts = src.split(".");
          if (parts.length > 2) {
            throw Error("Invalid number");
          }
          let whole = parts[0];
          let frac = parts[1];
          if (!whole) {
            whole = "0";
          }
          if (!frac) {
            frac = "0";
          }
          if (frac.length > 9) {
            throw Error("Invalid number");
          }
          while (frac.length < 9) {
            frac += "0";
          }
          let r = BigInt(whole) * 1000000000n + BigInt(frac);
          if (neg) {
            r = -r;
          }
          return r;
        }
      }
      exports.toNano = toNano;
      function fromNano(src) {
        let v = BigInt(src);
        let neg = false;
        if (v < 0) {
          neg = true;
          v = -v;
        }
        let frac = v % 1000000000n;
        let facStr = frac.toString();
        while (facStr.length < 9) {
          facStr = "0" + facStr;
        }
        facStr = facStr.match(/^([0-9]*[1-9]|0)(0*)/)[1];
        let whole = v / 1000000000n;
        let wholeStr = whole.toString();
        let value = `${wholeStr}${facStr === "0" ? "" : `.${facStr}`}`;
        if (neg) {
          value = "-" + value;
        }
        return value;
      }
      exports.fromNano = fromNano;
    }
  });

  // node_modules/ton-core/dist/types/_helpers.js
  var require_helpers = __commonJS({
    "node_modules/ton-core/dist/types/_helpers.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.comment = exports.external = exports.internal = void 0;
      var Address_1 = require_Address();
      var Cell_1 = require_Cell();
      var Builder_1 = require_Builder();
      var convert_1 = require_convert();
      function internal(src) {
        let bounce = true;
        if (src.bounce !== null && src.bounce !== void 0) {
          bounce = src.bounce;
        }
        let to;
        if (typeof src.to === "string") {
          to = Address_1.Address.parse(src.to);
        } else if (Address_1.Address.isAddress(src.to)) {
          to = src.to;
        } else {
          throw new Error(`Invalid address ${src.to}`);
        }
        let value;
        if (typeof src.value === "string") {
          value = (0, convert_1.toNano)(src.value);
        } else {
          value = src.value;
        }
        let body = Cell_1.Cell.EMPTY;
        if (typeof src.body === "string") {
          body = (0, Builder_1.beginCell)().storeUint(0, 32).storeStringTail(src.body).endCell();
        } else if (src.body) {
          body = src.body;
        }
        return {
          info: {
            type: "internal",
            dest: to,
            value: { coins: value },
            bounce,
            ihrDisabled: true,
            bounced: false,
            ihrFee: 0n,
            forwardFee: 0n,
            createdAt: 0,
            createdLt: 0n
          },
          init: src.init ? { code: src.init.code, data: src.init.data } : void 0,
          body
        };
      }
      exports.internal = internal;
      function external(src) {
        let to;
        if (typeof src.to === "string") {
          to = Address_1.Address.parse(src.to);
        } else if (Address_1.Address.isAddress(src.to)) {
          to = src.to;
        } else {
          throw new Error(`Invalid address ${src.to}`);
        }
        return {
          info: {
            type: "external-in",
            dest: to,
            importFee: 0n
          },
          init: src.init ? { code: src.init.code, data: src.init.data } : void 0,
          body: src.body || Cell_1.Cell.EMPTY
        };
      }
      exports.external = external;
      function comment(src) {
        return (0, Builder_1.beginCell)().storeUint(0, 32).storeStringTail(src).endCell();
      }
      exports.comment = comment;
    }
  });

  // node_modules/ton-core/dist/types/AccountState.js
  var require_AccountState = __commonJS({
    "node_modules/ton-core/dist/types/AccountState.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeAccountState = exports.loadAccountState = void 0;
      var StateInit_1 = require_StateInit();
      function loadAccountState(cs) {
        if (cs.loadBit()) {
          return { type: "active", state: (0, StateInit_1.loadStateInit)(cs) };
        } else if (cs.loadBit()) {
          return { type: "frozen", stateHash: cs.loadUintBig(256) };
        } else {
          return { type: "uninit" };
        }
      }
      exports.loadAccountState = loadAccountState;
      function storeAccountState(src) {
        return (builder) => {
          if (src.type === "active") {
            builder.storeBit(true);
            builder.store((0, StateInit_1.storeStateInit)(src.state));
          } else if (src.type === "frozen") {
            builder.storeBit(false);
            builder.storeBit(true);
            builder.storeUint(src.stateHash, 256);
          } else if (src.type === "uninit") {
            builder.storeBit(false);
            builder.storeBit(false);
          }
        };
      }
      exports.storeAccountState = storeAccountState;
    }
  });

  // node_modules/ton-core/dist/types/CurrencyCollection.js
  var require_CurrencyCollection = __commonJS({
    "node_modules/ton-core/dist/types/CurrencyCollection.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeCurrencyCollection = exports.loadCurrencyCollection = void 0;
      var Dictionary_1 = require_Dictionary();
      function loadCurrencyCollection(slice2) {
        const coins = slice2.loadCoins();
        const other = slice2.loadDict(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(
          5
          /* log2(32) */
        ));
        if (other.size === 0) {
          return { coins };
        } else {
          return { other, coins };
        }
      }
      exports.loadCurrencyCollection = loadCurrencyCollection;
      function storeCurrencyCollection(collection) {
        return (builder) => {
          builder.storeCoins(collection.coins);
          if (collection.other) {
            builder.storeDict(collection.other);
          } else {
            builder.storeBit(0);
          }
        };
      }
      exports.storeCurrencyCollection = storeCurrencyCollection;
    }
  });

  // node_modules/ton-core/dist/types/AccountStorage.js
  var require_AccountStorage = __commonJS({
    "node_modules/ton-core/dist/types/AccountStorage.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeAccountStorage = exports.loadAccountStorage = void 0;
      var AccountState_1 = require_AccountState();
      var CurrencyCollection_1 = require_CurrencyCollection();
      function loadAccountStorage(slice2) {
        return {
          lastTransLt: slice2.loadUintBig(64),
          balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice2),
          state: (0, AccountState_1.loadAccountState)(slice2)
        };
      }
      exports.loadAccountStorage = loadAccountStorage;
      function storeAccountStorage(src) {
        return (builder) => {
          builder.storeUint(src.lastTransLt, 64);
          builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
          builder.store((0, AccountState_1.storeAccountState)(src.state));
        };
      }
      exports.storeAccountStorage = storeAccountStorage;
    }
  });

  // node_modules/ton-core/dist/types/StorageUsed.js
  var require_StorageUsed = __commonJS({
    "node_modules/ton-core/dist/types/StorageUsed.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeStorageUsed = exports.loadStorageUsed = void 0;
      function loadStorageUsed(cs) {
        return {
          cells: cs.loadVarUintBig(3),
          bits: cs.loadVarUintBig(3),
          publicCells: cs.loadVarUintBig(3)
        };
      }
      exports.loadStorageUsed = loadStorageUsed;
      function storeStorageUsed(src) {
        return (builder) => {
          builder.storeVarUint(src.cells, 3);
          builder.storeVarUint(src.bits, 3);
          builder.storeVarUint(src.publicCells, 3);
        };
      }
      exports.storeStorageUsed = storeStorageUsed;
    }
  });

  // node_modules/ton-core/dist/types/StorageInto.js
  var require_StorageInto = __commonJS({
    "node_modules/ton-core/dist/types/StorageInto.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeStorageInfo = exports.loadStorageInfo = void 0;
      var StorageUsed_1 = require_StorageUsed();
      function loadStorageInfo(slice2) {
        return {
          used: (0, StorageUsed_1.loadStorageUsed)(slice2),
          lastPaid: slice2.loadUint(32),
          duePayment: slice2.loadMaybeCoins()
        };
      }
      exports.loadStorageInfo = loadStorageInfo;
      function storeStorageInfo(src) {
        return (builder) => {
          builder.store((0, StorageUsed_1.storeStorageUsed)(src.used));
          builder.storeUint(src.lastPaid, 32);
          builder.storeMaybeCoins(src.duePayment);
        };
      }
      exports.storeStorageInfo = storeStorageInfo;
    }
  });

  // node_modules/ton-core/dist/types/Account.js
  var require_Account = __commonJS({
    "node_modules/ton-core/dist/types/Account.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeAccount = exports.loadAccount = void 0;
      var AccountStorage_1 = require_AccountStorage();
      var StorageInto_1 = require_StorageInto();
      function loadAccount(slice2) {
        return {
          addr: slice2.loadAddress(),
          storageStats: (0, StorageInto_1.loadStorageInfo)(slice2),
          storage: (0, AccountStorage_1.loadAccountStorage)(slice2)
        };
      }
      exports.loadAccount = loadAccount;
      function storeAccount(src) {
        return (builder) => {
          builder.storeAddress(src.addr);
          builder.store((0, StorageInto_1.storeStorageInfo)(src.storageStats));
          builder.store((0, AccountStorage_1.storeAccountStorage)(src.storage));
        };
      }
      exports.storeAccount = storeAccount;
    }
  });

  // node_modules/ton-core/dist/types/AccountStatus.js
  var require_AccountStatus = __commonJS({
    "node_modules/ton-core/dist/types/AccountStatus.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeAccountStatus = exports.loadAccountStatus = void 0;
      function loadAccountStatus(slice2) {
        const status = slice2.loadUint(2);
        if (status === 0) {
          return "uninitialized";
        }
        if (status === 1) {
          return "frozen";
        }
        if (status === 2) {
          return "active";
        }
        if (status === 3) {
          return "non-existing";
        }
        throw Error("Invalid data");
      }
      exports.loadAccountStatus = loadAccountStatus;
      function storeAccountStatus(src) {
        return (builder) => {
          if (src === "uninitialized") {
            builder.storeUint(0, 2);
          } else if (src === "frozen") {
            builder.storeUint(1, 2);
          } else if (src === "active") {
            builder.storeUint(2, 2);
          } else if (src === "non-existing") {
            builder.storeUint(3, 2);
          } else {
            throw Error("Invalid data");
          }
          return builder;
        };
      }
      exports.storeAccountStatus = storeAccountStatus;
    }
  });

  // node_modules/ton-core/dist/types/AccountStatusChange.js
  var require_AccountStatusChange = __commonJS({
    "node_modules/ton-core/dist/types/AccountStatusChange.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeAccountStatusChange = exports.loadAccountStatusChange = void 0;
      function loadAccountStatusChange(slice2) {
        if (!slice2.loadBit()) {
          return "unchanged";
        }
        if (slice2.loadBit()) {
          return "frozen";
        } else {
          return "deleted";
        }
      }
      exports.loadAccountStatusChange = loadAccountStatusChange;
      function storeAccountStatusChange(src) {
        return (builder) => {
          if (src == "unchanged") {
            builder.storeBit(0);
          } else if (src === "frozen") {
            builder.storeBit(1);
            builder.storeBit(0);
          } else if (src === "deleted") {
            builder.storeBit(1);
            builder.storeBit(1);
          } else {
            throw Error("Invalid account status change");
          }
        };
      }
      exports.storeAccountStatusChange = storeAccountStatusChange;
    }
  });

  // node_modules/ton-core/dist/types/CommonMessageInfo.js
  var require_CommonMessageInfo = __commonJS({
    "node_modules/ton-core/dist/types/CommonMessageInfo.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = void 0;
      var CurrencyCollection_1 = require_CurrencyCollection();
      function loadCommonMessageInfo(slice2) {
        if (!slice2.loadBit()) {
          const ihrDisabled = slice2.loadBit();
          const bounce = slice2.loadBit();
          const bounced = slice2.loadBit();
          const src2 = slice2.loadAddress();
          const dest2 = slice2.loadAddress();
          const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice2);
          const ihrFee = slice2.loadCoins();
          const forwardFee = slice2.loadCoins();
          const createdLt2 = slice2.loadUintBig(64);
          const createdAt2 = slice2.loadUint(32);
          return {
            type: "internal",
            ihrDisabled,
            bounce,
            bounced,
            src: src2,
            dest: dest2,
            value,
            ihrFee,
            forwardFee,
            createdLt: createdLt2,
            createdAt: createdAt2
          };
        }
        if (!slice2.loadBit()) {
          const src2 = slice2.loadMaybeExternalAddress();
          const dest2 = slice2.loadAddress();
          const importFee = slice2.loadCoins();
          return {
            type: "external-in",
            src: src2,
            dest: dest2,
            importFee
          };
        }
        const src = slice2.loadAddress();
        const dest = slice2.loadMaybeExternalAddress();
        const createdLt = slice2.loadUintBig(64);
        const createdAt = slice2.loadUint(32);
        return {
          type: "external-out",
          src,
          dest,
          createdLt,
          createdAt
        };
      }
      exports.loadCommonMessageInfo = loadCommonMessageInfo;
      function storeCommonMessageInfo(source) {
        return (builder) => {
          if (source.type === "internal") {
            builder.storeBit(0);
            builder.storeBit(source.ihrDisabled);
            builder.storeBit(source.bounce);
            builder.storeBit(source.bounced);
            builder.storeAddress(source.src);
            builder.storeAddress(source.dest);
            builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
            builder.storeCoins(source.ihrFee);
            builder.storeCoins(source.forwardFee);
            builder.storeUint(source.createdLt, 64);
            builder.storeUint(source.createdAt, 32);
          } else if (source.type === "external-in") {
            builder.storeBit(1);
            builder.storeBit(0);
            builder.storeAddress(source.src);
            builder.storeAddress(source.dest);
            builder.storeCoins(source.importFee);
          } else if (source.type === "external-out") {
            builder.storeBit(1);
            builder.storeBit(1);
            builder.storeAddress(source.src);
            builder.storeAddress(source.dest);
            builder.storeUint(source.createdLt, 64);
            builder.storeUint(source.createdAt, 32);
          } else {
            throw new Error("Unknown CommonMessageInfo type");
          }
        };
      }
      exports.storeCommonMessageInfo = storeCommonMessageInfo;
    }
  });

  // node_modules/ton-core/dist/types/CommonMessageInfoRelaxed.js
  var require_CommonMessageInfoRelaxed = __commonJS({
    "node_modules/ton-core/dist/types/CommonMessageInfoRelaxed.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = void 0;
      var CurrencyCollection_1 = require_CurrencyCollection();
      function loadCommonMessageInfoRelaxed(slice2) {
        if (!slice2.loadBit()) {
          const ihrDisabled = slice2.loadBit();
          const bounce = slice2.loadBit();
          const bounced = slice2.loadBit();
          const src2 = slice2.loadMaybeAddress();
          const dest2 = slice2.loadAddress();
          const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice2);
          const ihrFee = slice2.loadCoins();
          const forwardFee = slice2.loadCoins();
          const createdLt2 = slice2.loadUintBig(64);
          const createdAt2 = slice2.loadUint(32);
          return {
            type: "internal",
            ihrDisabled,
            bounce,
            bounced,
            src: src2,
            dest: dest2,
            value,
            ihrFee,
            forwardFee,
            createdLt: createdLt2,
            createdAt: createdAt2
          };
        }
        if (!slice2.loadBit()) {
          throw Error("External In message is not possible for CommonMessageInfoRelaxed");
        }
        const src = slice2.loadMaybeAddress();
        const dest = slice2.loadMaybeExternalAddress();
        const createdLt = slice2.loadUintBig(64);
        const createdAt = slice2.loadUint(32);
        return {
          type: "external-out",
          src,
          dest,
          createdLt,
          createdAt
        };
      }
      exports.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;
      function storeCommonMessageInfoRelaxed(source) {
        return (builder) => {
          if (source.type === "internal") {
            builder.storeBit(0);
            builder.storeBit(source.ihrDisabled);
            builder.storeBit(source.bounce);
            builder.storeBit(source.bounced);
            builder.storeAddress(source.src);
            builder.storeAddress(source.dest);
            builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
            builder.storeCoins(source.ihrFee);
            builder.storeCoins(source.forwardFee);
            builder.storeUint(source.createdLt, 64);
            builder.storeUint(source.createdAt, 32);
          } else if (source.type === "external-out") {
            builder.storeBit(1);
            builder.storeBit(1);
            builder.storeAddress(source.src);
            builder.storeAddress(source.dest);
            builder.storeUint(source.createdLt, 64);
            builder.storeUint(source.createdAt, 32);
          } else {
            throw new Error("Unknown CommonMessageInfo type");
          }
        };
      }
      exports.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
    }
  });

  // node_modules/ton-core/dist/types/ComputeSkipReason.js
  var require_ComputeSkipReason = __commonJS({
    "node_modules/ton-core/dist/types/ComputeSkipReason.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeComputeSkipReason = exports.loadComputeSkipReason = void 0;
      function loadComputeSkipReason(slice2) {
        let reason = slice2.loadUint(2);
        if (reason === 0) {
          return "no-state";
        } else if (reason === 1) {
          return "bad-state";
        } else if (reason === 2) {
          return "no-gas";
        }
        throw new Error(`Unknown ComputeSkipReason: ${reason}`);
      }
      exports.loadComputeSkipReason = loadComputeSkipReason;
      function storeComputeSkipReason(src) {
        return (builder) => {
          if (src === "no-state") {
            builder.storeUint(0, 2);
          } else if (src === "bad-state") {
            builder.storeUint(1, 2);
          } else if (src === "no-gas") {
            builder.storeUint(2, 2);
          } else {
            throw new Error(`Unknown ComputeSkipReason: ${src}`);
          }
        };
      }
      exports.storeComputeSkipReason = storeComputeSkipReason;
    }
  });

  // node_modules/ton-core/dist/types/DepthBalanceInfo.js
  var require_DepthBalanceInfo = __commonJS({
    "node_modules/ton-core/dist/types/DepthBalanceInfo.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = void 0;
      var CurrencyCollection_1 = require_CurrencyCollection();
      function loadDepthBalanceInfo(slice2) {
        let splitDepth = slice2.loadUint(5);
        return {
          splitDepth,
          balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice2)
        };
      }
      exports.loadDepthBalanceInfo = loadDepthBalanceInfo;
      function storeDepthBalanceInfo(src) {
        return (builder) => {
          builder.storeUint(src.splitDepth, 5);
          builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
        };
      }
      exports.storeDepthBalanceInfo = storeDepthBalanceInfo;
    }
  });

  // node_modules/ton-core/dist/types/HashUpdate.js
  var require_HashUpdate = __commonJS({
    "node_modules/ton-core/dist/types/HashUpdate.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeHashUpdate = exports.loadHashUpdate = void 0;
      function loadHashUpdate(slice2) {
        if (slice2.loadUint(8) !== 114) {
          throw Error("Invalid data");
        }
        const oldHash = slice2.loadBuffer(32);
        const newHash = slice2.loadBuffer(32);
        return { oldHash, newHash };
      }
      exports.loadHashUpdate = loadHashUpdate;
      function storeHashUpdate(src) {
        return (builder) => {
          builder.storeUint(114, 8);
          builder.storeBuffer(src.oldHash);
          builder.storeBuffer(src.newHash);
        };
      }
      exports.storeHashUpdate = storeHashUpdate;
    }
  });

  // node_modules/ton-core/dist/types/MasterchainStateExtra.js
  var require_MasterchainStateExtra = __commonJS({
    "node_modules/ton-core/dist/types/MasterchainStateExtra.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.loadMasterchainStateExtra = void 0;
      var Dictionary_1 = require_Dictionary();
      var CurrencyCollection_1 = require_CurrencyCollection();
      function loadMasterchainStateExtra(cs) {
        if (cs.loadUint(16) !== 52262) {
          throw Error("Invalid data");
        }
        if (cs.loadBit()) {
          cs.loadRef();
        }
        let configAddress = cs.loadUintBig(256);
        let config2 = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), cs);
        const globalBalance = (0, CurrencyCollection_1.loadCurrencyCollection)(cs);
        return {
          config: config2,
          configAddress,
          globalBalance
        };
      }
      exports.loadMasterchainStateExtra = loadMasterchainStateExtra;
    }
  });

  // node_modules/ton-core/dist/types/Message.js
  var require_Message = __commonJS({
    "node_modules/ton-core/dist/types/Message.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MessageValue = exports.storeMessage = exports.loadMessage = void 0;
      var Builder_1 = require_Builder();
      var CommonMessageInfo_1 = require_CommonMessageInfo();
      var StateInit_1 = require_StateInit();
      function loadMessage(slice2) {
        const info = (0, CommonMessageInfo_1.loadCommonMessageInfo)(slice2);
        let init2 = null;
        if (slice2.loadBit()) {
          if (!slice2.loadBit()) {
            init2 = (0, StateInit_1.loadStateInit)(slice2);
          } else {
            init2 = (0, StateInit_1.loadStateInit)(slice2.loadRef().beginParse());
          }
        }
        const body = slice2.loadBit() ? slice2.loadRef() : slice2.asCell();
        return {
          info,
          init: init2,
          body
        };
      }
      exports.loadMessage = loadMessage;
      function storeMessage(message, opts) {
        return (builder) => {
          builder.store((0, CommonMessageInfo_1.storeCommonMessageInfo)(message.info));
          if (message.init) {
            builder.storeBit(true);
            let initCell = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
            if (builder.availableBits - 2 >= initCell.bits) {
              builder.storeBit(false);
              builder.storeBuilder(initCell);
            } else {
              builder.storeBit(true);
              builder.storeRef(initCell);
            }
          } else {
            builder.storeBit(false);
          }
          let needRef = false;
          if (opts && opts.forceRef) {
            needRef = true;
          } else {
            if (builder.availableBits - 1 >= message.body.bits.length) {
              needRef = false;
            } else {
              needRef = true;
            }
          }
          if (needRef) {
            builder.storeBit(true);
            builder.storeRef(message.body);
          } else {
            builder.storeBit(false);
            builder.storeBuilder(message.body.asBuilder());
          }
        };
      }
      exports.storeMessage = storeMessage;
      exports.MessageValue = {
        serialize(src, builder) {
          builder.storeRef((0, Builder_1.beginCell)().store(storeMessage(src)));
        },
        parse(slice2) {
          return loadMessage(slice2.loadRef().beginParse());
        }
      };
    }
  });

  // node_modules/ton-core/dist/types/MessageRelaxed.js
  var require_MessageRelaxed = __commonJS({
    "node_modules/ton-core/dist/types/MessageRelaxed.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeMessageRelaxed = exports.loadMessageRelaxed = void 0;
      var Builder_1 = require_Builder();
      var CommonMessageInfoRelaxed_1 = require_CommonMessageInfoRelaxed();
      var StateInit_1 = require_StateInit();
      function loadMessageRelaxed(slice2) {
        const info = (0, CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(slice2);
        let init2 = null;
        if (slice2.loadBit()) {
          if (!slice2.loadBit()) {
            init2 = (0, StateInit_1.loadStateInit)(slice2);
          } else {
            init2 = (0, StateInit_1.loadStateInit)(slice2.loadRef().beginParse());
          }
        }
        const body = slice2.loadBit() ? slice2.loadRef() : slice2.asCell();
        return {
          info,
          init: init2,
          body
        };
      }
      exports.loadMessageRelaxed = loadMessageRelaxed;
      function storeMessageRelaxed(message, opts) {
        return (builder) => {
          builder.store((0, CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(message.info));
          if (message.init) {
            builder.storeBit(true);
            let initCell = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
            if (builder.availableBits - 2 >= initCell.bits) {
              builder.storeBit(false);
              builder.storeBuilder(initCell);
            } else {
              builder.storeBit(true);
              builder.storeRef(initCell);
            }
          } else {
            builder.storeBit(false);
          }
          let needRef = false;
          if (opts && opts.forceRef) {
            needRef = true;
          } else {
            if (builder.availableBits - 1 >= message.body.bits.length) {
              needRef = false;
            } else {
              needRef = true;
            }
          }
          if (needRef) {
            builder.storeBit(true);
            builder.storeRef(message.body);
          } else {
            builder.storeBit(false);
            builder.storeBuilder(message.body.asBuilder());
          }
        };
      }
      exports.storeMessageRelaxed = storeMessageRelaxed;
    }
  });

  // node_modules/ton-core/dist/types/SendMode.js
  var require_SendMode = __commonJS({
    "node_modules/ton-core/dist/types/SendMode.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SendMode = void 0;
      var SendMode;
      (function(SendMode2) {
        SendMode2[SendMode2["CARRRY_ALL_REMAINING_BALANCE"] = 128] = "CARRRY_ALL_REMAINING_BALANCE";
        SendMode2[SendMode2["CARRRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRRY_ALL_REMAINING_INCOMING_VALUE";
        SendMode2[SendMode2["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
        SendMode2[SendMode2["PAY_GAS_SEPARATLY"] = 1] = "PAY_GAS_SEPARATLY";
        SendMode2[SendMode2["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
        SendMode2[SendMode2["NONE"] = 0] = "NONE";
      })(SendMode = exports.SendMode || (exports.SendMode = {}));
    }
  });

  // node_modules/ton-core/dist/types/ShardAccount.js
  var require_ShardAccount = __commonJS({
    "node_modules/ton-core/dist/types/ShardAccount.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeShardAccount = exports.loadShardAccount = void 0;
      var Builder_1 = require_Builder();
      var Account_1 = require_Account();
      function loadShardAccount(slice2) {
        let accountRef = slice2.loadRef();
        let account = void 0;
        if (!accountRef.isExotic) {
          let accountSlice = accountRef.beginParse();
          if (accountSlice.loadBit()) {
            account = (0, Account_1.loadAccount)(accountSlice);
          }
        }
        return {
          account,
          lastTransactionHash: slice2.loadUintBig(256),
          lastTransactionLt: slice2.loadUintBig(64)
        };
      }
      exports.loadShardAccount = loadShardAccount;
      function storeShardAccount(src) {
        return (builder) => {
          if (src.account) {
            builder.storeRef((0, Builder_1.beginCell)().storeBit(true).store((0, Account_1.storeAccount)(src.account)));
          } else {
            builder.storeRef((0, Builder_1.beginCell)().storeBit(false));
          }
          builder.storeUint(src.lastTransactionHash, 256);
          builder.storeUint(src.lastTransactionLt, 64);
        };
      }
      exports.storeShardAccount = storeShardAccount;
    }
  });

  // node_modules/ton-core/dist/types/ShardAccounts.js
  var require_ShardAccounts = __commonJS({
    "node_modules/ton-core/dist/types/ShardAccounts.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = void 0;
      var Dictionary_1 = require_Dictionary();
      var DepthBalanceInfo_1 = require_DepthBalanceInfo();
      var ShardAccount_1 = require_ShardAccount();
      exports.ShardAccountRefValue = {
        parse: (cs) => {
          let depthBalanceInfo = (0, DepthBalanceInfo_1.loadDepthBalanceInfo)(cs);
          let shardAccount = (0, ShardAccount_1.loadShardAccount)(cs);
          return {
            depthBalanceInfo,
            shardAccount
          };
        },
        serialize(src, builder) {
          builder.store((0, DepthBalanceInfo_1.storeDepthBalanceInfo)(src.depthBalanceInfo));
          builder.store((0, ShardAccount_1.storeShardAccount)(src.shardAccount));
        }
      };
      function loadShardAccounts(cs) {
        return Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.BigUint(256), exports.ShardAccountRefValue, cs);
      }
      exports.loadShardAccounts = loadShardAccounts;
      function storeShardAccounts(src) {
        return (Builder) => {
          Builder.storeDict(src);
        };
      }
      exports.storeShardAccounts = storeShardAccounts;
    }
  });

  // node_modules/ton-core/dist/types/ShardIdent.js
  var require_ShardIdent = __commonJS({
    "node_modules/ton-core/dist/types/ShardIdent.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeShardIdent = exports.loadShardIdent = void 0;
      function loadShardIdent(slice2) {
        if (slice2.loadUint(2) !== 0) {
          throw Error("Invalid data");
        }
        return {
          shardPrefixBits: slice2.loadUint(6),
          workchainId: slice2.loadInt(32),
          shardPrefix: slice2.loadUintBig(64)
        };
      }
      exports.loadShardIdent = loadShardIdent;
      function storeShardIdent(src) {
        return (builder) => {
          builder.storeUint(0, 2);
          builder.storeUint(src.shardPrefixBits, 6);
          builder.storeInt(src.workchainId, 32);
          builder.storeUint(src.shardPrefix, 64);
        };
      }
      exports.storeShardIdent = storeShardIdent;
    }
  });

  // node_modules/ton-core/dist/types/ShardStateUnsplit.js
  var require_ShardStateUnsplit = __commonJS({
    "node_modules/ton-core/dist/types/ShardStateUnsplit.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.loadShardStateUnsplit = void 0;
      var MasterchainStateExtra_1 = require_MasterchainStateExtra();
      var ShardAccounts_1 = require_ShardAccounts();
      var ShardIdent_1 = require_ShardIdent();
      function loadShardStateUnsplit(cs) {
        if (cs.loadUint(32) !== 2418257890) {
          throw Error("Invalid data");
        }
        let globalId = cs.loadInt(32);
        let shardId = (0, ShardIdent_1.loadShardIdent)(cs);
        let seqno = cs.loadUint(32);
        let vertSeqNo = cs.loadUint(32);
        let genUtime = cs.loadUint(32);
        let genLt = cs.loadUintBig(64);
        let minRefMcSeqno = cs.loadUint(32);
        cs.loadRef();
        let beforeSplit = cs.loadBit();
        let shardAccountsRef = cs.loadRef();
        let accounts = void 0;
        if (!shardAccountsRef.isExotic) {
          accounts = (0, ShardAccounts_1.loadShardAccounts)(shardAccountsRef.beginParse());
        }
        cs.loadRef();
        let mcStateExtra = cs.loadBit();
        let extras = null;
        if (mcStateExtra) {
          let cell = cs.loadRef();
          if (!cell.isExotic) {
            extras = (0, MasterchainStateExtra_1.loadMasterchainStateExtra)(cell.beginParse());
          }
        }
        ;
        return {
          globalId,
          shardId,
          seqno,
          vertSeqNo,
          genUtime,
          genLt,
          minRefMcSeqno,
          beforeSplit,
          accounts,
          extras
        };
      }
      exports.loadShardStateUnsplit = loadShardStateUnsplit;
    }
  });

  // node_modules/ton-core/dist/types/SplitMergeInfo.js
  var require_SplitMergeInfo = __commonJS({
    "node_modules/ton-core/dist/types/SplitMergeInfo.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = void 0;
      function loadSplitMergeInfo(slice2) {
        let currentShardPrefixLength = slice2.loadUint(6);
        let accountSplitDepth = slice2.loadUint(6);
        let thisAddress = slice2.loadUintBig(256);
        let siblingAddress = slice2.loadUintBig(256);
        return {
          currentShardPrefixLength,
          accountSplitDepth,
          thisAddress,
          siblingAddress
        };
      }
      exports.loadSplitMergeInfo = loadSplitMergeInfo;
      function storeSplitMergeInfo(src) {
        return (builder) => {
          builder.storeUint(src.currentShardPrefixLength, 6);
          builder.storeUint(src.accountSplitDepth, 6);
          builder.storeUint(src.thisAddress, 256);
          builder.storeUint(src.siblingAddress, 256);
        };
      }
      exports.storeSplitMergeInfo = storeSplitMergeInfo;
    }
  });

  // node_modules/ton-core/dist/types/StorageUsedShort.js
  var require_StorageUsedShort = __commonJS({
    "node_modules/ton-core/dist/types/StorageUsedShort.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeStorageUsedShort = exports.loadStorageUsedShort = void 0;
      function loadStorageUsedShort(slice2) {
        let cells = slice2.loadVarUintBig(3);
        let bits = slice2.loadVarUintBig(3);
        return {
          cells,
          bits
        };
      }
      exports.loadStorageUsedShort = loadStorageUsedShort;
      function storeStorageUsedShort(src) {
        return (builder) => {
          builder.storeVarUint(src.cells, 3);
          builder.storeVarUint(src.bits, 3);
        };
      }
      exports.storeStorageUsedShort = storeStorageUsedShort;
    }
  });

  // node_modules/ton-core/dist/types/TransactionActionPhase.js
  var require_TransactionActionPhase = __commonJS({
    "node_modules/ton-core/dist/types/TransactionActionPhase.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = void 0;
      var AccountStatusChange_1 = require_AccountStatusChange();
      var StorageUsedShort_1 = require_StorageUsedShort();
      function loadTransactionActionPhase(slice2) {
        let success = slice2.loadBit();
        let valid = slice2.loadBit();
        let noFunds = slice2.loadBit();
        let statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice2);
        let totalFwdFees = slice2.loadBit() ? slice2.loadCoins() : void 0;
        let totalActionFees = slice2.loadBit() ? slice2.loadCoins() : void 0;
        let resultCode = slice2.loadInt(32);
        let resultArg = slice2.loadBit() ? slice2.loadInt(32) : void 0;
        let totalActions = slice2.loadUint(16);
        let specActions = slice2.loadUint(16);
        let skippedActions = slice2.loadUint(16);
        let messagesCreated = slice2.loadUint(16);
        let actionListHash = slice2.loadUintBig(256);
        let totalMessageSize = (0, StorageUsedShort_1.loadStorageUsedShort)(slice2);
        return {
          success,
          valid,
          noFunds,
          statusChange,
          totalFwdFees,
          totalActionFees,
          resultCode,
          resultArg,
          totalActions,
          specActions,
          skippedActions,
          messagesCreated,
          actionListHash,
          totalMessageSize
        };
      }
      exports.loadTransactionActionPhase = loadTransactionActionPhase;
      function storeTransactionActionPhase(src) {
        return (builder) => {
          builder.storeBit(src.success);
          builder.storeBit(src.valid);
          builder.storeBit(src.noFunds);
          builder.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
          builder.storeMaybeCoins(src.totalFwdFees);
          builder.storeMaybeCoins(src.totalActionFees);
          builder.storeInt(src.resultCode, 32);
          builder.storeMaybeInt(src.resultArg, 32);
          builder.storeUint(src.totalActions, 16);
          builder.storeUint(src.specActions, 16);
          builder.storeUint(src.skippedActions, 16);
          builder.storeUint(src.messagesCreated, 16);
          builder.storeUint(src.actionListHash, 256);
          builder.store((0, StorageUsedShort_1.storeStorageUsedShort)(src.totalMessageSize));
        };
      }
      exports.storeTransactionActionPhase = storeTransactionActionPhase;
    }
  });

  // node_modules/ton-core/dist/types/TransactionBouncePhase.js
  var require_TransactionBouncePhase = __commonJS({
    "node_modules/ton-core/dist/types/TransactionBouncePhase.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = void 0;
      var StorageUsedShort_1 = require_StorageUsedShort();
      function loadTransactionBouncePhase(slice2) {
        if (slice2.loadBit()) {
          let messageSize = (0, StorageUsedShort_1.loadStorageUsedShort)(slice2);
          let messageFees = slice2.loadCoins();
          let forwardFees = slice2.loadCoins();
          return {
            type: "ok",
            messageSize,
            messageFees,
            forwardFees
          };
        }
        if (slice2.loadBit()) {
          let messageSize = (0, StorageUsedShort_1.loadStorageUsedShort)(slice2);
          let requiredForwardFees = slice2.loadCoins();
          return {
            type: "no-funds",
            messageSize,
            requiredForwardFees
          };
        }
        return {
          type: "negative-funds"
        };
      }
      exports.loadTransactionBouncePhase = loadTransactionBouncePhase;
      function storeTransactionBouncePhase(src) {
        return (builder) => {
          if (src.type === "ok") {
            builder.storeBit(true);
            builder.store((0, StorageUsedShort_1.storeStorageUsedShort)(src.messageSize));
            builder.storeCoins(src.messageFees);
            builder.storeCoins(src.forwardFees);
          } else if (src.type === "negative-funds") {
            builder.storeBit(false);
            builder.storeBit(false);
          } else if (src.type === "no-funds") {
            builder.storeBit(false);
            builder.storeBit(true);
            builder.store((0, StorageUsedShort_1.storeStorageUsedShort)(src.messageSize));
            builder.storeCoins(src.requiredForwardFees);
          } else {
            throw new Error("Invalid TransactionBouncePhase type");
          }
        };
      }
      exports.storeTransactionBouncePhase = storeTransactionBouncePhase;
    }
  });

  // node_modules/ton-core/dist/types/TransactionComputePhase.js
  var require_TransactionComputePhase = __commonJS({
    "node_modules/ton-core/dist/types/TransactionComputePhase.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = void 0;
      var Builder_1 = require_Builder();
      var ComputeSkipReason_1 = require_ComputeSkipReason();
      function loadTransactionComputePhase(slice2) {
        if (!slice2.loadBit()) {
          let reason = (0, ComputeSkipReason_1.loadComputeSkipReason)(slice2);
          return {
            type: "skipped",
            reason
          };
        }
        let success = slice2.loadBit();
        let messageStateUsed = slice2.loadBit();
        let accountActivated = slice2.loadBit();
        let gasFees = slice2.loadCoins();
        const vmState = slice2.loadRef().beginParse();
        let gasUsed = vmState.loadVarUintBig(3);
        let gasLimit = vmState.loadVarUintBig(3);
        let gasCredit = vmState.loadBit() ? vmState.loadVarUintBig(2) : void 0;
        let mode = vmState.loadUint(8);
        let exitCode = vmState.loadUint(32);
        let exitArg = vmState.loadBit() ? vmState.loadInt(32) : void 0;
        let vmSteps = vmState.loadUint(32);
        let vmInitStateHash = vmState.loadUintBig(256);
        let vmFinalStateHash = vmState.loadUintBig(256);
        return {
          type: "vm",
          success,
          messageStateUsed,
          accountActivated,
          gasFees,
          gasUsed,
          gasLimit,
          gasCredit,
          mode,
          exitCode,
          exitArg,
          vmSteps,
          vmInitStateHash,
          vmFinalStateHash
        };
      }
      exports.loadTransactionComputePhase = loadTransactionComputePhase;
      function storeTransactionComputePhase(src) {
        return (builder) => {
          if (src.type === "skipped") {
            builder.storeBit(0);
            builder.store((0, ComputeSkipReason_1.storeComputeSkipReason)(src.reason));
            return;
          }
          builder.storeBit(1);
          builder.storeBit(src.success);
          builder.storeBit(src.messageStateUsed);
          builder.storeBit(src.accountActivated);
          builder.storeCoins(src.gasFees);
          builder.storeRef((0, Builder_1.beginCell)().storeVarUint(src.gasUsed, 3).storeVarUint(src.gasLimit, 3).store((b) => src.gasCredit !== void 0 && src.gasCredit !== null ? b.storeBit(1).storeVarUint(src.gasCredit, 2) : b.storeBit(0)).storeUint(src.mode, 8).storeUint(src.exitCode, 32).store((b) => src.exitArg !== void 0 && src.exitArg !== null ? b.storeBit(1).storeInt(src.exitArg, 32) : b.storeBit(0)).storeUint(src.vmSteps, 32).storeUint(src.vmInitStateHash, 256).storeUint(src.vmFinalStateHash, 256).endCell());
        };
      }
      exports.storeTransactionComputePhase = storeTransactionComputePhase;
    }
  });

  // node_modules/ton-core/dist/types/TransactionCreditPhase.js
  var require_TransactionCreditPhase = __commonJS({
    "node_modules/ton-core/dist/types/TransactionCreditPhase.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = void 0;
      var CurrencyCollection_1 = require_CurrencyCollection();
      function loadTransactionCreditPhase(slice2) {
        const dueFeesColelcted = slice2.loadBit() ? slice2.loadCoins() : void 0;
        const credit = (0, CurrencyCollection_1.loadCurrencyCollection)(slice2);
        return {
          dueFeesColelcted,
          credit
        };
      }
      exports.loadTransactionCreditPhase = loadTransactionCreditPhase;
      function storeTransactionCreditPhase(src) {
        return (builder) => {
          if (src.dueFeesColelcted === null || src.dueFeesColelcted === void 0) {
            builder.storeBit(false);
          } else {
            builder.storeBit(true);
            builder.storeCoins(src.dueFeesColelcted);
          }
          builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.credit));
        };
      }
      exports.storeTransactionCreditPhase = storeTransactionCreditPhase;
    }
  });

  // node_modules/ton-core/dist/types/TransactionStoragePhase.js
  var require_TransactionStoragePhase = __commonJS({
    "node_modules/ton-core/dist/types/TransactionStoragePhase.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = void 0;
      var AccountStatusChange_1 = require_AccountStatusChange();
      function loadTransactionStoragePhase(slice2) {
        const storageFeesCollected = slice2.loadCoins();
        let storageFeesDue = void 0;
        if (slice2.loadBit()) {
          storageFeesDue = slice2.loadCoins();
        }
        const statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice2);
        return {
          storageFeesCollected,
          storageFeesDue,
          statusChange
        };
      }
      exports.loadTransactionStoragePhase = loadTransactionStoragePhase;
      function storeTransactionsStoragePhase(src) {
        return (builder) => {
          builder.storeCoins(src.storageFeesCollected);
          if (src.storageFeesDue === null || src.storageFeesDue === void 0) {
            builder.storeBit(false);
          } else {
            builder.storeBit(true);
            builder.storeCoins(src.storageFeesDue);
          }
          builder.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
        };
      }
      exports.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
    }
  });

  // node_modules/ton-core/dist/types/TransactionDescription.js
  var require_TransactionDescription = __commonJS({
    "node_modules/ton-core/dist/types/TransactionDescription.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeTransactionDescription = exports.loadTransactionDescription = void 0;
      var Builder_1 = require_Builder();
      var SplitMergeInfo_1 = require_SplitMergeInfo();
      var Transaction_1 = require_Transaction();
      var TransactionActionPhase_1 = require_TransactionActionPhase();
      var TransactionBouncePhase_1 = require_TransactionBouncePhase();
      var TransactionComputePhase_1 = require_TransactionComputePhase();
      var TransactionCreditPhase_1 = require_TransactionCreditPhase();
      var TransactionStoragePhase_1 = require_TransactionStoragePhase();
      function loadTransactionDescription(slice2) {
        let type = slice2.loadUint(4);
        if (type === 0) {
          const creditFirst = slice2.loadBit();
          let storagePhase = void 0;
          if (slice2.loadBit()) {
            storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice2);
          }
          let creditPhase = void 0;
          if (slice2.loadBit()) {
            creditPhase = (0, TransactionCreditPhase_1.loadTransactionCreditPhase)(slice2);
          }
          let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice2);
          let actionPhase = void 0;
          if (slice2.loadBit()) {
            actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice2.loadRef().beginParse());
          }
          let aborted = slice2.loadBit();
          let bouncePhase = void 0;
          if (slice2.loadBit()) {
            bouncePhase = (0, TransactionBouncePhase_1.loadTransactionBouncePhase)(slice2);
          }
          const destroyed = slice2.loadBit();
          return {
            type: "generic",
            creditFirst,
            storagePhase,
            creditPhase,
            computePhase,
            actionPhase,
            bouncePhase,
            aborted,
            destroyed
          };
        }
        if (type === 1) {
          return {
            type: "storage",
            storagePhase: (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice2)
          };
        }
        if (type === 2 || type === 3) {
          const isTock = type === 3;
          let storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice2);
          let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice2);
          let actionPhase = void 0;
          if (slice2.loadBit()) {
            actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice2.loadRef().beginParse());
          }
          const aborted = slice2.loadBit();
          const destroyed = slice2.loadBit();
          return {
            type: "tick-tock",
            isTock,
            storagePhase,
            computePhase,
            actionPhase,
            aborted,
            destroyed
          };
        }
        if (type === 4) {
          let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice2);
          let storagePhase = void 0;
          if (slice2.loadBit()) {
            storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice2);
          }
          let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice2);
          let actionPhase = void 0;
          if (slice2.loadBit()) {
            actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice2.loadRef().beginParse());
          }
          const aborted = slice2.loadBit();
          const destroyed = slice2.loadBit();
          return {
            type: "split-prepare",
            splitInfo,
            storagePhase,
            computePhase,
            actionPhase,
            aborted,
            destroyed
          };
        }
        if (type === 5) {
          let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice2);
          let prepareTransaction = (0, Transaction_1.loadTransaction)(slice2.loadRef().beginParse());
          const installed = slice2.loadBit();
          return {
            type: "split-install",
            splitInfo,
            prepareTransaction,
            installed
          };
        }
        throw Error(`Unsupported transaction description type ${type}`);
      }
      exports.loadTransactionDescription = loadTransactionDescription;
      function storeTransactionDescription(src) {
        return (builder) => {
          if (src.type === "generic") {
            builder.storeUint(0, 4);
            builder.storeBit(src.creditFirst);
            if (src.storagePhase) {
              builder.storeBit(true);
              builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
            } else {
              builder.storeBit(false);
            }
            if (src.creditPhase) {
              builder.storeBit(true);
              builder.store((0, TransactionCreditPhase_1.storeTransactionCreditPhase)(src.creditPhase));
            } else {
              builder.storeBit(false);
            }
            builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
            if (src.actionPhase) {
              builder.storeBit(true);
              builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
            } else {
              builder.storeBit(false);
            }
            builder.storeBit(src.aborted);
            if (src.bouncePhase) {
              builder.storeBit(true);
              builder.store((0, TransactionBouncePhase_1.storeTransactionBouncePhase)(src.bouncePhase));
            } else {
              builder.storeBit(false);
            }
            builder.storeBit(src.destroyed);
          } else if (src.type === "storage") {
            builder.storeUint(1, 4);
            builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
          } else if (src.type === "tick-tock") {
            builder.storeUint(src.isTock ? 3 : 2, 4);
            builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
            builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
            if (src.actionPhase) {
              builder.storeBit(true);
              builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
            } else {
              builder.storeBit(false);
            }
            builder.storeBit(src.aborted);
            builder.storeBit(src.destroyed);
          } else if (src.type === "split-prepare") {
            builder.storeUint(4, 4);
            builder.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
            if (src.storagePhase) {
              builder.storeBit(true);
              builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
            } else {
              builder.storeBit(false);
            }
            builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
            if (src.actionPhase) {
              builder.storeBit(true);
              builder.store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase));
            } else {
              builder.storeBit(false);
            }
            builder.storeBit(src.aborted);
            builder.storeBit(src.destroyed);
          } else if (src.type === "split-install") {
            builder.storeUint(5, 4);
            builder.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
            builder.storeRef((0, Builder_1.beginCell)().store((0, Transaction_1.storeTransaction)(src.prepareTransaction)));
            builder.storeBit(src.installed);
          } else {
            throw Error(`Unsupported transaction description type ${src.type}`);
          }
        };
      }
      exports.storeTransactionDescription = storeTransactionDescription;
    }
  });

  // node_modules/ton-core/dist/types/Transaction.js
  var require_Transaction = __commonJS({
    "node_modules/ton-core/dist/types/Transaction.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.storeTransaction = exports.loadTransaction = void 0;
      var Builder_1 = require_Builder();
      var Dictionary_1 = require_Dictionary();
      var AccountStatus_1 = require_AccountStatus();
      var CurrencyCollection_1 = require_CurrencyCollection();
      var HashUpdate_1 = require_HashUpdate();
      var Message_1 = require_Message();
      var TransactionDescription_1 = require_TransactionDescription();
      function loadTransaction(slice2) {
        if (slice2.loadUint(4) !== 7) {
          throw Error("Invalid data");
        }
        let address = slice2.loadUintBig(256);
        let lt = slice2.loadUintBig(64);
        let prevTransactionHash = slice2.loadUintBig(256);
        let prevTransactionLt = slice2.loadUintBig(64);
        let now = slice2.loadUint(32);
        let outMessagesCount = slice2.loadUint(15);
        let oldStatus = (0, AccountStatus_1.loadAccountStatus)(slice2);
        let endStatus = (0, AccountStatus_1.loadAccountStatus)(slice2);
        let msgRef = slice2.loadRef();
        let msgSlice = msgRef.beginParse();
        let inMessage = msgSlice.loadBit() ? (0, Message_1.loadMessage)(msgSlice.loadRef().beginParse()) : void 0;
        let outMessages = msgSlice.loadDict(Dictionary_1.Dictionary.Keys.Uint(15), Message_1.MessageValue);
        msgSlice.endParse();
        let totalFees = (0, CurrencyCollection_1.loadCurrencyCollection)(slice2);
        let stateUpdate = (0, HashUpdate_1.loadHashUpdate)(slice2.loadRef().beginParse());
        let description = (0, TransactionDescription_1.loadTransactionDescription)(slice2.loadRef().beginParse());
        return {
          address,
          lt,
          prevTransactionHash,
          prevTransactionLt,
          now,
          outMessagesCount,
          oldStatus,
          endStatus,
          inMessage,
          outMessages,
          totalFees,
          stateUpdate,
          description
        };
      }
      exports.loadTransaction = loadTransaction;
      function storeTransaction(src) {
        return (builder) => {
          builder.storeUint(7, 4);
          builder.storeUint(src.address, 256);
          builder.storeUint(src.lt, 64);
          builder.storeUint(src.prevTransactionHash, 256);
          builder.storeUint(src.prevTransactionLt, 64);
          builder.storeUint(src.now, 32);
          builder.storeUint(src.outMessagesCount, 15);
          builder.store((0, AccountStatus_1.storeAccountStatus)(src.oldStatus));
          builder.store((0, AccountStatus_1.storeAccountStatus)(src.endStatus));
          let msgBuilder = (0, Builder_1.beginCell)();
          if (src.inMessage) {
            msgBuilder.storeBit(true);
            msgBuilder.storeRef((0, Builder_1.beginCell)().store((0, Message_1.storeMessage)(src.inMessage)));
          } else {
            msgBuilder.storeBit(false);
          }
          msgBuilder.storeDict(src.outMessages);
          builder.storeRef(msgBuilder);
          builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.totalFees));
          builder.storeRef((0, Builder_1.beginCell)().store((0, HashUpdate_1.storeHashUpdate)(src.stateUpdate)));
          builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionDescription_1.storeTransactionDescription)(src.description)));
        };
      }
      exports.storeTransaction = storeTransaction;
    }
  });

  // node_modules/ton-core/dist/types/_export.js
  var require_export = __commonJS({
    "node_modules/ton-core/dist/types/_export.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.loadStorageUsedShort = exports.storeStorageUsed = exports.loadStorageUsed = exports.storeStorageInfo = exports.loadStorageInfo = exports.storeStateInit = exports.loadStateInit = exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = exports.storeSimpleLibrary = exports.loadSimpleLibrary = exports.loadShardStateUnsplit = exports.storeShardIdent = exports.loadShardIdent = exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = exports.storeShardAccount = exports.loadShardAccount = exports.SendMode = exports.storeMessageRelaxed = exports.loadMessageRelaxed = exports.storeMessage = exports.loadMessage = exports.loadMasterchainStateExtra = exports.storeHashUpdate = exports.loadHashUpdate = exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = exports.storeCurrencyCollection = exports.loadCurrencyCollection = exports.storeComputeSkipReason = exports.loadComputeSkipReason = exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = exports.storeAccountStorage = exports.loadAccountStorage = exports.storeAccountStatusChange = exports.loadAccountStatusChange = exports.storeAccountStatus = exports.loadAccountStatus = exports.storeAccountState = exports.loadAccountState = exports.storeAccount = exports.loadAccount = exports.comment = exports.external = exports.internal = void 0;
      exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = exports.storeTransactionDescription = exports.loadTransactionDescription = exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = exports.storeTransaction = exports.loadTransaction = exports.storeTickTock = exports.loadTickTock = exports.storeStorageUsedShort = void 0;
      var _helpers_1 = require_helpers();
      Object.defineProperty(exports, "internal", { enumerable: true, get: function() {
        return _helpers_1.internal;
      } });
      Object.defineProperty(exports, "external", { enumerable: true, get: function() {
        return _helpers_1.external;
      } });
      Object.defineProperty(exports, "comment", { enumerable: true, get: function() {
        return _helpers_1.comment;
      } });
      var Account_1 = require_Account();
      Object.defineProperty(exports, "loadAccount", { enumerable: true, get: function() {
        return Account_1.loadAccount;
      } });
      Object.defineProperty(exports, "storeAccount", { enumerable: true, get: function() {
        return Account_1.storeAccount;
      } });
      var AccountState_1 = require_AccountState();
      Object.defineProperty(exports, "loadAccountState", { enumerable: true, get: function() {
        return AccountState_1.loadAccountState;
      } });
      Object.defineProperty(exports, "storeAccountState", { enumerable: true, get: function() {
        return AccountState_1.storeAccountState;
      } });
      var AccountStatus_1 = require_AccountStatus();
      Object.defineProperty(exports, "loadAccountStatus", { enumerable: true, get: function() {
        return AccountStatus_1.loadAccountStatus;
      } });
      Object.defineProperty(exports, "storeAccountStatus", { enumerable: true, get: function() {
        return AccountStatus_1.storeAccountStatus;
      } });
      var AccountStatusChange_1 = require_AccountStatusChange();
      Object.defineProperty(exports, "loadAccountStatusChange", { enumerable: true, get: function() {
        return AccountStatusChange_1.loadAccountStatusChange;
      } });
      Object.defineProperty(exports, "storeAccountStatusChange", { enumerable: true, get: function() {
        return AccountStatusChange_1.storeAccountStatusChange;
      } });
      var AccountStorage_1 = require_AccountStorage();
      Object.defineProperty(exports, "loadAccountStorage", { enumerable: true, get: function() {
        return AccountStorage_1.loadAccountStorage;
      } });
      Object.defineProperty(exports, "storeAccountStorage", { enumerable: true, get: function() {
        return AccountStorage_1.storeAccountStorage;
      } });
      var CommonMessageInfo_1 = require_CommonMessageInfo();
      Object.defineProperty(exports, "loadCommonMessageInfo", { enumerable: true, get: function() {
        return CommonMessageInfo_1.loadCommonMessageInfo;
      } });
      Object.defineProperty(exports, "storeCommonMessageInfo", { enumerable: true, get: function() {
        return CommonMessageInfo_1.storeCommonMessageInfo;
      } });
      var CommonMessageInfoRelaxed_1 = require_CommonMessageInfoRelaxed();
      Object.defineProperty(exports, "loadCommonMessageInfoRelaxed", { enumerable: true, get: function() {
        return CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed;
      } });
      Object.defineProperty(exports, "storeCommonMessageInfoRelaxed", { enumerable: true, get: function() {
        return CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed;
      } });
      var ComputeSkipReason_1 = require_ComputeSkipReason();
      Object.defineProperty(exports, "loadComputeSkipReason", { enumerable: true, get: function() {
        return ComputeSkipReason_1.loadComputeSkipReason;
      } });
      Object.defineProperty(exports, "storeComputeSkipReason", { enumerable: true, get: function() {
        return ComputeSkipReason_1.storeComputeSkipReason;
      } });
      var CurrencyCollection_1 = require_CurrencyCollection();
      Object.defineProperty(exports, "loadCurrencyCollection", { enumerable: true, get: function() {
        return CurrencyCollection_1.loadCurrencyCollection;
      } });
      Object.defineProperty(exports, "storeCurrencyCollection", { enumerable: true, get: function() {
        return CurrencyCollection_1.storeCurrencyCollection;
      } });
      var DepthBalanceInfo_1 = require_DepthBalanceInfo();
      Object.defineProperty(exports, "loadDepthBalanceInfo", { enumerable: true, get: function() {
        return DepthBalanceInfo_1.loadDepthBalanceInfo;
      } });
      Object.defineProperty(exports, "storeDepthBalanceInfo", { enumerable: true, get: function() {
        return DepthBalanceInfo_1.storeDepthBalanceInfo;
      } });
      var HashUpdate_1 = require_HashUpdate();
      Object.defineProperty(exports, "loadHashUpdate", { enumerable: true, get: function() {
        return HashUpdate_1.loadHashUpdate;
      } });
      Object.defineProperty(exports, "storeHashUpdate", { enumerable: true, get: function() {
        return HashUpdate_1.storeHashUpdate;
      } });
      var MasterchainStateExtra_1 = require_MasterchainStateExtra();
      Object.defineProperty(exports, "loadMasterchainStateExtra", { enumerable: true, get: function() {
        return MasterchainStateExtra_1.loadMasterchainStateExtra;
      } });
      var Message_1 = require_Message();
      Object.defineProperty(exports, "loadMessage", { enumerable: true, get: function() {
        return Message_1.loadMessage;
      } });
      Object.defineProperty(exports, "storeMessage", { enumerable: true, get: function() {
        return Message_1.storeMessage;
      } });
      var MessageRelaxed_1 = require_MessageRelaxed();
      Object.defineProperty(exports, "loadMessageRelaxed", { enumerable: true, get: function() {
        return MessageRelaxed_1.loadMessageRelaxed;
      } });
      Object.defineProperty(exports, "storeMessageRelaxed", { enumerable: true, get: function() {
        return MessageRelaxed_1.storeMessageRelaxed;
      } });
      var SendMode_1 = require_SendMode();
      Object.defineProperty(exports, "SendMode", { enumerable: true, get: function() {
        return SendMode_1.SendMode;
      } });
      var ShardAccount_1 = require_ShardAccount();
      Object.defineProperty(exports, "loadShardAccount", { enumerable: true, get: function() {
        return ShardAccount_1.loadShardAccount;
      } });
      Object.defineProperty(exports, "storeShardAccount", { enumerable: true, get: function() {
        return ShardAccount_1.storeShardAccount;
      } });
      var ShardAccounts_1 = require_ShardAccounts();
      Object.defineProperty(exports, "ShardAccountRefValue", { enumerable: true, get: function() {
        return ShardAccounts_1.ShardAccountRefValue;
      } });
      Object.defineProperty(exports, "loadShardAccounts", { enumerable: true, get: function() {
        return ShardAccounts_1.loadShardAccounts;
      } });
      Object.defineProperty(exports, "storeShardAccounts", { enumerable: true, get: function() {
        return ShardAccounts_1.storeShardAccounts;
      } });
      var ShardIdent_1 = require_ShardIdent();
      Object.defineProperty(exports, "loadShardIdent", { enumerable: true, get: function() {
        return ShardIdent_1.loadShardIdent;
      } });
      Object.defineProperty(exports, "storeShardIdent", { enumerable: true, get: function() {
        return ShardIdent_1.storeShardIdent;
      } });
      var ShardStateUnsplit_1 = require_ShardStateUnsplit();
      Object.defineProperty(exports, "loadShardStateUnsplit", { enumerable: true, get: function() {
        return ShardStateUnsplit_1.loadShardStateUnsplit;
      } });
      var SimpleLibrary_1 = require_SimpleLibrary();
      Object.defineProperty(exports, "loadSimpleLibrary", { enumerable: true, get: function() {
        return SimpleLibrary_1.loadSimpleLibrary;
      } });
      Object.defineProperty(exports, "storeSimpleLibrary", { enumerable: true, get: function() {
        return SimpleLibrary_1.storeSimpleLibrary;
      } });
      var SplitMergeInfo_1 = require_SplitMergeInfo();
      Object.defineProperty(exports, "loadSplitMergeInfo", { enumerable: true, get: function() {
        return SplitMergeInfo_1.loadSplitMergeInfo;
      } });
      Object.defineProperty(exports, "storeSplitMergeInfo", { enumerable: true, get: function() {
        return SplitMergeInfo_1.storeSplitMergeInfo;
      } });
      var StateInit_1 = require_StateInit();
      Object.defineProperty(exports, "loadStateInit", { enumerable: true, get: function() {
        return StateInit_1.loadStateInit;
      } });
      Object.defineProperty(exports, "storeStateInit", { enumerable: true, get: function() {
        return StateInit_1.storeStateInit;
      } });
      var StorageInto_1 = require_StorageInto();
      Object.defineProperty(exports, "loadStorageInfo", { enumerable: true, get: function() {
        return StorageInto_1.loadStorageInfo;
      } });
      Object.defineProperty(exports, "storeStorageInfo", { enumerable: true, get: function() {
        return StorageInto_1.storeStorageInfo;
      } });
      var StorageUsed_1 = require_StorageUsed();
      Object.defineProperty(exports, "loadStorageUsed", { enumerable: true, get: function() {
        return StorageUsed_1.loadStorageUsed;
      } });
      Object.defineProperty(exports, "storeStorageUsed", { enumerable: true, get: function() {
        return StorageUsed_1.storeStorageUsed;
      } });
      var StorageUsedShort_1 = require_StorageUsedShort();
      Object.defineProperty(exports, "loadStorageUsedShort", { enumerable: true, get: function() {
        return StorageUsedShort_1.loadStorageUsedShort;
      } });
      Object.defineProperty(exports, "storeStorageUsedShort", { enumerable: true, get: function() {
        return StorageUsedShort_1.storeStorageUsedShort;
      } });
      var TickTock_1 = require_TickTock();
      Object.defineProperty(exports, "loadTickTock", { enumerable: true, get: function() {
        return TickTock_1.loadTickTock;
      } });
      Object.defineProperty(exports, "storeTickTock", { enumerable: true, get: function() {
        return TickTock_1.storeTickTock;
      } });
      var Transaction_1 = require_Transaction();
      Object.defineProperty(exports, "loadTransaction", { enumerable: true, get: function() {
        return Transaction_1.loadTransaction;
      } });
      Object.defineProperty(exports, "storeTransaction", { enumerable: true, get: function() {
        return Transaction_1.storeTransaction;
      } });
      var TransactionActionPhase_1 = require_TransactionActionPhase();
      Object.defineProperty(exports, "loadTransactionActionPhase", { enumerable: true, get: function() {
        return TransactionActionPhase_1.loadTransactionActionPhase;
      } });
      Object.defineProperty(exports, "storeTransactionActionPhase", { enumerable: true, get: function() {
        return TransactionActionPhase_1.storeTransactionActionPhase;
      } });
      var TransactionBouncePhase_1 = require_TransactionBouncePhase();
      Object.defineProperty(exports, "loadTransactionBouncePhase", { enumerable: true, get: function() {
        return TransactionBouncePhase_1.loadTransactionBouncePhase;
      } });
      Object.defineProperty(exports, "storeTransactionBouncePhase", { enumerable: true, get: function() {
        return TransactionBouncePhase_1.storeTransactionBouncePhase;
      } });
      var TransactionComputePhase_1 = require_TransactionComputePhase();
      Object.defineProperty(exports, "loadTransactionComputePhase", { enumerable: true, get: function() {
        return TransactionComputePhase_1.loadTransactionComputePhase;
      } });
      Object.defineProperty(exports, "storeTransactionComputePhase", { enumerable: true, get: function() {
        return TransactionComputePhase_1.storeTransactionComputePhase;
      } });
      var TransactionCreditPhase_1 = require_TransactionCreditPhase();
      Object.defineProperty(exports, "loadTransactionCreditPhase", { enumerable: true, get: function() {
        return TransactionCreditPhase_1.loadTransactionCreditPhase;
      } });
      Object.defineProperty(exports, "storeTransactionCreditPhase", { enumerable: true, get: function() {
        return TransactionCreditPhase_1.storeTransactionCreditPhase;
      } });
      var TransactionDescription_1 = require_TransactionDescription();
      Object.defineProperty(exports, "loadTransactionDescription", { enumerable: true, get: function() {
        return TransactionDescription_1.loadTransactionDescription;
      } });
      Object.defineProperty(exports, "storeTransactionDescription", { enumerable: true, get: function() {
        return TransactionDescription_1.storeTransactionDescription;
      } });
      var TransactionStoragePhase_1 = require_TransactionStoragePhase();
      Object.defineProperty(exports, "loadTransactionStoragePhase", { enumerable: true, get: function() {
        return TransactionStoragePhase_1.loadTransactionStoragePhase;
      } });
      Object.defineProperty(exports, "storeTransactionsStoragePhase", { enumerable: true, get: function() {
        return TransactionStoragePhase_1.storeTransactionsStoragePhase;
      } });
    }
  });

  // node_modules/ton-core/dist/contract/openContract.js
  var require_openContract = __commonJS({
    "node_modules/ton-core/dist/contract/openContract.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.openContract = void 0;
      var Address_1 = require_Address();
      var Cell_1 = require_Cell();
      function openContract(src, factory) {
        let address;
        let init2 = null;
        if (!Address_1.Address.isAddress(src.address)) {
          throw Error("Invalid address");
        }
        address = src.address;
        if (src.init) {
          if (!(src.init.code instanceof Cell_1.Cell)) {
            throw Error("Invalid init.code");
          }
          if (!(src.init.data instanceof Cell_1.Cell)) {
            throw Error("Invalid init.data");
          }
          init2 = src.init;
        }
        let executor = factory({ address, init: init2 });
        return new Proxy(src, {
          get(target, prop) {
            const value = target[prop];
            if (typeof prop === "string" && (prop.startsWith("get") || prop.startsWith("send"))) {
              if (typeof value === "function") {
                return (...args) => value.apply(target, [executor, ...args]);
              }
            }
            return value;
          }
        });
      }
      exports.openContract = openContract;
    }
  });

  // node_modules/ton-core/dist/contract/ComputeError.js
  var require_ComputeError = __commonJS({
    "node_modules/ton-core/dist/contract/ComputeError.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ComputeError = void 0;
      var ComputeError = class extends Error {
        constructor(message, exitCode, opts) {
          super(message);
          this.exitCode = exitCode;
          this.debugLogs = opts && opts.debugLogs ? opts.debugLogs : null;
          this.logs = opts && opts.logs ? opts.logs : null;
          Object.setPrototypeOf(this, ComputeError.prototype);
        }
      };
      exports.ComputeError = ComputeError;
    }
  });

  // node_modules/ton-core/dist/utils/getMethodId.js
  var require_getMethodId = __commonJS({
    "node_modules/ton-core/dist/utils/getMethodId.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getMethodId = void 0;
      var TABLE = new Int16Array([
        0,
        4129,
        8258,
        12387,
        16516,
        20645,
        24774,
        28903,
        33032,
        37161,
        41290,
        45419,
        49548,
        53677,
        57806,
        61935,
        4657,
        528,
        12915,
        8786,
        21173,
        17044,
        29431,
        25302,
        37689,
        33560,
        45947,
        41818,
        54205,
        50076,
        62463,
        58334,
        9314,
        13379,
        1056,
        5121,
        25830,
        29895,
        17572,
        21637,
        42346,
        46411,
        34088,
        38153,
        58862,
        62927,
        50604,
        54669,
        13907,
        9842,
        5649,
        1584,
        30423,
        26358,
        22165,
        18100,
        46939,
        42874,
        38681,
        34616,
        63455,
        59390,
        55197,
        51132,
        18628,
        22757,
        26758,
        30887,
        2112,
        6241,
        10242,
        14371,
        51660,
        55789,
        59790,
        63919,
        35144,
        39273,
        43274,
        47403,
        23285,
        19156,
        31415,
        27286,
        6769,
        2640,
        14899,
        10770,
        56317,
        52188,
        64447,
        60318,
        39801,
        35672,
        47931,
        43802,
        27814,
        31879,
        19684,
        23749,
        11298,
        15363,
        3168,
        7233,
        60846,
        64911,
        52716,
        56781,
        44330,
        48395,
        36200,
        40265,
        32407,
        28342,
        24277,
        20212,
        15891,
        11826,
        7761,
        3696,
        65439,
        61374,
        57309,
        53244,
        48923,
        44858,
        40793,
        36728,
        37256,
        33193,
        45514,
        41451,
        53516,
        49453,
        61774,
        57711,
        4224,
        161,
        12482,
        8419,
        20484,
        16421,
        28742,
        24679,
        33721,
        37784,
        41979,
        46042,
        49981,
        54044,
        58239,
        62302,
        689,
        4752,
        8947,
        13010,
        16949,
        21012,
        25207,
        29270,
        46570,
        42443,
        38312,
        34185,
        62830,
        58703,
        54572,
        50445,
        13538,
        9411,
        5280,
        1153,
        29798,
        25671,
        21540,
        17413,
        42971,
        47098,
        34713,
        38840,
        59231,
        63358,
        50973,
        55100,
        9939,
        14066,
        1681,
        5808,
        26199,
        30326,
        17941,
        22068,
        55628,
        51565,
        63758,
        59695,
        39368,
        35305,
        47498,
        43435,
        22596,
        18533,
        30726,
        26663,
        6336,
        2273,
        14466,
        10403,
        52093,
        56156,
        60223,
        64286,
        35833,
        39896,
        43963,
        48026,
        19061,
        23124,
        27191,
        31254,
        2801,
        6864,
        10931,
        14994,
        64814,
        60687,
        56684,
        52557,
        48554,
        44427,
        40424,
        36297,
        31782,
        27655,
        23652,
        19525,
        15522,
        11395,
        7392,
        3265,
        61215,
        65342,
        53085,
        57212,
        44955,
        49082,
        36825,
        40952,
        28183,
        32310,
        20053,
        24180,
        11923,
        16050,
        3793,
        7920
      ]);
      function crc16(data) {
        if (!(data instanceof Buffer2)) {
          data = Buffer2.from(data);
        }
        let crc = 0;
        for (let index = 0; index < data.length; index++) {
          const byte = data[index];
          crc = (TABLE[(crc >> 8 ^ byte) & 255] ^ crc << 8) & 65535;
        }
        return crc;
      }
      function getMethodId(name) {
        return crc16(name) & 65535 | 65536;
      }
      exports.getMethodId = getMethodId;
    }
  });

  // node_modules/ton-core/dist/crypto/safeSign.js
  var require_safeSign = __commonJS({
    "node_modules/ton-core/dist/crypto/safeSign.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.safeSignVerify = exports.safeSign = void 0;
      var ton_crypto_1 = require_dist();
      var MIN_SEED_LENGTH = 8;
      var MAX_SEED_LENGTH = 64;
      function createSafeSignHash(cell, seed) {
        let seedData = Buffer2.from(seed);
        if (seedData.length > MAX_SEED_LENGTH) {
          throw Error("Seed can	 be longer than 64 bytes");
        }
        if (seedData.length < MIN_SEED_LENGTH) {
          throw Error("Seed must be at least 8 bytes");
        }
        return (0, ton_crypto_1.sha256_sync)(Buffer2.concat([Buffer2.from([255, 255]), seedData, cell.hash()]));
      }
      function safeSign(cell, secretKey, seed = "ton-safe-sign-magic") {
        return (0, ton_crypto_1.sign)(createSafeSignHash(cell, seed), secretKey);
      }
      exports.safeSign = safeSign;
      function safeSignVerify(cell, signature, publicKey, seed = "ton-safe-sign-magic") {
        return (0, ton_crypto_1.signVerify)(createSafeSignHash(cell, seed), signature, publicKey);
      }
      exports.safeSignVerify = safeSignVerify;
    }
  });

  // node_modules/ton-core/dist/index.js
  var require_dist2 = __commonJS({
    "node_modules/ton-core/dist/index.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding2(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.safeSignVerify = exports.safeSign = exports.getMethodId = exports.base32Encode = exports.base32Decode = exports.crc32c = exports.crc16 = exports.fromNano = exports.toNano = exports.ComputeError = exports.openContract = exports.TupleBuilder = exports.TupleReader = exports.serializeTuple = exports.parseTuple = exports.exoticPruned = exports.exoticMerkleUpdate = exports.exoticMerkleProof = exports.Dictionary = exports.Cell = exports.CellType = exports.Slice = exports.beginCell = exports.Builder = exports.BitBuilder = exports.BitReader = exports.BitString = exports.contractAddress = exports.ADNLAddress = exports.ExternalAddress = exports.Address = void 0;
      var Address_1 = require_Address();
      Object.defineProperty(exports, "Address", { enumerable: true, get: function() {
        return Address_1.Address;
      } });
      var ExternalAddress_1 = require_ExternalAddress();
      Object.defineProperty(exports, "ExternalAddress", { enumerable: true, get: function() {
        return ExternalAddress_1.ExternalAddress;
      } });
      var ADNLAddress_1 = require_ADNLAddress();
      Object.defineProperty(exports, "ADNLAddress", { enumerable: true, get: function() {
        return ADNLAddress_1.ADNLAddress;
      } });
      var contractAddress_1 = require_contractAddress();
      Object.defineProperty(exports, "contractAddress", { enumerable: true, get: function() {
        return contractAddress_1.contractAddress;
      } });
      var BitString_1 = require_BitString();
      Object.defineProperty(exports, "BitString", { enumerable: true, get: function() {
        return BitString_1.BitString;
      } });
      var BitReader_1 = require_BitReader();
      Object.defineProperty(exports, "BitReader", { enumerable: true, get: function() {
        return BitReader_1.BitReader;
      } });
      var BitBuilder_1 = require_BitBuilder();
      Object.defineProperty(exports, "BitBuilder", { enumerable: true, get: function() {
        return BitBuilder_1.BitBuilder;
      } });
      var Builder_1 = require_Builder();
      Object.defineProperty(exports, "Builder", { enumerable: true, get: function() {
        return Builder_1.Builder;
      } });
      Object.defineProperty(exports, "beginCell", { enumerable: true, get: function() {
        return Builder_1.beginCell;
      } });
      var Slice_1 = require_Slice();
      Object.defineProperty(exports, "Slice", { enumerable: true, get: function() {
        return Slice_1.Slice;
      } });
      var CellType_1 = require_CellType();
      Object.defineProperty(exports, "CellType", { enumerable: true, get: function() {
        return CellType_1.CellType;
      } });
      var Cell_1 = require_Cell();
      Object.defineProperty(exports, "Cell", { enumerable: true, get: function() {
        return Cell_1.Cell;
      } });
      var Dictionary_1 = require_Dictionary();
      Object.defineProperty(exports, "Dictionary", { enumerable: true, get: function() {
        return Dictionary_1.Dictionary;
      } });
      var exoticMerkleProof_1 = require_exoticMerkleProof();
      Object.defineProperty(exports, "exoticMerkleProof", { enumerable: true, get: function() {
        return exoticMerkleProof_1.exoticMerkleProof;
      } });
      var exoticMerkleUpdate_1 = require_exoticMerkleUpdate();
      Object.defineProperty(exports, "exoticMerkleUpdate", { enumerable: true, get: function() {
        return exoticMerkleUpdate_1.exoticMerkleUpdate;
      } });
      var exoticPruned_1 = require_exoticPruned();
      Object.defineProperty(exports, "exoticPruned", { enumerable: true, get: function() {
        return exoticPruned_1.exoticPruned;
      } });
      var tuple_1 = require_tuple();
      Object.defineProperty(exports, "parseTuple", { enumerable: true, get: function() {
        return tuple_1.parseTuple;
      } });
      Object.defineProperty(exports, "serializeTuple", { enumerable: true, get: function() {
        return tuple_1.serializeTuple;
      } });
      var reader_1 = require_reader();
      Object.defineProperty(exports, "TupleReader", { enumerable: true, get: function() {
        return reader_1.TupleReader;
      } });
      var builder_1 = require_builder();
      Object.defineProperty(exports, "TupleBuilder", { enumerable: true, get: function() {
        return builder_1.TupleBuilder;
      } });
      __exportStar2(require_export(), exports);
      var openContract_1 = require_openContract();
      Object.defineProperty(exports, "openContract", { enumerable: true, get: function() {
        return openContract_1.openContract;
      } });
      var ComputeError_1 = require_ComputeError();
      Object.defineProperty(exports, "ComputeError", { enumerable: true, get: function() {
        return ComputeError_1.ComputeError;
      } });
      var convert_1 = require_convert();
      Object.defineProperty(exports, "toNano", { enumerable: true, get: function() {
        return convert_1.toNano;
      } });
      Object.defineProperty(exports, "fromNano", { enumerable: true, get: function() {
        return convert_1.fromNano;
      } });
      var crc16_1 = require_crc16();
      Object.defineProperty(exports, "crc16", { enumerable: true, get: function() {
        return crc16_1.crc16;
      } });
      var crc32c_1 = require_crc32c();
      Object.defineProperty(exports, "crc32c", { enumerable: true, get: function() {
        return crc32c_1.crc32c;
      } });
      var base32_1 = require_base32();
      Object.defineProperty(exports, "base32Decode", { enumerable: true, get: function() {
        return base32_1.base32Decode;
      } });
      Object.defineProperty(exports, "base32Encode", { enumerable: true, get: function() {
        return base32_1.base32Encode;
      } });
      var getMethodId_1 = require_getMethodId();
      Object.defineProperty(exports, "getMethodId", { enumerable: true, get: function() {
        return getMethodId_1.getMethodId;
      } });
      var safeSign_1 = require_safeSign();
      Object.defineProperty(exports, "safeSign", { enumerable: true, get: function() {
        return safeSign_1.safeSign;
      } });
      Object.defineProperty(exports, "safeSignVerify", { enumerable: true, get: function() {
        return safeSign_1.safeSignVerify;
      } });
    }
  });

  // node_modules/fp-ts/lib/function.js
  var require_function = __commonJS({
    "node_modules/fp-ts/lib/function.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getEndomorphismMonoid = exports.not = exports.SK = exports.hole = exports.pipe = exports.untupled = exports.tupled = exports.absurd = exports.decrement = exports.increment = exports.tuple = exports.flow = exports.flip = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.constant = exports.unsafeCoerce = exports.identity = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;
      var getBooleanAlgebra = function(B) {
        return function() {
          return {
            meet: function(x, y) {
              return function(a) {
                return B.meet(x(a), y(a));
              };
            },
            join: function(x, y) {
              return function(a) {
                return B.join(x(a), y(a));
              };
            },
            zero: function() {
              return B.zero;
            },
            one: function() {
              return B.one;
            },
            implies: function(x, y) {
              return function(a) {
                return B.implies(x(a), y(a));
              };
            },
            not: function(x) {
              return function(a) {
                return B.not(x(a));
              };
            }
          };
        };
      };
      exports.getBooleanAlgebra = getBooleanAlgebra;
      var getSemigroup = function(S) {
        return function() {
          return {
            concat: function(f, g) {
              return function(a) {
                return S.concat(f(a), g(a));
              };
            }
          };
        };
      };
      exports.getSemigroup = getSemigroup;
      var getMonoid = function(M) {
        var getSemigroupM = (0, exports.getSemigroup)(M);
        return function() {
          return {
            concat: getSemigroupM().concat,
            empty: function() {
              return M.empty;
            }
          };
        };
      };
      exports.getMonoid = getMonoid;
      var getSemiring = function(S) {
        return {
          add: function(f, g) {
            return function(x) {
              return S.add(f(x), g(x));
            };
          },
          zero: function() {
            return S.zero;
          },
          mul: function(f, g) {
            return function(x) {
              return S.mul(f(x), g(x));
            };
          },
          one: function() {
            return S.one;
          }
        };
      };
      exports.getSemiring = getSemiring;
      var getRing = function(R) {
        var S = (0, exports.getSemiring)(R);
        return {
          add: S.add,
          mul: S.mul,
          one: S.one,
          zero: S.zero,
          sub: function(f, g) {
            return function(x) {
              return R.sub(f(x), g(x));
            };
          }
        };
      };
      exports.getRing = getRing;
      var apply = function(a) {
        return function(f) {
          return f(a);
        };
      };
      exports.apply = apply;
      function identity(a) {
        return a;
      }
      exports.identity = identity;
      exports.unsafeCoerce = identity;
      function constant(a) {
        return function() {
          return a;
        };
      }
      exports.constant = constant;
      exports.constTrue = constant(true);
      exports.constFalse = constant(false);
      exports.constNull = constant(null);
      exports.constUndefined = constant(void 0);
      exports.constVoid = exports.constUndefined;
      function flip(f) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (args.length > 1) {
            return f(args[1], args[0]);
          }
          return function(a) {
            return f(a)(args[0]);
          };
        };
      }
      exports.flip = flip;
      function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
        switch (arguments.length) {
          case 1:
            return ab;
          case 2:
            return function() {
              return bc(ab.apply(this, arguments));
            };
          case 3:
            return function() {
              return cd(bc(ab.apply(this, arguments)));
            };
          case 4:
            return function() {
              return de(cd(bc(ab.apply(this, arguments))));
            };
          case 5:
            return function() {
              return ef(de(cd(bc(ab.apply(this, arguments)))));
            };
          case 6:
            return function() {
              return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
            };
          case 7:
            return function() {
              return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
            };
          case 8:
            return function() {
              return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
            };
          case 9:
            return function() {
              return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
            };
        }
        return;
      }
      exports.flow = flow;
      function tuple() {
        var t = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          t[_i] = arguments[_i];
        }
        return t;
      }
      exports.tuple = tuple;
      function increment(n) {
        return n + 1;
      }
      exports.increment = increment;
      function decrement(n) {
        return n - 1;
      }
      exports.decrement = decrement;
      function absurd(_) {
        throw new Error("Called `absurd` function which should be uncallable");
      }
      exports.absurd = absurd;
      function tupled(f) {
        return function(a) {
          return f.apply(void 0, a);
        };
      }
      exports.tupled = tupled;
      function untupled(f) {
        return function() {
          var a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
          }
          return f(a);
        };
      }
      exports.untupled = untupled;
      function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
        switch (arguments.length) {
          case 1:
            return a;
          case 2:
            return ab(a);
          case 3:
            return bc(ab(a));
          case 4:
            return cd(bc(ab(a)));
          case 5:
            return de(cd(bc(ab(a))));
          case 6:
            return ef(de(cd(bc(ab(a)))));
          case 7:
            return fg(ef(de(cd(bc(ab(a))))));
          case 8:
            return gh(fg(ef(de(cd(bc(ab(a)))))));
          case 9:
            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
          default: {
            var ret = arguments[0];
            for (var i = 1; i < arguments.length; i++) {
              ret = arguments[i](ret);
            }
            return ret;
          }
        }
      }
      exports.pipe = pipe;
      exports.hole = absurd;
      var SK = function(_, b) {
        return b;
      };
      exports.SK = SK;
      function not(predicate) {
        return function(a) {
          return !predicate(a);
        };
      }
      exports.not = not;
      var getEndomorphismMonoid = function() {
        return {
          concat: function(first, second) {
            return flow(first, second);
          },
          empty: identity
        };
      };
      exports.getEndomorphismMonoid = getEndomorphismMonoid;
    }
  });

  // node_modules/fp-ts/lib/internal.js
  var require_internal = __commonJS({
    "node_modules/fp-ts/lib/internal.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __spreadArray = exports && exports.__spreadArray || function(to, from2, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from2.length, ar; i < l; i++) {
            if (ar || !(i in from2)) {
              if (!ar)
                ar = Array.prototype.slice.call(from2, 0, i);
              ar[i] = from2[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from2));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromReadonlyNonEmptyArray = exports.has = exports.emptyRecord = exports.emptyReadonlyArray = exports.tail = exports.head = exports.isNonEmpty = exports.singleton = exports.right = exports.left = exports.isRight = exports.isLeft = exports.some = exports.none = exports.isSome = exports.isNone = void 0;
      var isNone = function(fa) {
        return fa._tag === "None";
      };
      exports.isNone = isNone;
      var isSome = function(fa) {
        return fa._tag === "Some";
      };
      exports.isSome = isSome;
      exports.none = { _tag: "None" };
      var some = function(a) {
        return { _tag: "Some", value: a };
      };
      exports.some = some;
      var isLeft = function(ma) {
        return ma._tag === "Left";
      };
      exports.isLeft = isLeft;
      var isRight = function(ma) {
        return ma._tag === "Right";
      };
      exports.isRight = isRight;
      var left = function(e) {
        return { _tag: "Left", left: e };
      };
      exports.left = left;
      var right = function(a) {
        return { _tag: "Right", right: a };
      };
      exports.right = right;
      var singleton = function(a) {
        return [a];
      };
      exports.singleton = singleton;
      var isNonEmpty = function(as) {
        return as.length > 0;
      };
      exports.isNonEmpty = isNonEmpty;
      var head = function(as) {
        return as[0];
      };
      exports.head = head;
      var tail = function(as) {
        return as.slice(1);
      };
      exports.tail = tail;
      exports.emptyReadonlyArray = [];
      exports.emptyRecord = {};
      exports.has = Object.prototype.hasOwnProperty;
      var fromReadonlyNonEmptyArray = function(as) {
        return __spreadArray([as[0]], as.slice(1), true);
      };
      exports.fromReadonlyNonEmptyArray = fromReadonlyNonEmptyArray;
    }
  });

  // node_modules/fp-ts/lib/Apply.js
  var require_Apply = __commonJS({
    "node_modules/fp-ts/lib/Apply.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sequenceS = exports.sequenceT = exports.getApplySemigroup = exports.apS = exports.apSecond = exports.apFirst = exports.ap = void 0;
      var function_1 = require_function();
      var _ = __importStar2(require_internal());
      function ap(F, G) {
        return function(fa) {
          return function(fab) {
            return F.ap(F.map(fab, function(gab) {
              return function(ga) {
                return G.ap(gab, ga);
              };
            }), fa);
          };
        };
      }
      exports.ap = ap;
      function apFirst(A) {
        return function(second) {
          return function(first) {
            return A.ap(A.map(first, function(a) {
              return function() {
                return a;
              };
            }), second);
          };
        };
      }
      exports.apFirst = apFirst;
      function apSecond(A) {
        return function(second) {
          return function(first) {
            return A.ap(A.map(first, function() {
              return function(b) {
                return b;
              };
            }), second);
          };
        };
      }
      exports.apSecond = apSecond;
      function apS(F) {
        return function(name, fb) {
          return function(fa) {
            return F.ap(F.map(fa, function(a) {
              return function(b) {
                var _a;
                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
              };
            }), fb);
          };
        };
      }
      exports.apS = apS;
      function getApplySemigroup(F) {
        return function(S) {
          return {
            concat: function(first, second) {
              return F.ap(F.map(first, function(x) {
                return function(y) {
                  return S.concat(x, y);
                };
              }), second);
            }
          };
        };
      }
      exports.getApplySemigroup = getApplySemigroup;
      function curried(f, n, acc) {
        return function(x) {
          var combined = Array(acc.length + 1);
          for (var i = 0; i < acc.length; i++) {
            combined[i] = acc[i];
          }
          combined[acc.length] = x;
          return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);
        };
      }
      var tupleConstructors = {
        1: function(a) {
          return [a];
        },
        2: function(a) {
          return function(b) {
            return [a, b];
          };
        },
        3: function(a) {
          return function(b) {
            return function(c) {
              return [a, b, c];
            };
          };
        },
        4: function(a) {
          return function(b) {
            return function(c) {
              return function(d) {
                return [a, b, c, d];
              };
            };
          };
        },
        5: function(a) {
          return function(b) {
            return function(c) {
              return function(d) {
                return function(e) {
                  return [a, b, c, d, e];
                };
              };
            };
          };
        }
      };
      function getTupleConstructor(len) {
        if (!_.has.call(tupleConstructors, len)) {
          tupleConstructors[len] = curried(function_1.tuple, len - 1, []);
        }
        return tupleConstructors[len];
      }
      function sequenceT(F) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var len = args.length;
          var f = getTupleConstructor(len);
          var fas = F.map(args[0], f);
          for (var i = 1; i < len; i++) {
            fas = F.ap(fas, args[i]);
          }
          return fas;
        };
      }
      exports.sequenceT = sequenceT;
      function getRecordConstructor(keys) {
        var len = keys.length;
        switch (len) {
          case 1:
            return function(a) {
              var _a;
              return _a = {}, _a[keys[0]] = a, _a;
            };
          case 2:
            return function(a) {
              return function(b) {
                var _a;
                return _a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a;
              };
            };
          case 3:
            return function(a) {
              return function(b) {
                return function(c) {
                  var _a;
                  return _a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a;
                };
              };
            };
          case 4:
            return function(a) {
              return function(b) {
                return function(c) {
                  return function(d) {
                    var _a;
                    return _a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a[keys[3]] = d, _a;
                  };
                };
              };
            };
          case 5:
            return function(a) {
              return function(b) {
                return function(c) {
                  return function(d) {
                    return function(e) {
                      var _a;
                      return _a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a[keys[3]] = d, _a[keys[4]] = e, _a;
                    };
                  };
                };
              };
            };
          default:
            return curried(function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var r = {};
              for (var i = 0; i < len; i++) {
                r[keys[i]] = args[i];
              }
              return r;
            }, len - 1, []);
        }
      }
      function sequenceS(F) {
        return function(r) {
          var keys = Object.keys(r);
          var len = keys.length;
          var f = getRecordConstructor(keys);
          var fr = F.map(r[keys[0]], f);
          for (var i = 1; i < len; i++) {
            fr = F.ap(fr, r[keys[i]]);
          }
          return fr;
        };
      }
      exports.sequenceS = sequenceS;
    }
  });

  // node_modules/fp-ts/lib/Functor.js
  var require_Functor = __commonJS({
    "node_modules/fp-ts/lib/Functor.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFunctorComposition = exports.let = exports.bindTo = exports.flap = exports.map = void 0;
      var function_1 = require_function();
      function map(F, G) {
        return function(f) {
          return function(fa) {
            return F.map(fa, function(ga) {
              return G.map(ga, f);
            });
          };
        };
      }
      exports.map = map;
      function flap(F) {
        return function(a) {
          return function(fab) {
            return F.map(fab, function(f) {
              return f(a);
            });
          };
        };
      }
      exports.flap = flap;
      function bindTo(F) {
        return function(name) {
          return function(fa) {
            return F.map(fa, function(a) {
              var _a;
              return _a = {}, _a[name] = a, _a;
            });
          };
        };
      }
      exports.bindTo = bindTo;
      function let_(F) {
        return function(name, f) {
          return function(fa) {
            return F.map(fa, function(a) {
              var _a;
              return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));
            });
          };
        };
      }
      exports.let = let_;
      function getFunctorComposition(F, G) {
        var _map = map(F, G);
        return {
          map: function(fga, f) {
            return (0, function_1.pipe)(fga, _map(f));
          }
        };
      }
      exports.getFunctorComposition = getFunctorComposition;
    }
  });

  // node_modules/fp-ts/lib/Applicative.js
  var require_Applicative = __commonJS({
    "node_modules/fp-ts/lib/Applicative.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getApplicativeComposition = exports.getApplicativeMonoid = void 0;
      var Apply_1 = require_Apply();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      function getApplicativeMonoid(F) {
        var f = (0, Apply_1.getApplySemigroup)(F);
        return function(M) {
          return {
            concat: f(M).concat,
            empty: F.of(M.empty)
          };
        };
      }
      exports.getApplicativeMonoid = getApplicativeMonoid;
      function getApplicativeComposition(F, G) {
        var map = (0, Functor_1.getFunctorComposition)(F, G).map;
        var _ap = (0, Apply_1.ap)(F, G);
        return {
          map,
          of: function(a) {
            return F.of(G.of(a));
          },
          ap: function(fgab, fga) {
            return (0, function_1.pipe)(fgab, _ap(fga));
          }
        };
      }
      exports.getApplicativeComposition = getApplicativeComposition;
    }
  });

  // node_modules/fp-ts/lib/Chain.js
  var require_Chain = __commonJS({
    "node_modules/fp-ts/lib/Chain.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bind = exports.chainFirst = void 0;
      function chainFirst(M) {
        return function(f) {
          return function(first) {
            return M.chain(first, function(a) {
              return M.map(f(a), function() {
                return a;
              });
            });
          };
        };
      }
      exports.chainFirst = chainFirst;
      function bind(M) {
        return function(name, f) {
          return function(ma) {
            return M.chain(ma, function(a) {
              return M.map(f(a), function(b) {
                var _a;
                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
              });
            });
          };
        };
      }
      exports.bind = bind;
    }
  });

  // node_modules/fp-ts/lib/ChainRec.js
  var require_ChainRec = __commonJS({
    "node_modules/fp-ts/lib/ChainRec.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.tailRec = void 0;
      var tailRec = function(startWith, f) {
        var ab = f(startWith);
        while (ab._tag === "Left") {
          ab = f(ab.left);
        }
        return ab.right;
      };
      exports.tailRec = tailRec;
    }
  });

  // node_modules/fp-ts/lib/FromEither.js
  var require_FromEither = __commonJS({
    "node_modules/fp-ts/lib/FromEither.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.filterOrElse = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromPredicate = exports.fromOption = void 0;
      var Chain_1 = require_Chain();
      var function_1 = require_function();
      var _ = __importStar2(require_internal());
      function fromOption(F) {
        return function(onNone) {
          return function(ma) {
            return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value));
          };
        };
      }
      exports.fromOption = fromOption;
      function fromPredicate(F) {
        return function(predicate, onFalse) {
          return function(a) {
            return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
          };
        };
      }
      exports.fromPredicate = fromPredicate;
      function fromOptionK(F) {
        var fromOptionF = fromOption(F);
        return function(onNone) {
          var from2 = fromOptionF(onNone);
          return function(f) {
            return (0, function_1.flow)(f, from2);
          };
        };
      }
      exports.fromOptionK = fromOptionK;
      function chainOptionK(F, M) {
        var fromOptionKF = fromOptionK(F);
        return function(onNone) {
          var from2 = fromOptionKF(onNone);
          return function(f) {
            return function(ma) {
              return M.chain(ma, from2(f));
            };
          };
        };
      }
      exports.chainOptionK = chainOptionK;
      function fromEitherK(F) {
        return function(f) {
          return (0, function_1.flow)(f, F.fromEither);
        };
      }
      exports.fromEitherK = fromEitherK;
      function chainEitherK(F, M) {
        var fromEitherKF = fromEitherK(F);
        return function(f) {
          return function(ma) {
            return M.chain(ma, fromEitherKF(f));
          };
        };
      }
      exports.chainEitherK = chainEitherK;
      function chainFirstEitherK(F, M) {
        return (0, function_1.flow)(fromEitherK(F), (0, Chain_1.chainFirst)(M));
      }
      exports.chainFirstEitherK = chainFirstEitherK;
      function filterOrElse(F, M) {
        return function(predicate, onFalse) {
          return function(ma) {
            return M.chain(ma, function(a) {
              return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
            });
          };
        };
      }
      exports.filterOrElse = filterOrElse;
    }
  });

  // node_modules/fp-ts/lib/Separated.js
  var require_Separated = __commonJS({
    "node_modules/fp-ts/lib/Separated.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.right = exports.left = exports.flap = exports.Functor = exports.Bifunctor = exports.URI = exports.bimap = exports.mapLeft = exports.map = exports.separated = void 0;
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var separated = function(left2, right2) {
        return { left: left2, right: right2 };
      };
      exports.separated = separated;
      var _map = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f));
      };
      var _mapLeft = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f));
      };
      var _bimap = function(fa, g, f) {
        return (0, function_1.pipe)(fa, (0, exports.bimap)(g, f));
      };
      var map = function(f) {
        return function(fa) {
          return (0, exports.separated)((0, exports.left)(fa), f((0, exports.right)(fa)));
        };
      };
      exports.map = map;
      var mapLeft = function(f) {
        return function(fa) {
          return (0, exports.separated)(f((0, exports.left)(fa)), (0, exports.right)(fa));
        };
      };
      exports.mapLeft = mapLeft;
      var bimap = function(f, g) {
        return function(fa) {
          return (0, exports.separated)(f((0, exports.left)(fa)), g((0, exports.right)(fa)));
        };
      };
      exports.bimap = bimap;
      exports.URI = "Separated";
      exports.Bifunctor = {
        URI: exports.URI,
        mapLeft: _mapLeft,
        bimap: _bimap
      };
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      var left = function(s) {
        return s.left;
      };
      exports.left = left;
      var right = function(s) {
        return s.right;
      };
      exports.right = right;
    }
  });

  // node_modules/fp-ts/lib/Witherable.js
  var require_Witherable = __commonJS({
    "node_modules/fp-ts/lib/Witherable.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.filterE = exports.witherDefault = exports.wiltDefault = void 0;
      var _ = __importStar2(require_internal());
      function wiltDefault(T, C) {
        return function(F) {
          var traverseF = T.traverse(F);
          return function(wa, f) {
            return F.map(traverseF(wa, f), C.separate);
          };
        };
      }
      exports.wiltDefault = wiltDefault;
      function witherDefault(T, C) {
        return function(F) {
          var traverseF = T.traverse(F);
          return function(wa, f) {
            return F.map(traverseF(wa, f), C.compact);
          };
        };
      }
      exports.witherDefault = witherDefault;
      function filterE(W) {
        return function(F) {
          var witherF = W.wither(F);
          return function(predicate) {
            return function(ga) {
              return witherF(ga, function(a) {
                return F.map(predicate(a), function(b) {
                  return b ? _.some(a) : _.none;
                });
              });
            };
          };
        };
      }
      exports.filterE = filterE;
    }
  });

  // node_modules/fp-ts/lib/Either.js
  var require_Either = __commonJS({
    "node_modules/fp-ts/lib/Either.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fold = exports.match = exports.foldW = exports.matchW = exports.isRight = exports.isLeft = exports.fromOption = exports.fromPredicate = exports.FromEither = exports.MonadThrow = exports.throwError = exports.ChainRec = exports.Extend = exports.extend = exports.Alt = exports.alt = exports.altW = exports.Bifunctor = exports.mapLeft = exports.bimap = exports.Traversable = exports.sequence = exports.traverse = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.chain = exports.chainW = exports.Applicative = exports.Apply = exports.ap = exports.apW = exports.Pointed = exports.of = exports.Functor = exports.map = exports.getAltValidation = exports.getApplicativeValidation = exports.getWitherable = exports.getFilterable = exports.getCompactable = exports.getSemigroup = exports.getEq = exports.getShow = exports.URI = exports.right = exports.left = void 0;
      exports.getValidation = exports.getValidationMonoid = exports.getValidationSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.either = exports.stringifyJSON = exports.parseJSON = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toError = exports.toUnion = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.orElse = exports.orElseW = exports.swap = exports.filterOrElseW = exports.filterOrElse = exports.chainOptionK = exports.fromOptionK = exports.duplicate = exports.flatten = exports.flattenW = exports.chainFirstW = exports.chainFirst = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = void 0;
      var Applicative_1 = require_Applicative();
      var Apply_1 = require_Apply();
      var Chain_1 = require_Chain();
      var ChainRec_1 = require_ChainRec();
      var FromEither_1 = require_FromEither();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar2(require_internal());
      var Separated_1 = require_Separated();
      var Witherable_1 = require_Witherable();
      exports.left = _.left;
      exports.right = _.right;
      var _map = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f));
      };
      var _ap = function(fab, fa) {
        return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
      };
      var _chain = function(ma, f) {
        return (0, function_1.pipe)(ma, (0, exports.chain)(f));
      };
      var _reduce = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f));
      };
      var _foldMap = function(M) {
        return function(fa, f) {
          var foldMapM = (0, exports.foldMap)(M);
          return (0, function_1.pipe)(fa, foldMapM(f));
        };
      };
      var _reduceRight = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f));
      };
      var _traverse = function(F) {
        var traverseF = (0, exports.traverse)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseF(f));
        };
      };
      var _bimap = function(fa, f, g) {
        return (0, function_1.pipe)(fa, (0, exports.bimap)(f, g));
      };
      var _mapLeft = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f));
      };
      var _alt = function(fa, that) {
        return (0, function_1.pipe)(fa, (0, exports.alt)(that));
      };
      var _extend = function(wa, f) {
        return (0, function_1.pipe)(wa, (0, exports.extend)(f));
      };
      var _chainRec = function(a, f) {
        return (0, ChainRec_1.tailRec)(f(a), function(e) {
          return (0, exports.isLeft)(e) ? (0, exports.right)((0, exports.left)(e.left)) : (0, exports.isLeft)(e.right) ? (0, exports.left)(f(e.right.left)) : (0, exports.right)((0, exports.right)(e.right.right));
        });
      };
      exports.URI = "Either";
      var getShow = function(SE, SA) {
        return {
          show: function(ma) {
            return (0, exports.isLeft)(ma) ? "left(".concat(SE.show(ma.left), ")") : "right(".concat(SA.show(ma.right), ")");
          }
        };
      };
      exports.getShow = getShow;
      var getEq = function(EL, EA) {
        return {
          equals: function(x, y) {
            return x === y || ((0, exports.isLeft)(x) ? (0, exports.isLeft)(y) && EL.equals(x.left, y.left) : (0, exports.isRight)(y) && EA.equals(x.right, y.right));
          }
        };
      };
      exports.getEq = getEq;
      var getSemigroup = function(S) {
        return {
          concat: function(x, y) {
            return (0, exports.isLeft)(y) ? x : (0, exports.isLeft)(x) ? y : (0, exports.right)(S.concat(x.right, y.right));
          }
        };
      };
      exports.getSemigroup = getSemigroup;
      var getCompactable = function(M) {
        var empty = (0, exports.left)(M.empty);
        return {
          URI: exports.URI,
          _E: void 0,
          compact: function(ma) {
            return (0, exports.isLeft)(ma) ? ma : ma.right._tag === "None" ? empty : (0, exports.right)(ma.right.value);
          },
          separate: function(ma) {
            return (0, exports.isLeft)(ma) ? (0, Separated_1.separated)(ma, ma) : (0, exports.isLeft)(ma.right) ? (0, Separated_1.separated)((0, exports.right)(ma.right.left), empty) : (0, Separated_1.separated)(empty, (0, exports.right)(ma.right.right));
          }
        };
      };
      exports.getCompactable = getCompactable;
      var getFilterable = function(M) {
        var empty = (0, exports.left)(M.empty);
        var _a = (0, exports.getCompactable)(M), compact = _a.compact, separate = _a.separate;
        var filter = function(ma, predicate) {
          return (0, exports.isLeft)(ma) ? ma : predicate(ma.right) ? ma : empty;
        };
        var partition = function(ma, p) {
          return (0, exports.isLeft)(ma) ? (0, Separated_1.separated)(ma, ma) : p(ma.right) ? (0, Separated_1.separated)(empty, (0, exports.right)(ma.right)) : (0, Separated_1.separated)((0, exports.right)(ma.right), empty);
        };
        return {
          URI: exports.URI,
          _E: void 0,
          map: _map,
          compact,
          separate,
          filter,
          filterMap: function(ma, f) {
            if ((0, exports.isLeft)(ma)) {
              return ma;
            }
            var ob = f(ma.right);
            return ob._tag === "None" ? empty : (0, exports.right)(ob.value);
          },
          partition,
          partitionMap: function(ma, f) {
            if ((0, exports.isLeft)(ma)) {
              return (0, Separated_1.separated)(ma, ma);
            }
            var e = f(ma.right);
            return (0, exports.isLeft)(e) ? (0, Separated_1.separated)((0, exports.right)(e.left), empty) : (0, Separated_1.separated)(empty, (0, exports.right)(e.right));
          }
        };
      };
      exports.getFilterable = getFilterable;
      var getWitherable = function(M) {
        var F_ = (0, exports.getFilterable)(M);
        var C = (0, exports.getCompactable)(M);
        return {
          URI: exports.URI,
          _E: void 0,
          map: _map,
          compact: F_.compact,
          separate: F_.separate,
          filter: F_.filter,
          filterMap: F_.filterMap,
          partition: F_.partition,
          partitionMap: F_.partitionMap,
          traverse: _traverse,
          sequence: exports.sequence,
          reduce: _reduce,
          foldMap: _foldMap,
          reduceRight: _reduceRight,
          wither: (0, Witherable_1.witherDefault)(exports.Traversable, C),
          wilt: (0, Witherable_1.wiltDefault)(exports.Traversable, C)
        };
      };
      exports.getWitherable = getWitherable;
      var getApplicativeValidation = function(SE) {
        return {
          URI: exports.URI,
          _E: void 0,
          map: _map,
          ap: function(fab, fa) {
            return (0, exports.isLeft)(fab) ? (0, exports.isLeft)(fa) ? (0, exports.left)(SE.concat(fab.left, fa.left)) : fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
          },
          of: exports.of
        };
      };
      exports.getApplicativeValidation = getApplicativeValidation;
      var getAltValidation = function(SE) {
        return {
          URI: exports.URI,
          _E: void 0,
          map: _map,
          alt: function(me, that) {
            if ((0, exports.isRight)(me)) {
              return me;
            }
            var ea = that();
            return (0, exports.isLeft)(ea) ? (0, exports.left)(SE.concat(me.left, ea.left)) : ea;
          }
        };
      };
      exports.getAltValidation = getAltValidation;
      var map = function(f) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? fa : (0, exports.right)(f(fa.right));
        };
      };
      exports.map = map;
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.of = exports.right;
      exports.Pointed = {
        URI: exports.URI,
        of: exports.of
      };
      var apW = function(fa) {
        return function(fab) {
          return (0, exports.isLeft)(fab) ? fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
        };
      };
      exports.apW = apW;
      exports.ap = exports.apW;
      exports.Apply = {
        URI: exports.URI,
        map: _map,
        ap: _ap
      };
      exports.Applicative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of
      };
      var chainW = function(f) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? ma : f(ma.right);
        };
      };
      exports.chainW = chainW;
      exports.chain = exports.chainW;
      exports.Chain = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain
      };
      exports.Monad = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain
      };
      var reduce = function(b, f) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? b : f(b, fa.right);
        };
      };
      exports.reduce = reduce;
      var foldMap = function(M) {
        return function(f) {
          return function(fa) {
            return (0, exports.isLeft)(fa) ? M.empty : f(fa.right);
          };
        };
      };
      exports.foldMap = foldMap;
      var reduceRight = function(b, f) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? b : f(fa.right, b);
        };
      };
      exports.reduceRight = reduceRight;
      exports.Foldable = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight
      };
      var traverse = function(F) {
        return function(f) {
          return function(ta) {
            return (0, exports.isLeft)(ta) ? F.of((0, exports.left)(ta.left)) : F.map(f(ta.right), exports.right);
          };
        };
      };
      exports.traverse = traverse;
      var sequence = function(F) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? F.of((0, exports.left)(ma.left)) : F.map(ma.right, exports.right);
        };
      };
      exports.sequence = sequence;
      exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence
      };
      var bimap = function(f, g) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : (0, exports.right)(g(fa.right));
        };
      };
      exports.bimap = bimap;
      var mapLeft = function(f) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : fa;
        };
      };
      exports.mapLeft = mapLeft;
      exports.Bifunctor = {
        URI: exports.URI,
        bimap: _bimap,
        mapLeft: _mapLeft
      };
      var altW = function(that) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? that() : fa;
        };
      };
      exports.altW = altW;
      exports.alt = exports.altW;
      exports.Alt = {
        URI: exports.URI,
        map: _map,
        alt: _alt
      };
      var extend = function(f) {
        return function(wa) {
          return (0, exports.isLeft)(wa) ? wa : (0, exports.right)(f(wa));
        };
      };
      exports.extend = extend;
      exports.Extend = {
        URI: exports.URI,
        map: _map,
        extend: _extend
      };
      exports.ChainRec = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain,
        chainRec: _chainRec
      };
      exports.throwError = exports.left;
      exports.MonadThrow = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain,
        throwError: exports.throwError
      };
      exports.FromEither = {
        URI: exports.URI,
        fromEither: function_1.identity
      };
      exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
      exports.fromOption = /* @__PURE__ */ (0, FromEither_1.fromOption)(exports.FromEither);
      exports.isLeft = _.isLeft;
      exports.isRight = _.isRight;
      var matchW = function(onLeft, onRight) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? onLeft(ma.left) : onRight(ma.right);
        };
      };
      exports.matchW = matchW;
      exports.foldW = exports.matchW;
      exports.match = exports.matchW;
      exports.fold = exports.match;
      var getOrElseW = function(onLeft) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma.right;
        };
      };
      exports.getOrElseW = getOrElseW;
      exports.getOrElse = exports.getOrElseW;
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
      exports.apFirstW = exports.apFirst;
      exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
      exports.apSecondW = exports.apSecond;
      exports.chainFirst = /* @__PURE__ */ (0, Chain_1.chainFirst)(exports.Chain);
      exports.chainFirstW = exports.chainFirst;
      exports.flattenW = /* @__PURE__ */ (0, exports.chainW)(function_1.identity);
      exports.flatten = exports.flattenW;
      exports.duplicate = (0, exports.extend)(function_1.identity);
      exports.fromOptionK = /* @__PURE__ */ (0, FromEither_1.fromOptionK)(exports.FromEither);
      exports.chainOptionK = (0, FromEither_1.chainOptionK)(exports.FromEither, exports.Chain);
      exports.filterOrElse = (0, FromEither_1.filterOrElse)(exports.FromEither, exports.Chain);
      exports.filterOrElseW = exports.filterOrElse;
      var swap2 = function(ma) {
        return (0, exports.isLeft)(ma) ? (0, exports.right)(ma.left) : (0, exports.left)(ma.right);
      };
      exports.swap = swap2;
      var orElseW = function(onLeft) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma;
        };
      };
      exports.orElseW = orElseW;
      exports.orElse = exports.orElseW;
      var fromNullable = function(e) {
        return function(a) {
          return a == null ? (0, exports.left)(e) : (0, exports.right)(a);
        };
      };
      exports.fromNullable = fromNullable;
      var tryCatch = function(f, onThrow) {
        try {
          return (0, exports.right)(f());
        } catch (e) {
          return (0, exports.left)(onThrow(e));
        }
      };
      exports.tryCatch = tryCatch;
      var tryCatchK = function(f, onThrow) {
        return function() {
          var a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
          }
          return (0, exports.tryCatch)(function() {
            return f.apply(void 0, a);
          }, onThrow);
        };
      };
      exports.tryCatchK = tryCatchK;
      var fromNullableK = function(e) {
        var from2 = (0, exports.fromNullable)(e);
        return function(f) {
          return (0, function_1.flow)(f, from2);
        };
      };
      exports.fromNullableK = fromNullableK;
      var chainNullableK = function(e) {
        var from2 = (0, exports.fromNullableK)(e);
        return function(f) {
          return (0, exports.chain)(from2(f));
        };
      };
      exports.chainNullableK = chainNullableK;
      exports.toUnion = (0, exports.foldW)(function_1.identity, function_1.identity);
      function toError(e) {
        return e instanceof Error ? e : new Error(String(e));
      }
      exports.toError = toError;
      function elem(E) {
        return function(a, ma) {
          if (ma === void 0) {
            var elemE_1 = elem(E);
            return function(ma2) {
              return elemE_1(a, ma2);
            };
          }
          return (0, exports.isLeft)(ma) ? false : E.equals(a, ma.right);
        };
      }
      exports.elem = elem;
      var exists = function(predicate) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? false : predicate(ma.right);
        };
      };
      exports.exists = exists;
      exports.Do = (0, exports.of)(_.emptyRecord);
      exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
      var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
      exports.let = let_;
      exports.bind = (0, Chain_1.bind)(exports.Chain);
      exports.bindW = exports.bind;
      exports.apS = (0, Apply_1.apS)(exports.Apply);
      exports.apSW = exports.apS;
      exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
      var traverseReadonlyNonEmptyArrayWithIndex = function(f) {
        return function(as) {
          var e = f(0, _.head(as));
          if ((0, exports.isLeft)(e)) {
            return e;
          }
          var out = [e.right];
          for (var i = 1; i < as.length; i++) {
            var e_1 = f(i, as[i]);
            if ((0, exports.isLeft)(e_1)) {
              return e_1;
            }
            out.push(e_1.right);
          }
          return (0, exports.right)(out);
        };
      };
      exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
      var traverseReadonlyArrayWithIndex = function(f) {
        var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);
        return function(as) {
          return _.isNonEmpty(as) ? g(as) : exports.ApT;
        };
      };
      exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
      exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
      var traverseArray = function(f) {
        return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.traverseArray = traverseArray;
      exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
      function parseJSON(s, onError) {
        return (0, exports.tryCatch)(function() {
          return JSON.parse(s);
        }, onError);
      }
      exports.parseJSON = parseJSON;
      var stringifyJSON = function(u, onError) {
        return (0, exports.tryCatch)(function() {
          var s = JSON.stringify(u);
          if (typeof s !== "string") {
            throw new Error("Converting unsupported structure to JSON");
          }
          return s;
        }, onError);
      };
      exports.stringifyJSON = stringifyJSON;
      exports.either = {
        URI: exports.URI,
        map: _map,
        of: exports.of,
        ap: _ap,
        chain: _chain,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        bimap: _bimap,
        mapLeft: _mapLeft,
        alt: _alt,
        extend: _extend,
        chainRec: _chainRec,
        throwError: exports.throwError
      };
      exports.getApplySemigroup = /* @__PURE__ */ (0, Apply_1.getApplySemigroup)(exports.Apply);
      exports.getApplyMonoid = /* @__PURE__ */ (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);
      var getValidationSemigroup = function(SE, SA) {
        return (0, Apply_1.getApplySemigroup)((0, exports.getApplicativeValidation)(SE))(SA);
      };
      exports.getValidationSemigroup = getValidationSemigroup;
      var getValidationMonoid = function(SE, MA) {
        return (0, Applicative_1.getApplicativeMonoid)((0, exports.getApplicativeValidation)(SE))(MA);
      };
      exports.getValidationMonoid = getValidationMonoid;
      function getValidation(SE) {
        var ap = (0, exports.getApplicativeValidation)(SE).ap;
        var alt = (0, exports.getAltValidation)(SE).alt;
        return {
          URI: exports.URI,
          _E: void 0,
          map: _map,
          of: exports.of,
          chain: _chain,
          bimap: _bimap,
          mapLeft: _mapLeft,
          reduce: _reduce,
          foldMap: _foldMap,
          reduceRight: _reduceRight,
          extend: _extend,
          traverse: _traverse,
          sequence: exports.sequence,
          chainRec: _chainRec,
          throwError: exports.throwError,
          ap,
          alt
        };
      }
      exports.getValidation = getValidation;
    }
  });

  // node_modules/io-ts/lib/index.js
  var require_lib = __commonJS({
    "node_modules/io-ts/lib/index.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __extends2 = exports && exports.__extends || function() {
        var extendStatics2 = function(d, b) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics2(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics2(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __assign2 = exports && exports.__assign || function() {
        __assign2 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign2.apply(this, arguments);
      };
      var __spreadArray = exports && exports.__spreadArray || function(to, from2, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from2.length, ar; i < l; i++) {
            if (ar || !(i in from2)) {
              if (!ar)
                ar = Array.prototype.slice.call(from2, 0, i);
              ar[i] = from2[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from2));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.partial = exports.PartialType = exports.type = exports.InterfaceType = exports.array = exports.ArrayType = exports.recursion = exports.RecursiveType = exports.Int = exports.brand = exports.RefinementType = exports.keyof = exports.KeyofType = exports.literal = exports.LiteralType = exports.void = exports.undefined = exports.null = exports.UnknownRecord = exports.AnyDictionaryType = exports.UnknownArray = exports.AnyArrayType = exports.boolean = exports.BooleanType = exports.bigint = exports.BigIntType = exports.number = exports.NumberType = exports.string = exports.StringType = exports.unknown = exports.UnknownType = exports.voidType = exports.VoidType = exports.UndefinedType = exports.nullType = exports.NullType = exports.getIndex = exports.getTags = exports.emptyTags = exports.mergeAll = exports.getDomainKeys = exports.appendContext = exports.getContextEntry = exports.getFunctionName = exports.identity = exports.Type = exports.success = exports.failure = exports.failures = void 0;
      exports.alias = exports.clean = exports.StrictType = exports.dictionary = exports.Integer = exports.refinement = exports.object = exports.ObjectType = exports.Dictionary = exports.any = exports.AnyType = exports.never = exports.NeverType = exports.getDefaultContext = exports.getValidationError = exports.interface = exports.Array = exports.taggedUnion = exports.TaggedUnionType = exports.Function = exports.FunctionType = exports.exact = exports.ExactType = exports.strict = exports.readonlyArray = exports.ReadonlyArrayType = exports.readonly = exports.ReadonlyType = exports.tuple = exports.TupleType = exports.intersection = exports.IntersectionType = exports.union = exports.UnionType = exports.record = exports.DictionaryType = void 0;
      var Either_1 = require_Either();
      exports.failures = Either_1.left;
      var failure = function(value, context, message) {
        return (0, exports.failures)([{ value, context, message }]);
      };
      exports.failure = failure;
      exports.success = Either_1.right;
      var Type = function() {
        function Type2(name, is, validate, encode) {
          this.name = name;
          this.is = is;
          this.validate = validate;
          this.encode = encode;
          this.decode = this.decode.bind(this);
        }
        Type2.prototype.pipe = function(ab, name) {
          var _this = this;
          if (name === void 0) {
            name = "pipe(".concat(this.name, ", ").concat(ab.name, ")");
          }
          return new Type2(name, ab.is, function(i, c) {
            var e = _this.validate(i, c);
            if ((0, Either_1.isLeft)(e)) {
              return e;
            }
            return ab.validate(e.right, c);
          }, this.encode === exports.identity && ab.encode === exports.identity ? exports.identity : function(b) {
            return _this.encode(ab.encode(b));
          });
        };
        Type2.prototype.asDecoder = function() {
          return this;
        };
        Type2.prototype.asEncoder = function() {
          return this;
        };
        Type2.prototype.decode = function(i) {
          return this.validate(i, [{ key: "", type: this, actual: i }]);
        };
        return Type2;
      }();
      exports.Type = Type;
      var identity = function(a) {
        return a;
      };
      exports.identity = identity;
      function getFunctionName(f) {
        return f.displayName || f.name || "<function".concat(f.length, ">");
      }
      exports.getFunctionName = getFunctionName;
      function getContextEntry(key, decoder) {
        return { key, type: decoder };
      }
      exports.getContextEntry = getContextEntry;
      function appendContext(c, key, decoder, actual) {
        var len = c.length;
        var r = Array(len + 1);
        for (var i = 0; i < len; i++) {
          r[i] = c[i];
        }
        r[len] = { key, type: decoder, actual };
        return r;
      }
      exports.appendContext = appendContext;
      function pushAll(xs, ys) {
        var l = ys.length;
        for (var i = 0; i < l; i++) {
          xs.push(ys[i]);
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function getNameFromProps(props) {
        return Object.keys(props).map(function(k) {
          return "".concat(k, ": ").concat(props[k].name);
        }).join(", ");
      }
      function useIdentity(codecs) {
        for (var i = 0; i < codecs.length; i++) {
          if (codecs[i].encode !== exports.identity) {
            return false;
          }
        }
        return true;
      }
      function getInterfaceTypeName(props) {
        return "{ ".concat(getNameFromProps(props), " }");
      }
      function getPartialTypeName(inner) {
        return "Partial<".concat(inner, ">");
      }
      function enumerableRecord(keys, domain, codomain, name) {
        if (name === void 0) {
          name = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }");
        }
        var len = keys.length;
        return new DictionaryType(name, function(u) {
          return exports.UnknownRecord.is(u) && keys.every(function(k) {
            return codomain.is(u[k]);
          });
        }, function(u, c) {
          var e = exports.UnknownRecord.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var o = e.right;
          var a = {};
          var errors = [];
          var changed = false;
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            var ok = o[k];
            var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
            if ((0, Either_1.isLeft)(codomainResult)) {
              pushAll(errors, codomainResult.left);
            } else {
              var vok = codomainResult.right;
              changed = changed || vok !== ok;
              a[k] = vok;
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(changed || Object.keys(o).length !== len ? a : o);
        }, codomain.encode === exports.identity ? exports.identity : function(a) {
          var s = {};
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            s[k] = codomain.encode(a[k]);
          }
          return s;
        }, domain, codomain);
      }
      function getDomainKeys(domain) {
        var _a;
        if (isLiteralC(domain)) {
          var literal_1 = domain.value;
          if (exports.string.is(literal_1)) {
            return _a = {}, _a[literal_1] = null, _a;
          }
        } else if (isKeyofC(domain)) {
          return domain.keys;
        } else if (isUnionC(domain)) {
          var keys = domain.types.map(function(type2) {
            return getDomainKeys(type2);
          });
          return keys.some(undefinedType.is) ? void 0 : Object.assign.apply(Object, __spreadArray([{}], keys, false));
        }
        return void 0;
      }
      exports.getDomainKeys = getDomainKeys;
      function nonEnumerableRecord(domain, codomain, name) {
        if (name === void 0) {
          name = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }");
        }
        return new DictionaryType(name, function(u) {
          if (exports.UnknownRecord.is(u)) {
            return Object.keys(u).every(function(k) {
              return domain.is(k) && codomain.is(u[k]);
            });
          }
          return isAnyC(codomain) && Array.isArray(u);
        }, function(u, c) {
          if (exports.UnknownRecord.is(u)) {
            var a = {};
            var errors = [];
            var keys = Object.keys(u);
            var len = keys.length;
            var changed = false;
            for (var i = 0; i < len; i++) {
              var k = keys[i];
              var ok = u[k];
              var domainResult = domain.validate(k, appendContext(c, k, domain, k));
              if ((0, Either_1.isLeft)(domainResult)) {
                pushAll(errors, domainResult.left);
              } else {
                var vk = domainResult.right;
                changed = changed || vk !== k;
                k = vk;
                var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
                if ((0, Either_1.isLeft)(codomainResult)) {
                  pushAll(errors, codomainResult.left);
                } else {
                  var vok = codomainResult.right;
                  changed = changed || vok !== ok;
                  a[k] = vok;
                }
              }
            }
            return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(changed ? a : u);
          }
          if (isAnyC(codomain) && Array.isArray(u)) {
            return (0, exports.success)(u);
          }
          return (0, exports.failure)(u, c);
        }, domain.encode === exports.identity && codomain.encode === exports.identity ? exports.identity : function(a) {
          var s = {};
          var keys = Object.keys(a);
          var len = keys.length;
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            s[String(domain.encode(k))] = codomain.encode(a[k]);
          }
          return s;
        }, domain, codomain);
      }
      function getUnionName(codecs) {
        return "(" + codecs.map(function(type2) {
          return type2.name;
        }).join(" | ") + ")";
      }
      function mergeAll(base, us) {
        var equal = true;
        var primitive = true;
        var baseIsNotADictionary = !exports.UnknownRecord.is(base);
        for (var _i = 0, us_1 = us; _i < us_1.length; _i++) {
          var u = us_1[_i];
          if (u !== base) {
            equal = false;
          }
          if (exports.UnknownRecord.is(u)) {
            primitive = false;
          }
        }
        if (equal) {
          return base;
        } else if (primitive) {
          return us[us.length - 1];
        }
        var r = {};
        for (var _a = 0, us_2 = us; _a < us_2.length; _a++) {
          var u = us_2[_a];
          for (var k in u) {
            if (!hasOwnProperty.call(r, k) || baseIsNotADictionary || u[k] !== base[k]) {
              r[k] = u[k];
            }
          }
        }
        return r;
      }
      exports.mergeAll = mergeAll;
      function getProps(codec) {
        switch (codec._tag) {
          case "RefinementType":
          case "ReadonlyType":
            return getProps(codec.type);
          case "InterfaceType":
          case "StrictType":
          case "PartialType":
            return codec.props;
          case "IntersectionType":
            return codec.types.reduce(function(props, type2) {
              return Object.assign(props, getProps(type2));
            }, {});
        }
      }
      function stripKeys(o, props) {
        var keys = Object.getOwnPropertyNames(o);
        var shouldStrip = false;
        var r = {};
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (!hasOwnProperty.call(props, key)) {
            shouldStrip = true;
          } else {
            r[key] = o[key];
          }
        }
        return shouldStrip ? r : o;
      }
      function getExactTypeName(codec) {
        if (isTypeC(codec)) {
          return "{| ".concat(getNameFromProps(codec.props), " |}");
        } else if (isPartialC(codec)) {
          return getPartialTypeName("{| ".concat(getNameFromProps(codec.props), " |}"));
        }
        return "Exact<".concat(codec.name, ">");
      }
      function isNonEmpty(as) {
        return as.length > 0;
      }
      exports.emptyTags = {};
      function intersect(a, b) {
        var r = [];
        for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
          var v = a_1[_i];
          if (b.indexOf(v) !== -1) {
            r.push(v);
          }
        }
        return r;
      }
      function mergeTags(a, b) {
        if (a === exports.emptyTags) {
          return b;
        }
        if (b === exports.emptyTags) {
          return a;
        }
        var r = Object.assign({}, a);
        for (var k in b) {
          if (hasOwnProperty.call(a, k)) {
            var intersection_1 = intersect(a[k], b[k]);
            if (isNonEmpty(intersection_1)) {
              r[k] = intersection_1;
            } else {
              r = exports.emptyTags;
              break;
            }
          } else {
            r[k] = b[k];
          }
        }
        return r;
      }
      function intersectTags(a, b) {
        if (a === exports.emptyTags || b === exports.emptyTags) {
          return exports.emptyTags;
        }
        var r = exports.emptyTags;
        for (var k in a) {
          if (hasOwnProperty.call(b, k)) {
            var intersection_2 = intersect(a[k], b[k]);
            if (intersection_2.length === 0) {
              if (r === exports.emptyTags) {
                r = {};
              }
              r[k] = a[k].concat(b[k]);
            }
          }
        }
        return r;
      }
      function isAnyC(codec) {
        return codec._tag === "AnyType";
      }
      function isLiteralC(codec) {
        return codec._tag === "LiteralType";
      }
      function isKeyofC(codec) {
        return codec._tag === "KeyofType";
      }
      function isTypeC(codec) {
        return codec._tag === "InterfaceType";
      }
      function isPartialC(codec) {
        return codec._tag === "PartialType";
      }
      function isStrictC(codec) {
        return codec._tag === "StrictType";
      }
      function isExactC(codec) {
        return codec._tag === "ExactType";
      }
      function isRefinementC(codec) {
        return codec._tag === "RefinementType";
      }
      function isIntersectionC(codec) {
        return codec._tag === "IntersectionType";
      }
      function isUnionC(codec) {
        return codec._tag === "UnionType";
      }
      function isRecursiveC(codec) {
        return codec._tag === "RecursiveType";
      }
      var lazyCodecs = [];
      function getTags(codec) {
        if (lazyCodecs.indexOf(codec) !== -1) {
          return exports.emptyTags;
        }
        if (isTypeC(codec) || isStrictC(codec)) {
          var index = exports.emptyTags;
          for (var k in codec.props) {
            var prop = codec.props[k];
            if (isLiteralC(prop)) {
              if (index === exports.emptyTags) {
                index = {};
              }
              index[k] = [prop.value];
            }
          }
          return index;
        } else if (isExactC(codec) || isRefinementC(codec)) {
          return getTags(codec.type);
        } else if (isIntersectionC(codec)) {
          return codec.types.reduce(function(tags2, codec2) {
            return mergeTags(tags2, getTags(codec2));
          }, exports.emptyTags);
        } else if (isUnionC(codec)) {
          return codec.types.slice(1).reduce(function(tags2, codec2) {
            return intersectTags(tags2, getTags(codec2));
          }, getTags(codec.types[0]));
        } else if (isRecursiveC(codec)) {
          lazyCodecs.push(codec);
          var tags = getTags(codec.type);
          lazyCodecs.pop();
          return tags;
        }
        return exports.emptyTags;
      }
      exports.getTags = getTags;
      function getIndex(codecs) {
        var tags = getTags(codecs[0]);
        var keys = Object.keys(tags);
        var len = codecs.length;
        var _loop_1 = function(k2) {
          var all = tags[k2].slice();
          var index = [tags[k2]];
          for (var i = 1; i < len; i++) {
            var codec = codecs[i];
            var ctags = getTags(codec);
            var values = ctags[k2];
            if (values === void 0) {
              return "continue-keys";
            } else {
              if (values.some(function(v) {
                return all.indexOf(v) !== -1;
              })) {
                return "continue-keys";
              } else {
                all.push.apply(all, values);
                index.push(values);
              }
            }
          }
          return { value: [k2, index] };
        };
        keys:
          for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var k = keys_1[_i];
            var state_1 = _loop_1(k);
            if (typeof state_1 === "object")
              return state_1.value;
            switch (state_1) {
              case "continue-keys":
                continue keys;
            }
          }
        return void 0;
      }
      exports.getIndex = getIndex;
      var NullType = function(_super) {
        __extends2(NullType2, _super);
        function NullType2() {
          var _this = _super.call(this, "null", function(u) {
            return u === null;
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "NullType";
          return _this;
        }
        return NullType2;
      }(Type);
      exports.NullType = NullType;
      exports.nullType = new NullType();
      exports.null = exports.nullType;
      var UndefinedType = function(_super) {
        __extends2(UndefinedType2, _super);
        function UndefinedType2() {
          var _this = _super.call(this, "undefined", function(u) {
            return u === void 0;
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "UndefinedType";
          return _this;
        }
        return UndefinedType2;
      }(Type);
      exports.UndefinedType = UndefinedType;
      var undefinedType = new UndefinedType();
      exports.undefined = undefinedType;
      var VoidType = function(_super) {
        __extends2(VoidType2, _super);
        function VoidType2() {
          var _this = _super.call(this, "void", undefinedType.is, undefinedType.validate, exports.identity) || this;
          _this._tag = "VoidType";
          return _this;
        }
        return VoidType2;
      }(Type);
      exports.VoidType = VoidType;
      exports.voidType = new VoidType();
      exports.void = exports.voidType;
      var UnknownType = function(_super) {
        __extends2(UnknownType2, _super);
        function UnknownType2() {
          var _this = _super.call(this, "unknown", function(_) {
            return true;
          }, exports.success, exports.identity) || this;
          _this._tag = "UnknownType";
          return _this;
        }
        return UnknownType2;
      }(Type);
      exports.UnknownType = UnknownType;
      exports.unknown = new UnknownType();
      var StringType = function(_super) {
        __extends2(StringType2, _super);
        function StringType2() {
          var _this = _super.call(this, "string", function(u) {
            return typeof u === "string";
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "StringType";
          return _this;
        }
        return StringType2;
      }(Type);
      exports.StringType = StringType;
      exports.string = new StringType();
      var NumberType = function(_super) {
        __extends2(NumberType2, _super);
        function NumberType2() {
          var _this = _super.call(this, "number", function(u) {
            return typeof u === "number";
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "NumberType";
          return _this;
        }
        return NumberType2;
      }(Type);
      exports.NumberType = NumberType;
      exports.number = new NumberType();
      var BigIntType = function(_super) {
        __extends2(BigIntType2, _super);
        function BigIntType2() {
          var _this = _super.call(
            this,
            "bigint",
            // tslint:disable-next-line: valid-typeof
            function(u) {
              return typeof u === "bigint";
            },
            function(u, c) {
              return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
            },
            exports.identity
          ) || this;
          _this._tag = "BigIntType";
          return _this;
        }
        return BigIntType2;
      }(Type);
      exports.BigIntType = BigIntType;
      exports.bigint = new BigIntType();
      var BooleanType = function(_super) {
        __extends2(BooleanType2, _super);
        function BooleanType2() {
          var _this = _super.call(this, "boolean", function(u) {
            return typeof u === "boolean";
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "BooleanType";
          return _this;
        }
        return BooleanType2;
      }(Type);
      exports.BooleanType = BooleanType;
      exports.boolean = new BooleanType();
      var AnyArrayType = function(_super) {
        __extends2(AnyArrayType2, _super);
        function AnyArrayType2() {
          var _this = _super.call(this, "UnknownArray", Array.isArray, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "AnyArrayType";
          return _this;
        }
        return AnyArrayType2;
      }(Type);
      exports.AnyArrayType = AnyArrayType;
      exports.UnknownArray = new AnyArrayType();
      exports.Array = exports.UnknownArray;
      var AnyDictionaryType = function(_super) {
        __extends2(AnyDictionaryType2, _super);
        function AnyDictionaryType2() {
          var _this = _super.call(this, "UnknownRecord", function(u) {
            return u !== null && typeof u === "object" && !Array.isArray(u);
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "AnyDictionaryType";
          return _this;
        }
        return AnyDictionaryType2;
      }(Type);
      exports.AnyDictionaryType = AnyDictionaryType;
      exports.UnknownRecord = new AnyDictionaryType();
      var LiteralType = function(_super) {
        __extends2(LiteralType2, _super);
        function LiteralType2(name, is, validate, encode, value) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.value = value;
          _this._tag = "LiteralType";
          return _this;
        }
        return LiteralType2;
      }(Type);
      exports.LiteralType = LiteralType;
      function literal(value, name) {
        if (name === void 0) {
          name = JSON.stringify(value);
        }
        var is = function(u) {
          return u === value;
        };
        return new LiteralType(name, is, function(u, c) {
          return is(u) ? (0, exports.success)(value) : (0, exports.failure)(u, c);
        }, exports.identity, value);
      }
      exports.literal = literal;
      var KeyofType = function(_super) {
        __extends2(KeyofType2, _super);
        function KeyofType2(name, is, validate, encode, keys) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.keys = keys;
          _this._tag = "KeyofType";
          return _this;
        }
        return KeyofType2;
      }(Type);
      exports.KeyofType = KeyofType;
      function keyof(keys, name) {
        if (name === void 0) {
          name = Object.keys(keys).map(function(k) {
            return JSON.stringify(k);
          }).join(" | ");
        }
        var is = function(u) {
          return exports.string.is(u) && hasOwnProperty.call(keys, u);
        };
        return new KeyofType(name, is, function(u, c) {
          return is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
        }, exports.identity, keys);
      }
      exports.keyof = keyof;
      var RefinementType = function(_super) {
        __extends2(RefinementType2, _super);
        function RefinementType2(name, is, validate, encode, type2, predicate) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type2;
          _this.predicate = predicate;
          _this._tag = "RefinementType";
          return _this;
        }
        return RefinementType2;
      }(Type);
      exports.RefinementType = RefinementType;
      function brand(codec, predicate, name) {
        return refinement(codec, predicate, name);
      }
      exports.brand = brand;
      exports.Int = brand(exports.number, function(n) {
        return Number.isInteger(n);
      }, "Int");
      var RecursiveType = function(_super) {
        __extends2(RecursiveType2, _super);
        function RecursiveType2(name, is, validate, encode, runDefinition) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.runDefinition = runDefinition;
          _this._tag = "RecursiveType";
          return _this;
        }
        return RecursiveType2;
      }(Type);
      exports.RecursiveType = RecursiveType;
      Object.defineProperty(RecursiveType.prototype, "type", {
        get: function() {
          return this.runDefinition();
        },
        enumerable: true,
        configurable: true
      });
      function recursion(name, definition) {
        var cache;
        var runDefinition = function() {
          if (!cache) {
            cache = definition(Self);
            cache.name = name;
          }
          return cache;
        };
        var Self = new RecursiveType(name, function(u) {
          return runDefinition().is(u);
        }, function(u, c) {
          return runDefinition().validate(u, c);
        }, function(a) {
          return runDefinition().encode(a);
        }, runDefinition);
        return Self;
      }
      exports.recursion = recursion;
      var ArrayType = function(_super) {
        __extends2(ArrayType2, _super);
        function ArrayType2(name, is, validate, encode, type2) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type2;
          _this._tag = "ArrayType";
          return _this;
        }
        return ArrayType2;
      }(Type);
      exports.ArrayType = ArrayType;
      function array(item, name) {
        if (name === void 0) {
          name = "Array<".concat(item.name, ">");
        }
        return new ArrayType(name, function(u) {
          return exports.UnknownArray.is(u) && u.every(item.is);
        }, function(u, c) {
          var e = exports.UnknownArray.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var us = e.right;
          var len = us.length;
          var as = us;
          var errors = [];
          for (var i = 0; i < len; i++) {
            var ui = us[i];
            var result = item.validate(ui, appendContext(c, String(i), item, ui));
            if ((0, Either_1.isLeft)(result)) {
              pushAll(errors, result.left);
            } else {
              var ai = result.right;
              if (ai !== ui) {
                if (as === us) {
                  as = us.slice();
                }
                as[i] = ai;
              }
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(as);
        }, item.encode === exports.identity ? exports.identity : function(a) {
          return a.map(item.encode);
        }, item);
      }
      exports.array = array;
      var InterfaceType = function(_super) {
        __extends2(InterfaceType2, _super);
        function InterfaceType2(name, is, validate, encode, props) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.props = props;
          _this._tag = "InterfaceType";
          return _this;
        }
        return InterfaceType2;
      }(Type);
      exports.InterfaceType = InterfaceType;
      function type(props, name) {
        if (name === void 0) {
          name = getInterfaceTypeName(props);
        }
        var keys = Object.keys(props);
        var types = keys.map(function(key) {
          return props[key];
        });
        var len = keys.length;
        return new InterfaceType(name, function(u) {
          if (exports.UnknownRecord.is(u)) {
            for (var i = 0; i < len; i++) {
              var k = keys[i];
              var uk = u[k];
              if (uk === void 0 && !hasOwnProperty.call(u, k) || !types[i].is(uk)) {
                return false;
              }
            }
            return true;
          }
          return false;
        }, function(u, c) {
          var e = exports.UnknownRecord.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var o = e.right;
          var a = o;
          var errors = [];
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            var ak = a[k];
            var type_1 = types[i];
            var result = type_1.validate(ak, appendContext(c, k, type_1, ak));
            if ((0, Either_1.isLeft)(result)) {
              pushAll(errors, result.left);
            } else {
              var vak = result.right;
              if (vak !== ak || vak === void 0 && !hasOwnProperty.call(a, k)) {
                if (a === o) {
                  a = __assign2({}, o);
                }
                a[k] = vak;
              }
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(a);
        }, useIdentity(types) ? exports.identity : function(a) {
          var s = __assign2({}, a);
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            var encode = types[i].encode;
            if (encode !== exports.identity) {
              s[k] = encode(a[k]);
            }
          }
          return s;
        }, props);
      }
      exports.type = type;
      exports.interface = type;
      var PartialType = function(_super) {
        __extends2(PartialType2, _super);
        function PartialType2(name, is, validate, encode, props) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.props = props;
          _this._tag = "PartialType";
          return _this;
        }
        return PartialType2;
      }(Type);
      exports.PartialType = PartialType;
      function partial(props, name) {
        if (name === void 0) {
          name = getPartialTypeName(getInterfaceTypeName(props));
        }
        var keys = Object.keys(props);
        var types = keys.map(function(key) {
          return props[key];
        });
        var len = keys.length;
        return new PartialType(name, function(u) {
          if (exports.UnknownRecord.is(u)) {
            for (var i = 0; i < len; i++) {
              var k = keys[i];
              var uk = u[k];
              if (uk !== void 0 && !props[k].is(uk)) {
                return false;
              }
            }
            return true;
          }
          return false;
        }, function(u, c) {
          var e = exports.UnknownRecord.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var o = e.right;
          var a = o;
          var errors = [];
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            var ak = a[k];
            var type_2 = props[k];
            var result = type_2.validate(ak, appendContext(c, k, type_2, ak));
            if ((0, Either_1.isLeft)(result)) {
              if (ak !== void 0) {
                pushAll(errors, result.left);
              }
            } else {
              var vak = result.right;
              if (vak !== ak) {
                if (a === o) {
                  a = __assign2({}, o);
                }
                a[k] = vak;
              }
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(a);
        }, useIdentity(types) ? exports.identity : function(a) {
          var s = __assign2({}, a);
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            var ak = a[k];
            if (ak !== void 0) {
              s[k] = types[i].encode(ak);
            }
          }
          return s;
        }, props);
      }
      exports.partial = partial;
      var DictionaryType = function(_super) {
        __extends2(DictionaryType2, _super);
        function DictionaryType2(name, is, validate, encode, domain, codomain) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.domain = domain;
          _this.codomain = codomain;
          _this._tag = "DictionaryType";
          return _this;
        }
        return DictionaryType2;
      }(Type);
      exports.DictionaryType = DictionaryType;
      function record(domain, codomain, name) {
        var keys = getDomainKeys(domain);
        return keys ? enumerableRecord(Object.keys(keys), domain, codomain, name) : nonEnumerableRecord(domain, codomain, name);
      }
      exports.record = record;
      var UnionType = function(_super) {
        __extends2(UnionType2, _super);
        function UnionType2(name, is, validate, encode, types) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.types = types;
          _this._tag = "UnionType";
          return _this;
        }
        return UnionType2;
      }(Type);
      exports.UnionType = UnionType;
      function union(codecs, name) {
        if (name === void 0) {
          name = getUnionName(codecs);
        }
        var index = getIndex(codecs);
        if (index !== void 0 && codecs.length > 0) {
          var tag_1 = index[0], groups_1 = index[1];
          var len_1 = groups_1.length;
          var find_1 = function(value) {
            for (var i = 0; i < len_1; i++) {
              if (groups_1[i].indexOf(value) !== -1) {
                return i;
              }
            }
            return void 0;
          };
          return new TaggedUnionType(name, function(u) {
            if (exports.UnknownRecord.is(u)) {
              var i = find_1(u[tag_1]);
              return i !== void 0 ? codecs[i].is(u) : false;
            }
            return false;
          }, function(u, c) {
            var e = exports.UnknownRecord.validate(u, c);
            if ((0, Either_1.isLeft)(e)) {
              return e;
            }
            var r = e.right;
            var i = find_1(r[tag_1]);
            if (i === void 0) {
              return (0, exports.failure)(u, c);
            }
            var codec = codecs[i];
            return codec.validate(r, appendContext(c, String(i), codec, r));
          }, useIdentity(codecs) ? exports.identity : function(a) {
            var i = find_1(a[tag_1]);
            if (i === void 0) {
              throw new Error("no codec found to encode value in union codec ".concat(name));
            } else {
              return codecs[i].encode(a);
            }
          }, codecs, tag_1);
        } else {
          return new UnionType(name, function(u) {
            return codecs.some(function(type2) {
              return type2.is(u);
            });
          }, function(u, c) {
            var errors = [];
            for (var i = 0; i < codecs.length; i++) {
              var codec = codecs[i];
              var result = codec.validate(u, appendContext(c, String(i), codec, u));
              if ((0, Either_1.isLeft)(result)) {
                pushAll(errors, result.left);
              } else {
                return (0, exports.success)(result.right);
              }
            }
            return (0, exports.failures)(errors);
          }, useIdentity(codecs) ? exports.identity : function(a) {
            for (var _i = 0, codecs_1 = codecs; _i < codecs_1.length; _i++) {
              var codec = codecs_1[_i];
              if (codec.is(a)) {
                return codec.encode(a);
              }
            }
            throw new Error("no codec found to encode value in union type ".concat(name));
          }, codecs);
        }
      }
      exports.union = union;
      var IntersectionType = function(_super) {
        __extends2(IntersectionType2, _super);
        function IntersectionType2(name, is, validate, encode, types) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.types = types;
          _this._tag = "IntersectionType";
          return _this;
        }
        return IntersectionType2;
      }(Type);
      exports.IntersectionType = IntersectionType;
      function intersection(codecs, name) {
        if (name === void 0) {
          name = "(".concat(codecs.map(function(type2) {
            return type2.name;
          }).join(" & "), ")");
        }
        var len = codecs.length;
        return new IntersectionType(name, function(u) {
          return codecs.every(function(type2) {
            return type2.is(u);
          });
        }, codecs.length === 0 ? exports.success : function(u, c) {
          var us = [];
          var errors = [];
          for (var i = 0; i < len; i++) {
            var codec = codecs[i];
            var result = codec.validate(u, appendContext(c, String(i), codec, u));
            if ((0, Either_1.isLeft)(result)) {
              pushAll(errors, result.left);
            } else {
              us.push(result.right);
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(mergeAll(u, us));
        }, codecs.length === 0 ? exports.identity : function(a) {
          return mergeAll(a, codecs.map(function(codec) {
            return codec.encode(a);
          }));
        }, codecs);
      }
      exports.intersection = intersection;
      var TupleType = function(_super) {
        __extends2(TupleType2, _super);
        function TupleType2(name, is, validate, encode, types) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.types = types;
          _this._tag = "TupleType";
          return _this;
        }
        return TupleType2;
      }(Type);
      exports.TupleType = TupleType;
      function tuple(codecs, name) {
        if (name === void 0) {
          name = "[".concat(codecs.map(function(type2) {
            return type2.name;
          }).join(", "), "]");
        }
        var len = codecs.length;
        return new TupleType(name, function(u) {
          return exports.UnknownArray.is(u) && u.length === len && codecs.every(function(type2, i) {
            return type2.is(u[i]);
          });
        }, function(u, c) {
          var e = exports.UnknownArray.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var us = e.right;
          var as = us.length > len ? us.slice(0, len) : us;
          var errors = [];
          for (var i = 0; i < len; i++) {
            var a = us[i];
            var type_3 = codecs[i];
            var result = type_3.validate(a, appendContext(c, String(i), type_3, a));
            if ((0, Either_1.isLeft)(result)) {
              pushAll(errors, result.left);
            } else {
              var va = result.right;
              if (va !== a) {
                if (as === us) {
                  as = us.slice();
                }
                as[i] = va;
              }
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(as);
        }, useIdentity(codecs) ? exports.identity : function(a) {
          return codecs.map(function(type2, i) {
            return type2.encode(a[i]);
          });
        }, codecs);
      }
      exports.tuple = tuple;
      var ReadonlyType = function(_super) {
        __extends2(ReadonlyType2, _super);
        function ReadonlyType2(name, is, validate, encode, type2) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type2;
          _this._tag = "ReadonlyType";
          return _this;
        }
        return ReadonlyType2;
      }(Type);
      exports.ReadonlyType = ReadonlyType;
      function readonly(codec, name) {
        if (name === void 0) {
          name = "Readonly<".concat(codec.name, ">");
        }
        return new ReadonlyType(name, codec.is, codec.validate, codec.encode, codec);
      }
      exports.readonly = readonly;
      var ReadonlyArrayType = function(_super) {
        __extends2(ReadonlyArrayType2, _super);
        function ReadonlyArrayType2(name, is, validate, encode, type2) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type2;
          _this._tag = "ReadonlyArrayType";
          return _this;
        }
        return ReadonlyArrayType2;
      }(Type);
      exports.ReadonlyArrayType = ReadonlyArrayType;
      function readonlyArray(item, name) {
        if (name === void 0) {
          name = "ReadonlyArray<".concat(item.name, ">");
        }
        var codec = array(item);
        return new ReadonlyArrayType(name, codec.is, codec.validate, codec.encode, item);
      }
      exports.readonlyArray = readonlyArray;
      var strict = function(props, name) {
        return exact(type(props), name);
      };
      exports.strict = strict;
      var ExactType = function(_super) {
        __extends2(ExactType2, _super);
        function ExactType2(name, is, validate, encode, type2) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type2;
          _this._tag = "ExactType";
          return _this;
        }
        return ExactType2;
      }(Type);
      exports.ExactType = ExactType;
      function exact(codec, name) {
        if (name === void 0) {
          name = getExactTypeName(codec);
        }
        var props = getProps(codec);
        return new ExactType(name, codec.is, function(u, c) {
          var e = exports.UnknownRecord.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var ce = codec.validate(u, c);
          if ((0, Either_1.isLeft)(ce)) {
            return ce;
          }
          return (0, Either_1.right)(stripKeys(ce.right, props));
        }, function(a) {
          return codec.encode(stripKeys(a, props));
        }, codec);
      }
      exports.exact = exact;
      var FunctionType = function(_super) {
        __extends2(FunctionType2, _super);
        function FunctionType2() {
          var _this = _super.call(
            this,
            "Function",
            // tslint:disable-next-line:strict-type-predicates
            function(u) {
              return typeof u === "function";
            },
            function(u, c) {
              return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
            },
            exports.identity
          ) || this;
          _this._tag = "FunctionType";
          return _this;
        }
        return FunctionType2;
      }(Type);
      exports.FunctionType = FunctionType;
      exports.Function = new FunctionType();
      var TaggedUnionType = function(_super) {
        __extends2(TaggedUnionType2, _super);
        function TaggedUnionType2(name, is, validate, encode, codecs, tag) {
          var _this = _super.call(this, name, is, validate, encode, codecs) || this;
          _this.tag = tag;
          return _this;
        }
        return TaggedUnionType2;
      }(UnionType);
      exports.TaggedUnionType = TaggedUnionType;
      var taggedUnion = function(tag, codecs, name) {
        if (name === void 0) {
          name = getUnionName(codecs);
        }
        var U = union(codecs, name);
        if (U instanceof TaggedUnionType) {
          return U;
        } else {
          console.warn("[io-ts] Cannot build a tagged union for ".concat(name, ", returning a de-optimized union"));
          return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag);
        }
      };
      exports.taggedUnion = taggedUnion;
      var getValidationError = function(value, context) {
        return {
          value,
          context
        };
      };
      exports.getValidationError = getValidationError;
      var getDefaultContext = function(decoder) {
        return [
          { key: "", type: decoder }
        ];
      };
      exports.getDefaultContext = getDefaultContext;
      var NeverType = function(_super) {
        __extends2(NeverType2, _super);
        function NeverType2() {
          var _this = _super.call(
            this,
            "never",
            function(_) {
              return false;
            },
            function(u, c) {
              return (0, exports.failure)(u, c);
            },
            /* istanbul ignore next */
            function() {
              throw new Error("cannot encode never");
            }
          ) || this;
          _this._tag = "NeverType";
          return _this;
        }
        return NeverType2;
      }(Type);
      exports.NeverType = NeverType;
      exports.never = new NeverType();
      var AnyType = function(_super) {
        __extends2(AnyType2, _super);
        function AnyType2() {
          var _this = _super.call(this, "any", function(_) {
            return true;
          }, exports.success, exports.identity) || this;
          _this._tag = "AnyType";
          return _this;
        }
        return AnyType2;
      }(Type);
      exports.AnyType = AnyType;
      exports.any = new AnyType();
      exports.Dictionary = exports.UnknownRecord;
      var ObjectType = function(_super) {
        __extends2(ObjectType2, _super);
        function ObjectType2() {
          var _this = _super.call(this, "object", function(u) {
            return u !== null && typeof u === "object";
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "ObjectType";
          return _this;
        }
        return ObjectType2;
      }(Type);
      exports.ObjectType = ObjectType;
      exports.object = new ObjectType();
      function refinement(codec, predicate, name) {
        if (name === void 0) {
          name = "(".concat(codec.name, " | ").concat(getFunctionName(predicate), ")");
        }
        return new RefinementType(name, function(u) {
          return codec.is(u) && predicate(u);
        }, function(i, c) {
          var e = codec.validate(i, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var a = e.right;
          return predicate(a) ? (0, exports.success)(a) : (0, exports.failure)(a, c);
        }, codec.encode, codec, predicate);
      }
      exports.refinement = refinement;
      exports.Integer = refinement(exports.number, Number.isInteger, "Integer");
      exports.dictionary = record;
      var StrictType = function(_super) {
        __extends2(StrictType2, _super);
        function StrictType2(name, is, validate, encode, props) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.props = props;
          _this._tag = "StrictType";
          return _this;
        }
        return StrictType2;
      }(Type);
      exports.StrictType = StrictType;
      function clean(codec) {
        return codec;
      }
      exports.clean = clean;
      function alias(codec) {
        return function() {
          return codec;
        };
      }
      exports.alias = alias;
    }
  });

  // node_modules/fp-ts/lib/Eq.js
  var require_Eq = __commonJS({
    "node_modules/fp-ts/lib/Eq.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.eqDate = exports.eqNumber = exports.eqString = exports.eqBoolean = exports.eq = exports.strictEqual = exports.getStructEq = exports.getTupleEq = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.eqStrict = exports.URI = exports.contramap = exports.tuple = exports.struct = exports.fromEquals = void 0;
      var function_1 = require_function();
      var fromEquals = function(equals2) {
        return {
          equals: function(x, y) {
            return x === y || equals2(x, y);
          }
        };
      };
      exports.fromEquals = fromEquals;
      var struct = function(eqs) {
        return (0, exports.fromEquals)(function(first, second) {
          for (var key in eqs) {
            if (!eqs[key].equals(first[key], second[key])) {
              return false;
            }
          }
          return true;
        });
      };
      exports.struct = struct;
      var tuple = function() {
        var eqs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          eqs[_i] = arguments[_i];
        }
        return (0, exports.fromEquals)(function(first, second) {
          return eqs.every(function(E, i) {
            return E.equals(first[i], second[i]);
          });
        });
      };
      exports.tuple = tuple;
      var contramap_ = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.contramap)(f));
      };
      var contramap = function(f) {
        return function(fa) {
          return (0, exports.fromEquals)(function(x, y) {
            return fa.equals(f(x), f(y));
          });
        };
      };
      exports.contramap = contramap;
      exports.URI = "Eq";
      exports.eqStrict = {
        equals: function(a, b) {
          return a === b;
        }
      };
      var empty = {
        equals: function() {
          return true;
        }
      };
      var getSemigroup = function() {
        return {
          concat: function(x, y) {
            return (0, exports.fromEquals)(function(a, b) {
              return x.equals(a, b) && y.equals(a, b);
            });
          }
        };
      };
      exports.getSemigroup = getSemigroup;
      var getMonoid = function() {
        return {
          concat: (0, exports.getSemigroup)().concat,
          empty
        };
      };
      exports.getMonoid = getMonoid;
      exports.Contravariant = {
        URI: exports.URI,
        contramap: contramap_
      };
      exports.getTupleEq = exports.tuple;
      exports.getStructEq = exports.struct;
      exports.strictEqual = exports.eqStrict.equals;
      exports.eq = exports.Contravariant;
      exports.eqBoolean = exports.eqStrict;
      exports.eqString = exports.eqStrict;
      exports.eqNumber = exports.eqStrict;
      exports.eqDate = {
        equals: function(first, second) {
          return first.valueOf() === second.valueOf();
        }
      };
    }
  });

  // node_modules/fp-ts/lib/Ord.js
  var require_Ord = __commonJS({
    "node_modules/fp-ts/lib/Ord.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ordDate = exports.ordNumber = exports.ordString = exports.ordBoolean = exports.ord = exports.getDualOrd = exports.getTupleOrd = exports.between = exports.clamp = exports.max = exports.min = exports.geq = exports.leq = exports.gt = exports.lt = exports.equals = exports.trivial = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.URI = exports.contramap = exports.reverse = exports.tuple = exports.fromCompare = exports.equalsDefault = void 0;
      var Eq_1 = require_Eq();
      var function_1 = require_function();
      var equalsDefault = function(compare4) {
        return function(first, second) {
          return first === second || compare4(first, second) === 0;
        };
      };
      exports.equalsDefault = equalsDefault;
      var fromCompare = function(compare4) {
        return {
          equals: (0, exports.equalsDefault)(compare4),
          compare: function(first, second) {
            return first === second ? 0 : compare4(first, second);
          }
        };
      };
      exports.fromCompare = fromCompare;
      var tuple = function() {
        var ords = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          ords[_i] = arguments[_i];
        }
        return (0, exports.fromCompare)(function(first, second) {
          var i = 0;
          for (; i < ords.length - 1; i++) {
            var r = ords[i].compare(first[i], second[i]);
            if (r !== 0) {
              return r;
            }
          }
          return ords[i].compare(first[i], second[i]);
        });
      };
      exports.tuple = tuple;
      var reverse = function(O) {
        return (0, exports.fromCompare)(function(first, second) {
          return O.compare(second, first);
        });
      };
      exports.reverse = reverse;
      var contramap_ = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.contramap)(f));
      };
      var contramap = function(f) {
        return function(fa) {
          return (0, exports.fromCompare)(function(first, second) {
            return fa.compare(f(first), f(second));
          });
        };
      };
      exports.contramap = contramap;
      exports.URI = "Ord";
      var getSemigroup = function() {
        return {
          concat: function(first, second) {
            return (0, exports.fromCompare)(function(a, b) {
              var ox = first.compare(a, b);
              return ox !== 0 ? ox : second.compare(a, b);
            });
          }
        };
      };
      exports.getSemigroup = getSemigroup;
      var getMonoid = function() {
        return {
          concat: (0, exports.getSemigroup)().concat,
          empty: (0, exports.fromCompare)(function() {
            return 0;
          })
        };
      };
      exports.getMonoid = getMonoid;
      exports.Contravariant = {
        URI: exports.URI,
        contramap: contramap_
      };
      exports.trivial = {
        equals: function_1.constTrue,
        compare: /* @__PURE__ */ (0, function_1.constant)(0)
      };
      var equals2 = function(O) {
        return function(second) {
          return function(first) {
            return first === second || O.compare(first, second) === 0;
          };
        };
      };
      exports.equals = equals2;
      var lt = function(O) {
        return function(first, second) {
          return O.compare(first, second) === -1;
        };
      };
      exports.lt = lt;
      var gt = function(O) {
        return function(first, second) {
          return O.compare(first, second) === 1;
        };
      };
      exports.gt = gt;
      var leq = function(O) {
        return function(first, second) {
          return O.compare(first, second) !== 1;
        };
      };
      exports.leq = leq;
      var geq = function(O) {
        return function(first, second) {
          return O.compare(first, second) !== -1;
        };
      };
      exports.geq = geq;
      var min = function(O) {
        return function(first, second) {
          return first === second || O.compare(first, second) < 1 ? first : second;
        };
      };
      exports.min = min;
      var max = function(O) {
        return function(first, second) {
          return first === second || O.compare(first, second) > -1 ? first : second;
        };
      };
      exports.max = max;
      var clamp = function(O) {
        var minO = (0, exports.min)(O);
        var maxO = (0, exports.max)(O);
        return function(low, hi) {
          return function(a) {
            return maxO(minO(a, hi), low);
          };
        };
      };
      exports.clamp = clamp;
      var between = function(O) {
        var ltO = (0, exports.lt)(O);
        var gtO = (0, exports.gt)(O);
        return function(low, hi) {
          return function(a) {
            return ltO(a, low) || gtO(a, hi) ? false : true;
          };
        };
      };
      exports.between = between;
      exports.getTupleOrd = exports.tuple;
      exports.getDualOrd = exports.reverse;
      exports.ord = exports.Contravariant;
      function compare3(first, second) {
        return first < second ? -1 : first > second ? 1 : 0;
      }
      var strictOrd = {
        equals: Eq_1.eqStrict.equals,
        compare: compare3
      };
      exports.ordBoolean = strictOrd;
      exports.ordString = strictOrd;
      exports.ordNumber = strictOrd;
      exports.ordDate = (0, function_1.pipe)(
        exports.ordNumber,
        /* @__PURE__ */ (0, exports.contramap)(function(date) {
          return date.valueOf();
        })
      );
    }
  });

  // node_modules/fp-ts/lib/Magma.js
  var require_Magma = __commonJS({
    "node_modules/fp-ts/lib/Magma.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.concatAll = exports.endo = exports.filterSecond = exports.filterFirst = exports.reverse = void 0;
      var reverse = function(M) {
        return {
          concat: function(first, second) {
            return M.concat(second, first);
          }
        };
      };
      exports.reverse = reverse;
      var filterFirst = function(predicate) {
        return function(M) {
          return {
            concat: function(first, second) {
              return predicate(first) ? M.concat(first, second) : second;
            }
          };
        };
      };
      exports.filterFirst = filterFirst;
      var filterSecond = function(predicate) {
        return function(M) {
          return {
            concat: function(first, second) {
              return predicate(second) ? M.concat(first, second) : first;
            }
          };
        };
      };
      exports.filterSecond = filterSecond;
      var endo = function(f) {
        return function(M) {
          return {
            concat: function(first, second) {
              return M.concat(f(first), f(second));
            }
          };
        };
      };
      exports.endo = endo;
      var concatAll = function(M) {
        return function(startWith) {
          return function(as) {
            return as.reduce(function(a, acc) {
              return M.concat(a, acc);
            }, startWith);
          };
        };
      };
      exports.concatAll = concatAll;
    }
  });

  // node_modules/fp-ts/lib/Semigroup.js
  var require_Semigroup = __commonJS({
    "node_modules/fp-ts/lib/Semigroup.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.semigroupProduct = exports.semigroupSum = exports.semigroupString = exports.getFunctionSemigroup = exports.semigroupAny = exports.semigroupAll = exports.fold = exports.getIntercalateSemigroup = exports.getMeetSemigroup = exports.getJoinSemigroup = exports.getDualSemigroup = exports.getStructSemigroup = exports.getTupleSemigroup = exports.getFirstSemigroup = exports.getLastSemigroup = exports.getObjectSemigroup = exports.semigroupVoid = exports.concatAll = exports.last = exports.first = exports.intercalate = exports.tuple = exports.struct = exports.reverse = exports.constant = exports.max = exports.min = void 0;
      var function_1 = require_function();
      var _ = __importStar2(require_internal());
      var M = __importStar2(require_Magma());
      var Or = __importStar2(require_Ord());
      var min = function(O) {
        return {
          concat: Or.min(O)
        };
      };
      exports.min = min;
      var max = function(O) {
        return {
          concat: Or.max(O)
        };
      };
      exports.max = max;
      var constant = function(a) {
        return {
          concat: function() {
            return a;
          }
        };
      };
      exports.constant = constant;
      exports.reverse = M.reverse;
      var struct = function(semigroups) {
        return {
          concat: function(first2, second) {
            var r = {};
            for (var k in semigroups) {
              if (_.has.call(semigroups, k)) {
                r[k] = semigroups[k].concat(first2[k], second[k]);
              }
            }
            return r;
          }
        };
      };
      exports.struct = struct;
      var tuple = function() {
        var semigroups = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          semigroups[_i] = arguments[_i];
        }
        return {
          concat: function(first2, second) {
            return semigroups.map(function(s, i) {
              return s.concat(first2[i], second[i]);
            });
          }
        };
      };
      exports.tuple = tuple;
      var intercalate = function(middle) {
        return function(S) {
          return {
            concat: function(x, y) {
              return S.concat(x, S.concat(middle, y));
            }
          };
        };
      };
      exports.intercalate = intercalate;
      var first = function() {
        return { concat: function_1.identity };
      };
      exports.first = first;
      var last = function() {
        return { concat: function(_2, y) {
          return y;
        } };
      };
      exports.last = last;
      exports.concatAll = M.concatAll;
      exports.semigroupVoid = (0, exports.constant)(void 0);
      var getObjectSemigroup = function() {
        return {
          concat: function(first2, second) {
            return Object.assign({}, first2, second);
          }
        };
      };
      exports.getObjectSemigroup = getObjectSemigroup;
      exports.getLastSemigroup = exports.last;
      exports.getFirstSemigroup = exports.first;
      exports.getTupleSemigroup = exports.tuple;
      exports.getStructSemigroup = exports.struct;
      exports.getDualSemigroup = exports.reverse;
      exports.getJoinSemigroup = exports.max;
      exports.getMeetSemigroup = exports.min;
      exports.getIntercalateSemigroup = exports.intercalate;
      function fold(S) {
        var concatAllS = (0, exports.concatAll)(S);
        return function(startWith, as) {
          return as === void 0 ? concatAllS(startWith) : concatAllS(startWith)(as);
        };
      }
      exports.fold = fold;
      exports.semigroupAll = {
        concat: function(x, y) {
          return x && y;
        }
      };
      exports.semigroupAny = {
        concat: function(x, y) {
          return x || y;
        }
      };
      exports.getFunctionSemigroup = function_1.getSemigroup;
      exports.semigroupString = {
        concat: function(x, y) {
          return x + y;
        }
      };
      exports.semigroupSum = {
        concat: function(x, y) {
          return x + y;
        }
      };
      exports.semigroupProduct = {
        concat: function(x, y) {
          return x * y;
        }
      };
    }
  });

  // node_modules/fp-ts/lib/ReadonlyNonEmptyArray.js
  var require_ReadonlyNonEmptyArray = __commonJS({
    "node_modules/fp-ts/lib/ReadonlyNonEmptyArray.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __spreadArray = exports && exports.__spreadArray || function(to, from2, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from2.length, ar; i < l; i++) {
            if (ar || !(i in from2)) {
              if (!ar)
                ar = Array.prototype.slice.call(from2, 0, i);
              ar[i] = from2[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from2));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.reduceRight = exports.foldMap = exports.reduce = exports.mapWithIndex = exports.map = exports.flatten = exports.duplicate = exports.extend = exports.chain = exports.ap = exports.alt = exports.altW = exports.of = exports.chunksOf = exports.splitAt = exports.chop = exports.chainWithIndex = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = exports.modifyAt = exports.updateAt = exports.sort = exports.groupBy = exports.group = exports.reverse = exports.concat = exports.concatW = exports.fromArray = exports.unappend = exports.unprepend = exports.range = exports.replicate = exports.makeBy = exports.fromReadonlyArray = exports.rotate = exports.union = exports.sortBy = exports.uniq = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.append = exports.appendW = exports.prepend = exports.prependW = exports.isOutOfBound = exports.isNonEmpty = exports.empty = void 0;
      exports.filter = exports.groupSort = exports.intercalate = exports.updateLast = exports.modifyLast = exports.updateHead = exports.modifyHead = exports.matchRight = exports.matchLeft = exports.concatAll = exports.max = exports.min = exports.init = exports.last = exports.tail = exports.head = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.Comonad = exports.Alt = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getUnionSemigroup = exports.getEq = exports.getSemigroup = exports.getShow = exports.URI = exports.extract = exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = void 0;
      exports.readonlyNonEmptyArray = exports.fold = exports.prependToAll = exports.insertAt = exports.snoc = exports.cons = exports.unsnoc = exports.uncons = exports.filterWithIndex = void 0;
      var Apply_1 = require_Apply();
      var Chain_1 = require_Chain();
      var Eq_1 = require_Eq();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar2(require_internal());
      var Ord_1 = require_Ord();
      var Se = __importStar2(require_Semigroup());
      exports.empty = _.emptyReadonlyArray;
      exports.isNonEmpty = _.isNonEmpty;
      var isOutOfBound = function(i, as) {
        return i < 0 || i >= as.length;
      };
      exports.isOutOfBound = isOutOfBound;
      var prependW = function(head) {
        return function(tail) {
          return __spreadArray([head], tail, true);
        };
      };
      exports.prependW = prependW;
      exports.prepend = exports.prependW;
      var appendW = function(end) {
        return function(init3) {
          return __spreadArray(__spreadArray([], init3, true), [end], false);
        };
      };
      exports.appendW = appendW;
      exports.append = exports.appendW;
      var unsafeInsertAt = function(i, a, as) {
        if ((0, exports.isNonEmpty)(as)) {
          var xs = _.fromReadonlyNonEmptyArray(as);
          xs.splice(i, 0, a);
          return xs;
        }
        return [a];
      };
      exports.unsafeInsertAt = unsafeInsertAt;
      var unsafeUpdateAt = function(i, a, as) {
        if (as[i] === a) {
          return as;
        } else {
          var xs = _.fromReadonlyNonEmptyArray(as);
          xs[i] = a;
          return xs;
        }
      };
      exports.unsafeUpdateAt = unsafeUpdateAt;
      var uniq = function(E) {
        return function(as) {
          if (as.length === 1) {
            return as;
          }
          var out = [(0, exports.head)(as)];
          var rest = (0, exports.tail)(as);
          var _loop_1 = function(a2) {
            if (out.every(function(o) {
              return !E.equals(o, a2);
            })) {
              out.push(a2);
            }
          };
          for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
            var a = rest_1[_i];
            _loop_1(a);
          }
          return out;
        };
      };
      exports.uniq = uniq;
      var sortBy = function(ords) {
        if ((0, exports.isNonEmpty)(ords)) {
          var M = (0, Ord_1.getMonoid)();
          return (0, exports.sort)(ords.reduce(M.concat, M.empty));
        }
        return function_1.identity;
      };
      exports.sortBy = sortBy;
      var union = function(E) {
        var uniqE = (0, exports.uniq)(E);
        return function(second) {
          return function(first) {
            return uniqE((0, function_1.pipe)(first, concat2(second)));
          };
        };
      };
      exports.union = union;
      var rotate = function(n) {
        return function(as) {
          var len = as.length;
          var m = Math.round(n) % len;
          if ((0, exports.isOutOfBound)(Math.abs(m), as) || m === 0) {
            return as;
          }
          if (m < 0) {
            var _a = (0, exports.splitAt)(-m)(as), f = _a[0], s = _a[1];
            return (0, function_1.pipe)(s, concat2(f));
          } else {
            return (0, exports.rotate)(m - len)(as);
          }
        };
      };
      exports.rotate = rotate;
      var fromReadonlyArray = function(as) {
        return (0, exports.isNonEmpty)(as) ? _.some(as) : _.none;
      };
      exports.fromReadonlyArray = fromReadonlyArray;
      var makeBy = function(f) {
        return function(n) {
          var j = Math.max(0, Math.floor(n));
          var out = [f(0)];
          for (var i = 1; i < j; i++) {
            out.push(f(i));
          }
          return out;
        };
      };
      exports.makeBy = makeBy;
      var replicate = function(a) {
        return (0, exports.makeBy)(function() {
          return a;
        });
      };
      exports.replicate = replicate;
      var range = function(start, end) {
        return start <= end ? (0, exports.makeBy)(function(i) {
          return start + i;
        })(end - start + 1) : [start];
      };
      exports.range = range;
      var unprepend = function(as) {
        return [(0, exports.head)(as), (0, exports.tail)(as)];
      };
      exports.unprepend = unprepend;
      var unappend = function(as) {
        return [(0, exports.init)(as), (0, exports.last)(as)];
      };
      exports.unappend = unappend;
      var fromArray = function(as) {
        return (0, exports.fromReadonlyArray)(as.slice());
      };
      exports.fromArray = fromArray;
      function concatW(second) {
        return function(first) {
          return first.concat(second);
        };
      }
      exports.concatW = concatW;
      function concat2(x, y) {
        return y ? x.concat(y) : function(y2) {
          return y2.concat(x);
        };
      }
      exports.concat = concat2;
      var reverse = function(as) {
        return as.length === 1 ? as : __spreadArray([(0, exports.last)(as)], as.slice(0, -1).reverse(), true);
      };
      exports.reverse = reverse;
      function group(E) {
        return function(as) {
          var len = as.length;
          if (len === 0) {
            return exports.empty;
          }
          var out = [];
          var head = as[0];
          var nea = [head];
          for (var i = 1; i < len; i++) {
            var a = as[i];
            if (E.equals(a, head)) {
              nea.push(a);
            } else {
              out.push(nea);
              head = a;
              nea = [head];
            }
          }
          out.push(nea);
          return out;
        };
      }
      exports.group = group;
      var groupBy = function(f) {
        return function(as) {
          var out = {};
          for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
            var a = as_1[_i];
            var k = f(a);
            if (_.has.call(out, k)) {
              out[k].push(a);
            } else {
              out[k] = [a];
            }
          }
          return out;
        };
      };
      exports.groupBy = groupBy;
      var sort = function(O) {
        return function(as) {
          return as.length === 1 ? as : as.slice().sort(O.compare);
        };
      };
      exports.sort = sort;
      var updateAt = function(i, a) {
        return (0, exports.modifyAt)(i, function() {
          return a;
        });
      };
      exports.updateAt = updateAt;
      var modifyAt = function(i, f) {
        return function(as) {
          return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f(as[i]), as));
        };
      };
      exports.modifyAt = modifyAt;
      var zipWith = function(as, bs, f) {
        var cs = [f(as[0], bs[0])];
        var len = Math.min(as.length, bs.length);
        for (var i = 1; i < len; i++) {
          cs[i] = f(as[i], bs[i]);
        }
        return cs;
      };
      exports.zipWith = zipWith;
      function zip(as, bs) {
        if (bs === void 0) {
          return function(bs2) {
            return zip(bs2, as);
          };
        }
        return (0, exports.zipWith)(as, bs, function(a, b) {
          return [a, b];
        });
      }
      exports.zip = zip;
      var unzip = function(abs) {
        var fa = [abs[0][0]];
        var fb = [abs[0][1]];
        for (var i = 1; i < abs.length; i++) {
          fa[i] = abs[i][0];
          fb[i] = abs[i][1];
        }
        return [fa, fb];
      };
      exports.unzip = unzip;
      var prependAll = function(middle) {
        return function(as) {
          var out = [middle, as[0]];
          for (var i = 1; i < as.length; i++) {
            out.push(middle, as[i]);
          }
          return out;
        };
      };
      exports.prependAll = prependAll;
      var intersperse = function(middle) {
        return function(as) {
          var rest = (0, exports.tail)(as);
          return (0, exports.isNonEmpty)(rest) ? (0, function_1.pipe)(rest, (0, exports.prependAll)(middle), (0, exports.prepend)((0, exports.head)(as))) : as;
        };
      };
      exports.intersperse = intersperse;
      var chainWithIndex = function(f) {
        return function(as) {
          var out = _.fromReadonlyNonEmptyArray(f(0, (0, exports.head)(as)));
          for (var i = 1; i < as.length; i++) {
            out.push.apply(out, f(i, as[i]));
          }
          return out;
        };
      };
      exports.chainWithIndex = chainWithIndex;
      var chop = function(f) {
        return function(as) {
          var _a = f(as), b = _a[0], rest = _a[1];
          var out = [b];
          var next = rest;
          while ((0, exports.isNonEmpty)(next)) {
            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];
            out.push(b_1);
            next = rest_2;
          }
          return out;
        };
      };
      exports.chop = chop;
      var splitAt = function(n) {
        return function(as) {
          var m = Math.max(1, n);
          return m >= as.length ? [as, exports.empty] : [(0, function_1.pipe)(as.slice(1, m), (0, exports.prepend)((0, exports.head)(as))), as.slice(m)];
        };
      };
      exports.splitAt = splitAt;
      var chunksOf = function(n) {
        return (0, exports.chop)((0, exports.splitAt)(n));
      };
      exports.chunksOf = chunksOf;
      var _map = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f));
      };
      var _mapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f));
      };
      var _ap = function(fab, fa) {
        return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
      };
      var _chain = function(ma, f) {
        return (0, function_1.pipe)(ma, (0, exports.chain)(f));
      };
      var _extend = function(wa, f) {
        return (0, function_1.pipe)(wa, (0, exports.extend)(f));
      };
      var _reduce = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f));
      };
      var _foldMap = function(M) {
        var foldMapM = (0, exports.foldMap)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapM(f));
        };
      };
      var _reduceRight = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f));
      };
      var _traverse = function(F) {
        var traverseF = (0, exports.traverse)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseF(f));
        };
      };
      var _alt = function(fa, that) {
        return (0, function_1.pipe)(fa, (0, exports.alt)(that));
      };
      var _reduceWithIndex = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f));
      };
      var _foldMapWithIndex = function(M) {
        var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapWithIndexM(f));
        };
      };
      var _reduceRightWithIndex = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f));
      };
      var _traverseWithIndex = function(F) {
        var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseWithIndexF(f));
        };
      };
      exports.of = _.singleton;
      var altW = function(that) {
        return function(as) {
          return (0, function_1.pipe)(as, concatW(that()));
        };
      };
      exports.altW = altW;
      exports.alt = exports.altW;
      var ap = function(as) {
        return (0, exports.chain)(function(f) {
          return (0, function_1.pipe)(as, (0, exports.map)(f));
        });
      };
      exports.ap = ap;
      var chain = function(f) {
        return (0, exports.chainWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.chain = chain;
      var extend = function(f) {
        return function(as) {
          var next = (0, exports.tail)(as);
          var out = [f(as)];
          while ((0, exports.isNonEmpty)(next)) {
            out.push(f(next));
            next = (0, exports.tail)(next);
          }
          return out;
        };
      };
      exports.extend = extend;
      exports.duplicate = /* @__PURE__ */ (0, exports.extend)(function_1.identity);
      exports.flatten = /* @__PURE__ */ (0, exports.chain)(function_1.identity);
      var map = function(f) {
        return (0, exports.mapWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.map = map;
      var mapWithIndex = function(f) {
        return function(as) {
          var out = [f(0, (0, exports.head)(as))];
          for (var i = 1; i < as.length; i++) {
            out.push(f(i, as[i]));
          }
          return out;
        };
      };
      exports.mapWithIndex = mapWithIndex;
      var reduce = function(b, f) {
        return (0, exports.reduceWithIndex)(b, function(_2, b2, a) {
          return f(b2, a);
        });
      };
      exports.reduce = reduce;
      var foldMap = function(S) {
        return function(f) {
          return function(as) {
            return as.slice(1).reduce(function(s, a) {
              return S.concat(s, f(a));
            }, f(as[0]));
          };
        };
      };
      exports.foldMap = foldMap;
      var reduceRight = function(b, f) {
        return (0, exports.reduceRightWithIndex)(b, function(_2, b2, a) {
          return f(b2, a);
        });
      };
      exports.reduceRight = reduceRight;
      var reduceWithIndex = function(b, f) {
        return function(as) {
          return as.reduce(function(b2, a, i) {
            return f(i, b2, a);
          }, b);
        };
      };
      exports.reduceWithIndex = reduceWithIndex;
      var foldMapWithIndex = function(S) {
        return function(f) {
          return function(as) {
            return as.slice(1).reduce(function(s, a, i) {
              return S.concat(s, f(i + 1, a));
            }, f(0, as[0]));
          };
        };
      };
      exports.foldMapWithIndex = foldMapWithIndex;
      var reduceRightWithIndex = function(b, f) {
        return function(as) {
          return as.reduceRight(function(b2, a, i) {
            return f(i, a, b2);
          }, b);
        };
      };
      exports.reduceRightWithIndex = reduceRightWithIndex;
      var traverse = function(F) {
        var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
        return function(f) {
          return traverseWithIndexF(function(_2, a) {
            return f(a);
          });
        };
      };
      exports.traverse = traverse;
      var sequence = function(F) {
        return (0, exports.traverseWithIndex)(F)(function_1.SK);
      };
      exports.sequence = sequence;
      var traverseWithIndex = function(F) {
        return function(f) {
          return function(as) {
            var out = F.map(f(0, (0, exports.head)(as)), exports.of);
            for (var i = 1; i < as.length; i++) {
              out = F.ap(F.map(out, function(bs) {
                return function(b) {
                  return (0, function_1.pipe)(bs, (0, exports.append)(b));
                };
              }), f(i, as[i]));
            }
            return out;
          };
        };
      };
      exports.traverseWithIndex = traverseWithIndex;
      exports.extract = _.head;
      exports.URI = "ReadonlyNonEmptyArray";
      var getShow = function(S) {
        return {
          show: function(as) {
            return "[".concat(as.map(S.show).join(", "), "]");
          }
        };
      };
      exports.getShow = getShow;
      var getSemigroup = function() {
        return {
          concat: concat2
        };
      };
      exports.getSemigroup = getSemigroup;
      var getEq = function(E) {
        return (0, Eq_1.fromEquals)(function(xs, ys) {
          return xs.length === ys.length && xs.every(function(x, i) {
            return E.equals(x, ys[i]);
          });
        });
      };
      exports.getEq = getEq;
      var getUnionSemigroup = function(E) {
        var unionE = (0, exports.union)(E);
        return {
          concat: function(first, second) {
            return unionE(second)(first);
          }
        };
      };
      exports.getUnionSemigroup = getUnionSemigroup;
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.Pointed = {
        URI: exports.URI,
        of: exports.of
      };
      exports.FunctorWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex
      };
      exports.Apply = {
        URI: exports.URI,
        map: _map,
        ap: _ap
      };
      exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
      exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
      exports.Applicative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of
      };
      exports.Chain = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain
      };
      exports.chainFirst = (0, Chain_1.chainFirst)(exports.Chain);
      exports.Monad = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain
      };
      exports.Foldable = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight
      };
      exports.FoldableWithIndex = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex
      };
      exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence
      };
      exports.TraversableWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex,
        traverseWithIndex: _traverseWithIndex
      };
      exports.Alt = {
        URI: exports.URI,
        map: _map,
        alt: _alt
      };
      exports.Comonad = {
        URI: exports.URI,
        map: _map,
        extend: _extend,
        extract: exports.extract
      };
      exports.Do = (0, exports.of)(_.emptyRecord);
      exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
      var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
      exports.let = let_;
      exports.bind = (0, Chain_1.bind)(exports.Chain);
      exports.apS = (0, Apply_1.apS)(exports.Apply);
      exports.head = exports.extract;
      exports.tail = _.tail;
      var last = function(as) {
        return as[as.length - 1];
      };
      exports.last = last;
      var init2 = function(as) {
        return as.slice(0, -1);
      };
      exports.init = init2;
      var min = function(O) {
        var S = Se.min(O);
        return function(as) {
          return as.reduce(S.concat);
        };
      };
      exports.min = min;
      var max = function(O) {
        var S = Se.max(O);
        return function(as) {
          return as.reduce(S.concat);
        };
      };
      exports.max = max;
      var concatAll = function(S) {
        return function(as) {
          return as.reduce(S.concat);
        };
      };
      exports.concatAll = concatAll;
      var matchLeft = function(f) {
        return function(as) {
          return f((0, exports.head)(as), (0, exports.tail)(as));
        };
      };
      exports.matchLeft = matchLeft;
      var matchRight = function(f) {
        return function(as) {
          return f((0, exports.init)(as), (0, exports.last)(as));
        };
      };
      exports.matchRight = matchRight;
      var modifyHead = function(f) {
        return function(as) {
          return __spreadArray([f((0, exports.head)(as))], (0, exports.tail)(as), true);
        };
      };
      exports.modifyHead = modifyHead;
      var updateHead = function(a) {
        return (0, exports.modifyHead)(function() {
          return a;
        });
      };
      exports.updateHead = updateHead;
      var modifyLast = function(f) {
        return function(as) {
          return (0, function_1.pipe)((0, exports.init)(as), (0, exports.append)(f((0, exports.last)(as))));
        };
      };
      exports.modifyLast = modifyLast;
      var updateLast = function(a) {
        return (0, exports.modifyLast)(function() {
          return a;
        });
      };
      exports.updateLast = updateLast;
      var intercalate = function(S) {
        var concatAllS = (0, exports.concatAll)(S);
        return function(middle) {
          return (0, function_1.flow)((0, exports.intersperse)(middle), concatAllS);
        };
      };
      exports.intercalate = intercalate;
      function groupSort(O) {
        var sortO = (0, exports.sort)(O);
        var groupO = group(O);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? groupO(sortO(as)) : exports.empty;
        };
      }
      exports.groupSort = groupSort;
      function filter(predicate) {
        return (0, exports.filterWithIndex)(function(_2, a) {
          return predicate(a);
        });
      }
      exports.filter = filter;
      var filterWithIndex = function(predicate) {
        return function(as) {
          return (0, exports.fromReadonlyArray)(as.filter(function(a, i) {
            return predicate(i, a);
          }));
        };
      };
      exports.filterWithIndex = filterWithIndex;
      exports.uncons = exports.unprepend;
      exports.unsnoc = exports.unappend;
      function cons(head, tail) {
        return tail === void 0 ? (0, exports.prepend)(head) : (0, function_1.pipe)(tail, (0, exports.prepend)(head));
      }
      exports.cons = cons;
      var snoc = function(init3, end) {
        return (0, function_1.pipe)(init3, concat2([end]));
      };
      exports.snoc = snoc;
      var insertAt = function(i, a) {
        return function(as) {
          return i < 0 || i > as.length ? _.none : _.some((0, exports.unsafeInsertAt)(i, a, as));
        };
      };
      exports.insertAt = insertAt;
      exports.prependToAll = exports.prependAll;
      exports.fold = exports.concatAll;
      exports.readonlyNonEmptyArray = {
        URI: exports.URI,
        of: exports.of,
        map: _map,
        mapWithIndex: _mapWithIndex,
        ap: _ap,
        chain: _chain,
        extend: _extend,
        extract: exports.extract,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex,
        traverseWithIndex: _traverseWithIndex,
        alt: _alt
      };
    }
  });

  // node_modules/fp-ts/lib/NonEmptyArray.js
  var require_NonEmptyArray = __commonJS({
    "node_modules/fp-ts/lib/NonEmptyArray.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __spreadArray = exports && exports.__spreadArray || function(to, from2, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from2.length, ar; i < l; i++) {
            if (ar || !(i in from2)) {
              if (!ar)
                ar = Array.prototype.slice.call(from2, 0, i);
              ar[i] = from2[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from2));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mapWithIndex = exports.map = exports.flatten = exports.duplicate = exports.extend = exports.chain = exports.ap = exports.alt = exports.altW = exports.chunksOf = exports.splitAt = exports.chop = exports.chainWithIndex = exports.foldMap = exports.foldMapWithIndex = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = exports.of = exports.copy = exports.modifyAt = exports.updateAt = exports.insertAt = exports.sort = exports.groupBy = exports.group = exports.reverse = exports.concat = exports.concatW = exports.unappend = exports.unprepend = exports.range = exports.replicate = exports.makeBy = exports.fromArray = exports.fromReadonlyNonEmptyArray = exports.rotate = exports.union = exports.sortBy = exports.uniq = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.append = exports.appendW = exports.prepend = exports.prependW = exports.isOutOfBound = exports.isNonEmpty = void 0;
      exports.groupSort = exports.intercalate = exports.updateLast = exports.modifyLast = exports.updateHead = exports.modifyHead = exports.matchRight = exports.matchLeft = exports.concatAll = exports.max = exports.min = exports.init = exports.last = exports.tail = exports.head = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.Comonad = exports.Alt = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getUnionSemigroup = exports.getEq = exports.getSemigroup = exports.getShow = exports.URI = exports.extract = exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.reduce = void 0;
      exports.nonEmptyArray = exports.fold = exports.prependToAll = exports.snoc = exports.cons = exports.unsnoc = exports.uncons = exports.filterWithIndex = exports.filter = void 0;
      var Apply_1 = require_Apply();
      var Chain_1 = require_Chain();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar2(require_internal());
      var Ord_1 = require_Ord();
      var RNEA = __importStar2(require_ReadonlyNonEmptyArray());
      var isNonEmpty = function(as) {
        return as.length > 0;
      };
      exports.isNonEmpty = isNonEmpty;
      var isOutOfBound = function(i, as) {
        return i < 0 || i >= as.length;
      };
      exports.isOutOfBound = isOutOfBound;
      var prependW = function(head) {
        return function(tail2) {
          return __spreadArray([head], tail2, true);
        };
      };
      exports.prependW = prependW;
      exports.prepend = exports.prependW;
      var appendW = function(end) {
        return function(init3) {
          return __spreadArray(__spreadArray([], init3, true), [end], false);
        };
      };
      exports.appendW = appendW;
      exports.append = exports.appendW;
      var unsafeInsertAt = function(i, a, as) {
        if ((0, exports.isNonEmpty)(as)) {
          var xs = (0, exports.fromReadonlyNonEmptyArray)(as);
          xs.splice(i, 0, a);
          return xs;
        }
        return [a];
      };
      exports.unsafeInsertAt = unsafeInsertAt;
      var unsafeUpdateAt = function(i, a, as) {
        var xs = (0, exports.fromReadonlyNonEmptyArray)(as);
        xs[i] = a;
        return xs;
      };
      exports.unsafeUpdateAt = unsafeUpdateAt;
      var uniq = function(E) {
        return function(as) {
          if (as.length === 1) {
            return (0, exports.copy)(as);
          }
          var out = [(0, exports.head)(as)];
          var rest = (0, exports.tail)(as);
          var _loop_1 = function(a2) {
            if (out.every(function(o) {
              return !E.equals(o, a2);
            })) {
              out.push(a2);
            }
          };
          for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
            var a = rest_1[_i];
            _loop_1(a);
          }
          return out;
        };
      };
      exports.uniq = uniq;
      var sortBy = function(ords) {
        if ((0, exports.isNonEmpty)(ords)) {
          var M = (0, Ord_1.getMonoid)();
          return (0, exports.sort)(ords.reduce(M.concat, M.empty));
        }
        return exports.copy;
      };
      exports.sortBy = sortBy;
      var union = function(E) {
        var uniqE = (0, exports.uniq)(E);
        return function(second) {
          return function(first) {
            return uniqE((0, function_1.pipe)(first, concat2(second)));
          };
        };
      };
      exports.union = union;
      var rotate = function(n) {
        return function(as) {
          var len = as.length;
          var m = Math.round(n) % len;
          if ((0, exports.isOutOfBound)(Math.abs(m), as) || m === 0) {
            return (0, exports.copy)(as);
          }
          if (m < 0) {
            var _a = (0, exports.splitAt)(-m)(as), f = _a[0], s = _a[1];
            return (0, function_1.pipe)(s, concat2(f));
          } else {
            return (0, exports.rotate)(m - len)(as);
          }
        };
      };
      exports.rotate = rotate;
      exports.fromReadonlyNonEmptyArray = _.fromReadonlyNonEmptyArray;
      var fromArray = function(as) {
        return (0, exports.isNonEmpty)(as) ? _.some(as) : _.none;
      };
      exports.fromArray = fromArray;
      var makeBy = function(f) {
        return function(n) {
          var j = Math.max(0, Math.floor(n));
          var out = [f(0)];
          for (var i = 1; i < j; i++) {
            out.push(f(i));
          }
          return out;
        };
      };
      exports.makeBy = makeBy;
      var replicate = function(a) {
        return (0, exports.makeBy)(function() {
          return a;
        });
      };
      exports.replicate = replicate;
      var range = function(start, end) {
        return start <= end ? (0, exports.makeBy)(function(i) {
          return start + i;
        })(end - start + 1) : [start];
      };
      exports.range = range;
      var unprepend = function(as) {
        return [(0, exports.head)(as), (0, exports.tail)(as)];
      };
      exports.unprepend = unprepend;
      var unappend = function(as) {
        return [(0, exports.init)(as), (0, exports.last)(as)];
      };
      exports.unappend = unappend;
      function concatW(second) {
        return function(first) {
          return first.concat(second);
        };
      }
      exports.concatW = concatW;
      function concat2(x, y) {
        return y ? x.concat(y) : function(y2) {
          return y2.concat(x);
        };
      }
      exports.concat = concat2;
      var reverse = function(as) {
        return __spreadArray([(0, exports.last)(as)], as.slice(0, -1).reverse(), true);
      };
      exports.reverse = reverse;
      function group(E) {
        return function(as) {
          var len = as.length;
          if (len === 0) {
            return [];
          }
          var out = [];
          var head = as[0];
          var nea = [head];
          for (var i = 1; i < len; i++) {
            var a = as[i];
            if (E.equals(a, head)) {
              nea.push(a);
            } else {
              out.push(nea);
              head = a;
              nea = [head];
            }
          }
          out.push(nea);
          return out;
        };
      }
      exports.group = group;
      var groupBy = function(f) {
        return function(as) {
          var out = {};
          for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
            var a = as_1[_i];
            var k = f(a);
            if (_.has.call(out, k)) {
              out[k].push(a);
            } else {
              out[k] = [a];
            }
          }
          return out;
        };
      };
      exports.groupBy = groupBy;
      var sort = function(O) {
        return function(as) {
          return as.slice().sort(O.compare);
        };
      };
      exports.sort = sort;
      var insertAt = function(i, a) {
        return function(as) {
          return i < 0 || i > as.length ? _.none : _.some((0, exports.unsafeInsertAt)(i, a, as));
        };
      };
      exports.insertAt = insertAt;
      var updateAt = function(i, a) {
        return (0, exports.modifyAt)(i, function() {
          return a;
        });
      };
      exports.updateAt = updateAt;
      var modifyAt = function(i, f) {
        return function(as) {
          return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f(as[i]), as));
        };
      };
      exports.modifyAt = modifyAt;
      exports.copy = exports.fromReadonlyNonEmptyArray;
      var of = function(a) {
        return [a];
      };
      exports.of = of;
      var zipWith = function(as, bs, f) {
        var cs = [f(as[0], bs[0])];
        var len = Math.min(as.length, bs.length);
        for (var i = 1; i < len; i++) {
          cs[i] = f(as[i], bs[i]);
        }
        return cs;
      };
      exports.zipWith = zipWith;
      function zip(as, bs) {
        if (bs === void 0) {
          return function(bs2) {
            return zip(bs2, as);
          };
        }
        return (0, exports.zipWith)(as, bs, function(a, b) {
          return [a, b];
        });
      }
      exports.zip = zip;
      var unzip = function(abs) {
        var fa = [abs[0][0]];
        var fb = [abs[0][1]];
        for (var i = 1; i < abs.length; i++) {
          fa[i] = abs[i][0];
          fb[i] = abs[i][1];
        }
        return [fa, fb];
      };
      exports.unzip = unzip;
      var prependAll = function(middle) {
        return function(as) {
          var out = [middle, as[0]];
          for (var i = 1; i < as.length; i++) {
            out.push(middle, as[i]);
          }
          return out;
        };
      };
      exports.prependAll = prependAll;
      var intersperse = function(middle) {
        return function(as) {
          var rest = (0, exports.tail)(as);
          return (0, exports.isNonEmpty)(rest) ? (0, function_1.pipe)(rest, (0, exports.prependAll)(middle), (0, exports.prepend)((0, exports.head)(as))) : (0, exports.copy)(as);
        };
      };
      exports.intersperse = intersperse;
      exports.foldMapWithIndex = RNEA.foldMapWithIndex;
      exports.foldMap = RNEA.foldMap;
      var chainWithIndex = function(f) {
        return function(as) {
          var out = (0, exports.fromReadonlyNonEmptyArray)(f(0, (0, exports.head)(as)));
          for (var i = 1; i < as.length; i++) {
            out.push.apply(out, f(i, as[i]));
          }
          return out;
        };
      };
      exports.chainWithIndex = chainWithIndex;
      var chop = function(f) {
        return function(as) {
          var _a = f(as), b = _a[0], rest = _a[1];
          var out = [b];
          var next = rest;
          while ((0, exports.isNonEmpty)(next)) {
            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];
            out.push(b_1);
            next = rest_2;
          }
          return out;
        };
      };
      exports.chop = chop;
      var splitAt = function(n) {
        return function(as) {
          var m = Math.max(1, n);
          return m >= as.length ? [(0, exports.copy)(as), []] : [(0, function_1.pipe)(as.slice(1, m), (0, exports.prepend)((0, exports.head)(as))), as.slice(m)];
        };
      };
      exports.splitAt = splitAt;
      var chunksOf = function(n) {
        return (0, exports.chop)((0, exports.splitAt)(n));
      };
      exports.chunksOf = chunksOf;
      var _map = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f));
      };
      var _mapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f));
      };
      var _ap = function(fab, fa) {
        return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
      };
      var _chain = function(ma, f) {
        return (0, function_1.pipe)(ma, (0, exports.chain)(f));
      };
      var _extend = function(wa, f) {
        return (0, function_1.pipe)(wa, (0, exports.extend)(f));
      };
      var _reduce = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f));
      };
      var _foldMap = function(M) {
        var foldMapM = (0, exports.foldMap)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapM(f));
        };
      };
      var _reduceRight = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f));
      };
      var _traverse = function(F) {
        var traverseF = (0, exports.traverse)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseF(f));
        };
      };
      var _alt = function(fa, that) {
        return (0, function_1.pipe)(fa, (0, exports.alt)(that));
      };
      var _reduceWithIndex = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f));
      };
      var _foldMapWithIndex = function(M) {
        var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapWithIndexM(f));
        };
      };
      var _reduceRightWithIndex = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f));
      };
      var _traverseWithIndex = function(F) {
        var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseWithIndexF(f));
        };
      };
      var altW = function(that) {
        return function(as) {
          return (0, function_1.pipe)(as, concatW(that()));
        };
      };
      exports.altW = altW;
      exports.alt = exports.altW;
      var ap = function(as) {
        return (0, exports.chain)(function(f) {
          return (0, function_1.pipe)(as, (0, exports.map)(f));
        });
      };
      exports.ap = ap;
      var chain = function(f) {
        return (0, exports.chainWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.chain = chain;
      var extend = function(f) {
        return function(as) {
          var next = (0, exports.tail)(as);
          var out = [f(as)];
          while ((0, exports.isNonEmpty)(next)) {
            out.push(f(next));
            next = (0, exports.tail)(next);
          }
          return out;
        };
      };
      exports.extend = extend;
      exports.duplicate = (0, exports.extend)(function_1.identity);
      exports.flatten = (0, exports.chain)(function_1.identity);
      var map = function(f) {
        return (0, exports.mapWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.map = map;
      var mapWithIndex = function(f) {
        return function(as) {
          var out = [f(0, (0, exports.head)(as))];
          for (var i = 1; i < as.length; i++) {
            out.push(f(i, as[i]));
          }
          return out;
        };
      };
      exports.mapWithIndex = mapWithIndex;
      exports.reduce = RNEA.reduce;
      exports.reduceWithIndex = RNEA.reduceWithIndex;
      exports.reduceRight = RNEA.reduceRight;
      exports.reduceRightWithIndex = RNEA.reduceRightWithIndex;
      var traverse = function(F) {
        var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
        return function(f) {
          return traverseWithIndexF(function(_2, a) {
            return f(a);
          });
        };
      };
      exports.traverse = traverse;
      var sequence = function(F) {
        return (0, exports.traverseWithIndex)(F)(function(_2, a) {
          return a;
        });
      };
      exports.sequence = sequence;
      var traverseWithIndex = function(F) {
        return function(f) {
          return function(as) {
            var out = F.map(f(0, (0, exports.head)(as)), exports.of);
            for (var i = 1; i < as.length; i++) {
              out = F.ap(F.map(out, function(bs) {
                return function(b) {
                  return (0, function_1.pipe)(bs, (0, exports.append)(b));
                };
              }), f(i, as[i]));
            }
            return out;
          };
        };
      };
      exports.traverseWithIndex = traverseWithIndex;
      exports.extract = RNEA.head;
      exports.URI = "NonEmptyArray";
      exports.getShow = RNEA.getShow;
      var getSemigroup = function() {
        return {
          concat: concat2
        };
      };
      exports.getSemigroup = getSemigroup;
      exports.getEq = RNEA.getEq;
      var getUnionSemigroup = function(E) {
        var unionE = (0, exports.union)(E);
        return {
          concat: function(first, second) {
            return unionE(second)(first);
          }
        };
      };
      exports.getUnionSemigroup = getUnionSemigroup;
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.Pointed = {
        URI: exports.URI,
        of: exports.of
      };
      exports.FunctorWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex
      };
      exports.Apply = {
        URI: exports.URI,
        map: _map,
        ap: _ap
      };
      exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
      exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
      exports.Applicative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of
      };
      exports.Chain = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain
      };
      exports.chainFirst = /* @__PURE__ */ (0, Chain_1.chainFirst)(exports.Chain);
      exports.Monad = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain
      };
      exports.Foldable = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight
      };
      exports.FoldableWithIndex = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex
      };
      exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence
      };
      exports.TraversableWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex,
        traverseWithIndex: _traverseWithIndex
      };
      exports.Alt = {
        URI: exports.URI,
        map: _map,
        alt: _alt
      };
      exports.Comonad = {
        URI: exports.URI,
        map: _map,
        extend: _extend,
        extract: exports.extract
      };
      exports.Do = (0, exports.of)(_.emptyRecord);
      exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
      var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
      exports.let = let_;
      exports.bind = (0, Chain_1.bind)(exports.Chain);
      exports.apS = (0, Apply_1.apS)(exports.Apply);
      exports.head = RNEA.head;
      var tail = function(as) {
        return as.slice(1);
      };
      exports.tail = tail;
      exports.last = RNEA.last;
      var init2 = function(as) {
        return as.slice(0, -1);
      };
      exports.init = init2;
      exports.min = RNEA.min;
      exports.max = RNEA.max;
      var concatAll = function(S) {
        return function(as) {
          return as.reduce(S.concat);
        };
      };
      exports.concatAll = concatAll;
      var matchLeft = function(f) {
        return function(as) {
          return f((0, exports.head)(as), (0, exports.tail)(as));
        };
      };
      exports.matchLeft = matchLeft;
      var matchRight = function(f) {
        return function(as) {
          return f((0, exports.init)(as), (0, exports.last)(as));
        };
      };
      exports.matchRight = matchRight;
      var modifyHead = function(f) {
        return function(as) {
          return __spreadArray([f((0, exports.head)(as))], (0, exports.tail)(as), true);
        };
      };
      exports.modifyHead = modifyHead;
      var updateHead = function(a) {
        return (0, exports.modifyHead)(function() {
          return a;
        });
      };
      exports.updateHead = updateHead;
      var modifyLast = function(f) {
        return function(as) {
          return (0, function_1.pipe)((0, exports.init)(as), (0, exports.append)(f((0, exports.last)(as))));
        };
      };
      exports.modifyLast = modifyLast;
      var updateLast = function(a) {
        return (0, exports.modifyLast)(function() {
          return a;
        });
      };
      exports.updateLast = updateLast;
      exports.intercalate = RNEA.intercalate;
      function groupSort(O) {
        var sortO = (0, exports.sort)(O);
        var groupO = group(O);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? groupO(sortO(as)) : [];
        };
      }
      exports.groupSort = groupSort;
      function filter(predicate) {
        return (0, exports.filterWithIndex)(function(_2, a) {
          return predicate(a);
        });
      }
      exports.filter = filter;
      var filterWithIndex = function(predicate) {
        return function(as) {
          return (0, exports.fromArray)(as.filter(function(a, i) {
            return predicate(i, a);
          }));
        };
      };
      exports.filterWithIndex = filterWithIndex;
      exports.uncons = exports.unprepend;
      exports.unsnoc = exports.unappend;
      function cons(head, tail2) {
        return tail2 === void 0 ? (0, exports.prepend)(head) : (0, function_1.pipe)(tail2, (0, exports.prepend)(head));
      }
      exports.cons = cons;
      var snoc = function(init3, end) {
        return (0, function_1.pipe)(init3, (0, exports.append)(end));
      };
      exports.snoc = snoc;
      exports.prependToAll = exports.prependAll;
      exports.fold = RNEA.concatAll;
      exports.nonEmptyArray = {
        URI: exports.URI,
        of: exports.of,
        map: _map,
        mapWithIndex: _mapWithIndex,
        ap: _ap,
        chain: _chain,
        extend: _extend,
        extract: exports.extract,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex,
        traverseWithIndex: _traverseWithIndex,
        alt: _alt
      };
    }
  });

  // node_modules/fp-ts/lib/number.js
  var require_number = __commonJS({
    "node_modules/fp-ts/lib/number.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Field = exports.MonoidProduct = exports.MonoidSum = exports.SemigroupProduct = exports.SemigroupSum = exports.MagmaSub = exports.Show = exports.Bounded = exports.Ord = exports.Eq = exports.isNumber = void 0;
      var isNumber = function(u) {
        return typeof u === "number";
      };
      exports.isNumber = isNumber;
      exports.Eq = {
        equals: function(first, second) {
          return first === second;
        }
      };
      exports.Ord = {
        equals: exports.Eq.equals,
        compare: function(first, second) {
          return first < second ? -1 : first > second ? 1 : 0;
        }
      };
      exports.Bounded = {
        equals: exports.Eq.equals,
        compare: exports.Ord.compare,
        top: Infinity,
        bottom: -Infinity
      };
      exports.Show = {
        show: function(n) {
          return JSON.stringify(n);
        }
      };
      exports.MagmaSub = {
        concat: function(first, second) {
          return first - second;
        }
      };
      exports.SemigroupSum = {
        concat: function(first, second) {
          return first + second;
        }
      };
      exports.SemigroupProduct = {
        concat: function(first, second) {
          return first * second;
        }
      };
      exports.MonoidSum = {
        concat: exports.SemigroupSum.concat,
        empty: 0
      };
      exports.MonoidProduct = {
        concat: exports.SemigroupProduct.concat,
        empty: 1
      };
      exports.Field = {
        add: exports.SemigroupSum.concat,
        zero: 0,
        mul: exports.SemigroupProduct.concat,
        one: 1,
        sub: exports.MagmaSub.concat,
        degree: function(_) {
          return 1;
        },
        div: function(first, second) {
          return first / second;
        },
        mod: function(first, second) {
          return first % second;
        }
      };
    }
  });

  // node_modules/fp-ts/lib/Zero.js
  var require_Zero = __commonJS({
    "node_modules/fp-ts/lib/Zero.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.guard = void 0;
      function guard(F, P) {
        return function(b) {
          return b ? P.of(void 0) : F.zero();
        };
      }
      exports.guard = guard;
    }
  });

  // node_modules/fp-ts/lib/ReadonlyArray.js
  var require_ReadonlyArray = __commonJS({
    "node_modules/fp-ts/lib/ReadonlyArray.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __spreadArray = exports && exports.__spreadArray || function(to, from2, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from2.length, ar; i < l; i++) {
            if (ar || !(i in from2)) {
              if (!ar)
                ar = Array.prototype.slice.call(from2, 0, i);
              ar[i] = from2[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from2));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sort = exports.lefts = exports.rights = exports.reverse = exports.modifyAt = exports.deleteAt = exports.updateAt = exports.insertAt = exports.findLastIndex = exports.findLastMap = exports.findLast = exports.findFirstMap = exports.findFirst = exports.findIndex = exports.dropLeftWhile = exports.dropRight = exports.dropLeft = exports.spanLeft = exports.takeLeftWhile = exports.takeRight = exports.takeLeft = exports.init = exports.tail = exports.last = exports.head = exports.lookup = exports.isOutOfBound = exports.size = exports.scanRight = exports.scanLeft = exports.chainWithIndex = exports.foldRight = exports.matchRight = exports.matchRightW = exports.foldLeft = exports.matchLeft = exports.matchLeftW = exports.match = exports.matchW = exports.fromEither = exports.fromOption = exports.fromPredicate = exports.replicate = exports.makeBy = exports.appendW = exports.append = exports.prependW = exports.prepend = exports.isNonEmpty = exports.isEmpty = void 0;
      exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.foldMap = exports.reduce = exports.foldMapWithIndex = exports.duplicate = exports.extend = exports.filterWithIndex = exports.partitionMapWithIndex = exports.partitionMap = exports.partitionWithIndex = exports.partition = exports.compact = exports.filterMap = exports.filterMapWithIndex = exports.filter = exports.separate = exports.mapWithIndex = exports.map = exports.flatten = exports.chain = exports.ap = exports.alt = exports.altW = exports.zero = exports.of = exports._chainRecBreadthFirst = exports._chainRecDepthFirst = exports.difference = exports.intersection = exports.union = exports.concat = exports.concatW = exports.comprehension = exports.fromOptionK = exports.chunksOf = exports.splitAt = exports.chop = exports.sortBy = exports.uniq = exports.elem = exports.rotate = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = void 0;
      exports.toArray = exports.unsafeDeleteAt = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.fromEitherK = exports.FromEither = exports.filterE = exports.Witherable = exports.ChainRecBreadthFirst = exports.chainRecBreadthFirst = exports.ChainRecDepthFirst = exports.chainRecDepthFirst = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.Extend = exports.Alternative = exports.guard = exports.Zero = exports.Alt = exports.Unfoldable = exports.chainFirst = exports.Monad = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getOrd = exports.getEq = exports.getMonoid = exports.getSemigroup = exports.getShow = exports.URI = exports.unfold = exports.wilt = exports.wither = exports.traverseWithIndex = void 0;
      exports.readonlyArray = exports.prependToAll = exports.snoc = exports.cons = exports.range = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.intercalate = exports.exists = exports.some = exports.every = exports.empty = exports.fromArray = void 0;
      var Apply_1 = require_Apply();
      var Chain_1 = require_Chain();
      var Eq_1 = require_Eq();
      var FromEither_1 = require_FromEither();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar2(require_internal());
      var N = __importStar2(require_number());
      var Ord_1 = require_Ord();
      var RNEA = __importStar2(require_ReadonlyNonEmptyArray());
      var Separated_1 = require_Separated();
      var Witherable_1 = require_Witherable();
      var Zero_1 = require_Zero();
      var isEmpty = function(as) {
        return as.length === 0;
      };
      exports.isEmpty = isEmpty;
      exports.isNonEmpty = RNEA.isNonEmpty;
      exports.prepend = RNEA.prepend;
      exports.prependW = RNEA.prependW;
      exports.append = RNEA.append;
      exports.appendW = RNEA.appendW;
      var makeBy = function(n, f) {
        return n <= 0 ? exports.empty : RNEA.makeBy(f)(n);
      };
      exports.makeBy = makeBy;
      var replicate = function(n, a) {
        return (0, exports.makeBy)(n, function() {
          return a;
        });
      };
      exports.replicate = replicate;
      function fromPredicate(predicate) {
        return function(a) {
          return predicate(a) ? [a] : exports.empty;
        };
      }
      exports.fromPredicate = fromPredicate;
      var fromOption = function(ma) {
        return _.isNone(ma) ? exports.empty : [ma.value];
      };
      exports.fromOption = fromOption;
      var fromEither = function(e) {
        return _.isLeft(e) ? exports.empty : [e.right];
      };
      exports.fromEither = fromEither;
      var matchW = function(onEmpty, onNonEmpty) {
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? onNonEmpty(as) : onEmpty();
        };
      };
      exports.matchW = matchW;
      exports.match = exports.matchW;
      var matchLeftW = function(onEmpty, onNonEmpty) {
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();
        };
      };
      exports.matchLeftW = matchLeftW;
      exports.matchLeft = exports.matchLeftW;
      exports.foldLeft = exports.matchLeft;
      var matchRightW = function(onEmpty, onNonEmpty) {
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();
        };
      };
      exports.matchRightW = matchRightW;
      exports.matchRight = exports.matchRightW;
      exports.foldRight = exports.matchRight;
      var chainWithIndex = function(f) {
        return function(as) {
          if ((0, exports.isEmpty)(as)) {
            return exports.empty;
          }
          var out = [];
          for (var i = 0; i < as.length; i++) {
            out.push.apply(out, f(i, as[i]));
          }
          return out;
        };
      };
      exports.chainWithIndex = chainWithIndex;
      var scanLeft = function(b, f) {
        return function(as) {
          var len = as.length;
          var out = new Array(len + 1);
          out[0] = b;
          for (var i = 0; i < len; i++) {
            out[i + 1] = f(out[i], as[i]);
          }
          return out;
        };
      };
      exports.scanLeft = scanLeft;
      var scanRight = function(b, f) {
        return function(as) {
          var len = as.length;
          var out = new Array(len + 1);
          out[len] = b;
          for (var i = len - 1; i >= 0; i--) {
            out[i] = f(as[i], out[i + 1]);
          }
          return out;
        };
      };
      exports.scanRight = scanRight;
      var size = function(as) {
        return as.length;
      };
      exports.size = size;
      exports.isOutOfBound = RNEA.isOutOfBound;
      function lookup2(i, as) {
        return as === void 0 ? function(as2) {
          return lookup2(i, as2);
        } : (0, exports.isOutOfBound)(i, as) ? _.none : _.some(as[i]);
      }
      exports.lookup = lookup2;
      var head = function(as) {
        return (0, exports.isNonEmpty)(as) ? _.some(RNEA.head(as)) : _.none;
      };
      exports.head = head;
      var last = function(as) {
        return (0, exports.isNonEmpty)(as) ? _.some(RNEA.last(as)) : _.none;
      };
      exports.last = last;
      var tail = function(as) {
        return (0, exports.isNonEmpty)(as) ? _.some(RNEA.tail(as)) : _.none;
      };
      exports.tail = tail;
      var init2 = function(as) {
        return (0, exports.isNonEmpty)(as) ? _.some(RNEA.init(as)) : _.none;
      };
      exports.init = init2;
      var takeLeft = function(n) {
        return function(as) {
          return (0, exports.isOutOfBound)(n, as) ? as : n === 0 ? exports.empty : as.slice(0, n);
        };
      };
      exports.takeLeft = takeLeft;
      var takeRight = function(n) {
        return function(as) {
          return (0, exports.isOutOfBound)(n, as) ? as : n === 0 ? exports.empty : as.slice(-n);
        };
      };
      exports.takeRight = takeRight;
      function takeLeftWhile(predicate) {
        return function(as) {
          var out = [];
          for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
            var a = as_1[_i];
            if (!predicate(a)) {
              break;
            }
            out.push(a);
          }
          var len = out.length;
          return len === as.length ? as : len === 0 ? exports.empty : out;
        };
      }
      exports.takeLeftWhile = takeLeftWhile;
      var spanLeftIndex = function(as, predicate) {
        var l = as.length;
        var i = 0;
        for (; i < l; i++) {
          if (!predicate(as[i])) {
            break;
          }
        }
        return i;
      };
      function spanLeft(predicate) {
        return function(as) {
          var _a = (0, exports.splitAt)(spanLeftIndex(as, predicate))(as), init3 = _a[0], rest = _a[1];
          return { init: init3, rest };
        };
      }
      exports.spanLeft = spanLeft;
      var dropLeft = function(n) {
        return function(as) {
          return n <= 0 || (0, exports.isEmpty)(as) ? as : n >= as.length ? exports.empty : as.slice(n, as.length);
        };
      };
      exports.dropLeft = dropLeft;
      var dropRight = function(n) {
        return function(as) {
          return n <= 0 || (0, exports.isEmpty)(as) ? as : n >= as.length ? exports.empty : as.slice(0, as.length - n);
        };
      };
      exports.dropRight = dropRight;
      function dropLeftWhile(predicate) {
        return function(as) {
          var i = spanLeftIndex(as, predicate);
          return i === 0 ? as : i === as.length ? exports.empty : as.slice(i);
        };
      }
      exports.dropLeftWhile = dropLeftWhile;
      var findIndex = function(predicate) {
        return function(as) {
          for (var i = 0; i < as.length; i++) {
            if (predicate(as[i])) {
              return _.some(i);
            }
          }
          return _.none;
        };
      };
      exports.findIndex = findIndex;
      function findFirst(predicate) {
        return function(as) {
          for (var i = 0; i < as.length; i++) {
            if (predicate(as[i])) {
              return _.some(as[i]);
            }
          }
          return _.none;
        };
      }
      exports.findFirst = findFirst;
      var findFirstMap = function(f) {
        return function(as) {
          for (var i = 0; i < as.length; i++) {
            var out = f(as[i]);
            if (_.isSome(out)) {
              return out;
            }
          }
          return _.none;
        };
      };
      exports.findFirstMap = findFirstMap;
      function findLast(predicate) {
        return function(as) {
          for (var i = as.length - 1; i >= 0; i--) {
            if (predicate(as[i])) {
              return _.some(as[i]);
            }
          }
          return _.none;
        };
      }
      exports.findLast = findLast;
      var findLastMap = function(f) {
        return function(as) {
          for (var i = as.length - 1; i >= 0; i--) {
            var out = f(as[i]);
            if (_.isSome(out)) {
              return out;
            }
          }
          return _.none;
        };
      };
      exports.findLastMap = findLastMap;
      var findLastIndex = function(predicate) {
        return function(as) {
          for (var i = as.length - 1; i >= 0; i--) {
            if (predicate(as[i])) {
              return _.some(i);
            }
          }
          return _.none;
        };
      };
      exports.findLastIndex = findLastIndex;
      var insertAt = function(i, a) {
        return function(as) {
          return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));
        };
      };
      exports.insertAt = insertAt;
      var updateAt = function(i, a) {
        return (0, exports.modifyAt)(i, function() {
          return a;
        });
      };
      exports.updateAt = updateAt;
      var deleteAt = function(i) {
        return function(as) {
          return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeDeleteAt)(i, as));
        };
      };
      exports.deleteAt = deleteAt;
      var modifyAt = function(i, f) {
        return function(as) {
          return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f(as[i]), as));
        };
      };
      exports.modifyAt = modifyAt;
      var reverse = function(as) {
        return as.length <= 1 ? as : as.slice().reverse();
      };
      exports.reverse = reverse;
      var rights = function(as) {
        var r = [];
        for (var i = 0; i < as.length; i++) {
          var a = as[i];
          if (a._tag === "Right") {
            r.push(a.right);
          }
        }
        return r;
      };
      exports.rights = rights;
      var lefts = function(as) {
        var r = [];
        for (var i = 0; i < as.length; i++) {
          var a = as[i];
          if (a._tag === "Left") {
            r.push(a.left);
          }
        }
        return r;
      };
      exports.lefts = lefts;
      var sort = function(O) {
        return function(as) {
          return as.length <= 1 ? as : as.slice().sort(O.compare);
        };
      };
      exports.sort = sort;
      var zipWith = function(fa, fb, f) {
        var fc = [];
        var len = Math.min(fa.length, fb.length);
        for (var i = 0; i < len; i++) {
          fc[i] = f(fa[i], fb[i]);
        }
        return fc;
      };
      exports.zipWith = zipWith;
      function zip(as, bs) {
        if (bs === void 0) {
          return function(bs2) {
            return zip(bs2, as);
          };
        }
        return (0, exports.zipWith)(as, bs, function(a, b) {
          return [a, b];
        });
      }
      exports.zip = zip;
      var unzip = function(as) {
        var fa = [];
        var fb = [];
        for (var i = 0; i < as.length; i++) {
          fa[i] = as[i][0];
          fb[i] = as[i][1];
        }
        return [fa, fb];
      };
      exports.unzip = unzip;
      var prependAll = function(middle) {
        var f = RNEA.prependAll(middle);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : as;
        };
      };
      exports.prependAll = prependAll;
      var intersperse = function(middle) {
        var f = RNEA.intersperse(middle);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : as;
        };
      };
      exports.intersperse = intersperse;
      var rotate = function(n) {
        var f = RNEA.rotate(n);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : as;
        };
      };
      exports.rotate = rotate;
      function elem(E) {
        return function(a, as) {
          if (as === void 0) {
            var elemE_1 = elem(E);
            return function(as2) {
              return elemE_1(a, as2);
            };
          }
          var predicate = function(element) {
            return E.equals(element, a);
          };
          var i = 0;
          for (; i < as.length; i++) {
            if (predicate(as[i])) {
              return true;
            }
          }
          return false;
        };
      }
      exports.elem = elem;
      var uniq = function(E) {
        var f = RNEA.uniq(E);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : as;
        };
      };
      exports.uniq = uniq;
      var sortBy = function(ords) {
        var f = RNEA.sortBy(ords);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : as;
        };
      };
      exports.sortBy = sortBy;
      var chop = function(f) {
        var g = RNEA.chop(f);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? g(as) : exports.empty;
        };
      };
      exports.chop = chop;
      var splitAt = function(n) {
        return function(as) {
          return n >= 1 && (0, exports.isNonEmpty)(as) ? RNEA.splitAt(n)(as) : (0, exports.isEmpty)(as) ? [as, exports.empty] : [exports.empty, as];
        };
      };
      exports.splitAt = splitAt;
      var chunksOf = function(n) {
        var f = RNEA.chunksOf(n);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : exports.empty;
        };
      };
      exports.chunksOf = chunksOf;
      var fromOptionK = function(f) {
        return function() {
          var a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
          }
          return (0, exports.fromOption)(f.apply(void 0, a));
        };
      };
      exports.fromOptionK = fromOptionK;
      function comprehension(input, f, g) {
        if (g === void 0) {
          g = function() {
            return true;
          };
        }
        var go = function(scope, input2) {
          return (0, exports.isNonEmpty)(input2) ? (0, function_1.pipe)(RNEA.head(input2), (0, exports.chain)(function(x) {
            return go((0, function_1.pipe)(scope, (0, exports.append)(x)), RNEA.tail(input2));
          })) : g.apply(void 0, scope) ? [f.apply(void 0, scope)] : exports.empty;
        };
        return go(exports.empty, input);
      }
      exports.comprehension = comprehension;
      var concatW = function(second) {
        return function(first) {
          return (0, exports.isEmpty)(first) ? second : (0, exports.isEmpty)(second) ? first : first.concat(second);
        };
      };
      exports.concatW = concatW;
      exports.concat = exports.concatW;
      function union(E) {
        var unionE = RNEA.union(E);
        return function(first, second) {
          if (second === void 0) {
            var unionE_1 = union(E);
            return function(second2) {
              return unionE_1(second2, first);
            };
          }
          return (0, exports.isNonEmpty)(first) && (0, exports.isNonEmpty)(second) ? unionE(second)(first) : (0, exports.isNonEmpty)(first) ? first : second;
        };
      }
      exports.union = union;
      function intersection(E) {
        var elemE = elem(E);
        return function(xs, ys) {
          if (ys === void 0) {
            var intersectionE_1 = intersection(E);
            return function(ys2) {
              return intersectionE_1(ys2, xs);
            };
          }
          return xs.filter(function(a) {
            return elemE(a, ys);
          });
        };
      }
      exports.intersection = intersection;
      function difference(E) {
        var elemE = elem(E);
        return function(xs, ys) {
          if (ys === void 0) {
            var differenceE_1 = difference(E);
            return function(ys2) {
              return differenceE_1(ys2, xs);
            };
          }
          return xs.filter(function(a) {
            return !elemE(a, ys);
          });
        };
      }
      exports.difference = difference;
      var _map = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f));
      };
      var _mapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f));
      };
      var _ap = function(fab, fa) {
        return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
      };
      var _chain = function(ma, f) {
        return (0, function_1.pipe)(ma, (0, exports.chain)(f));
      };
      var _filter = function(fa, predicate) {
        return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));
      };
      var _filterMap = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.filterMap)(f));
      };
      var _partition = function(fa, predicate) {
        return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
      };
      var _partitionMap = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f));
      };
      var _partitionWithIndex = function(fa, predicateWithIndex) {
        return (0, function_1.pipe)(fa, (0, exports.partitionWithIndex)(predicateWithIndex));
      };
      var _partitionMapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.partitionMapWithIndex)(f));
      };
      var _alt = function(fa, that) {
        return (0, function_1.pipe)(fa, (0, exports.alt)(that));
      };
      var _reduce = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f));
      };
      var _foldMap = function(M) {
        var foldMapM = (0, exports.foldMap)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapM(f));
        };
      };
      var _reduceRight = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f));
      };
      var _reduceWithIndex = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f));
      };
      var _foldMapWithIndex = function(M) {
        var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapWithIndexM(f));
        };
      };
      var _reduceRightWithIndex = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f));
      };
      var _filterMapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.filterMapWithIndex)(f));
      };
      var _filterWithIndex = function(fa, predicateWithIndex) {
        return (0, function_1.pipe)(fa, (0, exports.filterWithIndex)(predicateWithIndex));
      };
      var _extend = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.extend)(f));
      };
      var _traverse = function(F) {
        var traverseF = (0, exports.traverse)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseF(f));
        };
      };
      var _traverseWithIndex = function(F) {
        var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseWithIndexF(f));
        };
      };
      var _chainRecDepthFirst = function(a, f) {
        return (0, function_1.pipe)(a, (0, exports.chainRecDepthFirst)(f));
      };
      exports._chainRecDepthFirst = _chainRecDepthFirst;
      var _chainRecBreadthFirst = function(a, f) {
        return (0, function_1.pipe)(a, (0, exports.chainRecBreadthFirst)(f));
      };
      exports._chainRecBreadthFirst = _chainRecBreadthFirst;
      exports.of = RNEA.of;
      var zero = function() {
        return exports.empty;
      };
      exports.zero = zero;
      var altW = function(that) {
        return function(fa) {
          return fa.concat(that());
        };
      };
      exports.altW = altW;
      exports.alt = exports.altW;
      var ap = function(fa) {
        return (0, exports.chain)(function(f) {
          return (0, function_1.pipe)(fa, (0, exports.map)(f));
        });
      };
      exports.ap = ap;
      var chain = function(f) {
        return function(ma) {
          return (0, function_1.pipe)(ma, (0, exports.chainWithIndex)(function(_2, a) {
            return f(a);
          }));
        };
      };
      exports.chain = chain;
      exports.flatten = (0, exports.chain)(function_1.identity);
      var map = function(f) {
        return function(fa) {
          return fa.map(function(a) {
            return f(a);
          });
        };
      };
      exports.map = map;
      var mapWithIndex = function(f) {
        return function(fa) {
          return fa.map(function(a, i) {
            return f(i, a);
          });
        };
      };
      exports.mapWithIndex = mapWithIndex;
      var separate = function(fa) {
        var left = [];
        var right = [];
        for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
          var e = fa_1[_i];
          if (e._tag === "Left") {
            left.push(e.left);
          } else {
            right.push(e.right);
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
      exports.separate = separate;
      var filter = function(predicate) {
        return function(as) {
          return as.filter(predicate);
        };
      };
      exports.filter = filter;
      var filterMapWithIndex = function(f) {
        return function(fa) {
          var out = [];
          for (var i = 0; i < fa.length; i++) {
            var optionB = f(i, fa[i]);
            if (_.isSome(optionB)) {
              out.push(optionB.value);
            }
          }
          return out;
        };
      };
      exports.filterMapWithIndex = filterMapWithIndex;
      var filterMap = function(f) {
        return (0, exports.filterMapWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.filterMap = filterMap;
      exports.compact = (0, exports.filterMap)(function_1.identity);
      var partition = function(predicate) {
        return (0, exports.partitionWithIndex)(function(_2, a) {
          return predicate(a);
        });
      };
      exports.partition = partition;
      var partitionWithIndex = function(predicateWithIndex) {
        return function(as) {
          var left = [];
          var right = [];
          for (var i = 0; i < as.length; i++) {
            var a = as[i];
            if (predicateWithIndex(i, a)) {
              right.push(a);
            } else {
              left.push(a);
            }
          }
          return (0, Separated_1.separated)(left, right);
        };
      };
      exports.partitionWithIndex = partitionWithIndex;
      var partitionMap = function(f) {
        return (0, exports.partitionMapWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.partitionMap = partitionMap;
      var partitionMapWithIndex = function(f) {
        return function(fa) {
          var left = [];
          var right = [];
          for (var i = 0; i < fa.length; i++) {
            var e = f(i, fa[i]);
            if (e._tag === "Left") {
              left.push(e.left);
            } else {
              right.push(e.right);
            }
          }
          return (0, Separated_1.separated)(left, right);
        };
      };
      exports.partitionMapWithIndex = partitionMapWithIndex;
      var filterWithIndex = function(predicateWithIndex) {
        return function(as) {
          return as.filter(function(a, i) {
            return predicateWithIndex(i, a);
          });
        };
      };
      exports.filterWithIndex = filterWithIndex;
      var extend = function(f) {
        return function(wa) {
          return wa.map(function(_2, i) {
            return f(wa.slice(i));
          });
        };
      };
      exports.extend = extend;
      exports.duplicate = (0, exports.extend)(function_1.identity);
      var foldMapWithIndex = function(M) {
        return function(f) {
          return function(fa) {
            return fa.reduce(function(b, a, i) {
              return M.concat(b, f(i, a));
            }, M.empty);
          };
        };
      };
      exports.foldMapWithIndex = foldMapWithIndex;
      var reduce = function(b, f) {
        return (0, exports.reduceWithIndex)(b, function(_2, b2, a) {
          return f(b2, a);
        });
      };
      exports.reduce = reduce;
      var foldMap = function(M) {
        var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
        return function(f) {
          return foldMapWithIndexM(function(_2, a) {
            return f(a);
          });
        };
      };
      exports.foldMap = foldMap;
      var reduceWithIndex = function(b, f) {
        return function(fa) {
          var len = fa.length;
          var out = b;
          for (var i = 0; i < len; i++) {
            out = f(i, out, fa[i]);
          }
          return out;
        };
      };
      exports.reduceWithIndex = reduceWithIndex;
      var reduceRight = function(b, f) {
        return (0, exports.reduceRightWithIndex)(b, function(_2, a, b2) {
          return f(a, b2);
        });
      };
      exports.reduceRight = reduceRight;
      var reduceRightWithIndex = function(b, f) {
        return function(fa) {
          return fa.reduceRight(function(b2, a, i) {
            return f(i, a, b2);
          }, b);
        };
      };
      exports.reduceRightWithIndex = reduceRightWithIndex;
      var traverse = function(F) {
        var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
        return function(f) {
          return traverseWithIndexF(function(_2, a) {
            return f(a);
          });
        };
      };
      exports.traverse = traverse;
      var sequence = function(F) {
        return function(ta) {
          return _reduce(ta, F.of((0, exports.zero)()), function(fas, fa) {
            return F.ap(F.map(fas, function(as) {
              return function(a) {
                return (0, function_1.pipe)(as, (0, exports.append)(a));
              };
            }), fa);
          });
        };
      };
      exports.sequence = sequence;
      var traverseWithIndex = function(F) {
        return function(f) {
          return (0, exports.reduceWithIndex)(F.of((0, exports.zero)()), function(i, fbs, a) {
            return F.ap(F.map(fbs, function(bs) {
              return function(b) {
                return (0, function_1.pipe)(bs, (0, exports.append)(b));
              };
            }), f(i, a));
          });
        };
      };
      exports.traverseWithIndex = traverseWithIndex;
      var wither = function(F) {
        var _witherF = _wither(F);
        return function(f) {
          return function(fa) {
            return _witherF(fa, f);
          };
        };
      };
      exports.wither = wither;
      var wilt = function(F) {
        var _wiltF = _wilt(F);
        return function(f) {
          return function(fa) {
            return _wiltF(fa, f);
          };
        };
      };
      exports.wilt = wilt;
      var unfold = function(b, f) {
        var out = [];
        var bb = b;
        while (true) {
          var mt = f(bb);
          if (_.isSome(mt)) {
            var _a = mt.value, a = _a[0], b_1 = _a[1];
            out.push(a);
            bb = b_1;
          } else {
            break;
          }
        }
        return out;
      };
      exports.unfold = unfold;
      exports.URI = "ReadonlyArray";
      var getShow = function(S) {
        return {
          show: function(as) {
            return "[".concat(as.map(S.show).join(", "), "]");
          }
        };
      };
      exports.getShow = getShow;
      var getSemigroup = function() {
        return {
          concat: function(first, second) {
            return (0, exports.isEmpty)(first) ? second : (0, exports.isEmpty)(second) ? first : first.concat(second);
          }
        };
      };
      exports.getSemigroup = getSemigroup;
      var getMonoid = function() {
        return {
          concat: (0, exports.getSemigroup)().concat,
          empty: exports.empty
        };
      };
      exports.getMonoid = getMonoid;
      var getEq = function(E) {
        return (0, Eq_1.fromEquals)(function(xs, ys) {
          return xs.length === ys.length && xs.every(function(x, i) {
            return E.equals(x, ys[i]);
          });
        });
      };
      exports.getEq = getEq;
      var getOrd = function(O) {
        return (0, Ord_1.fromCompare)(function(a, b) {
          var aLen = a.length;
          var bLen = b.length;
          var len = Math.min(aLen, bLen);
          for (var i = 0; i < len; i++) {
            var ordering = O.compare(a[i], b[i]);
            if (ordering !== 0) {
              return ordering;
            }
          }
          return N.Ord.compare(aLen, bLen);
        });
      };
      exports.getOrd = getOrd;
      var getUnionSemigroup = function(E) {
        var unionE = union(E);
        return {
          concat: function(first, second) {
            return unionE(second)(first);
          }
        };
      };
      exports.getUnionSemigroup = getUnionSemigroup;
      var getUnionMonoid = function(E) {
        return {
          concat: (0, exports.getUnionSemigroup)(E).concat,
          empty: exports.empty
        };
      };
      exports.getUnionMonoid = getUnionMonoid;
      var getIntersectionSemigroup = function(E) {
        var intersectionE = intersection(E);
        return {
          concat: function(first, second) {
            return intersectionE(second)(first);
          }
        };
      };
      exports.getIntersectionSemigroup = getIntersectionSemigroup;
      var getDifferenceMagma = function(E) {
        var differenceE = difference(E);
        return {
          concat: function(first, second) {
            return differenceE(second)(first);
          }
        };
      };
      exports.getDifferenceMagma = getDifferenceMagma;
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.Pointed = {
        URI: exports.URI,
        of: exports.of
      };
      exports.FunctorWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex
      };
      exports.Apply = {
        URI: exports.URI,
        map: _map,
        ap: _ap
      };
      exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
      exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
      exports.Applicative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of
      };
      exports.Chain = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain
      };
      exports.Monad = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain
      };
      exports.chainFirst = /* @__PURE__ */ (0, Chain_1.chainFirst)(exports.Chain);
      exports.Unfoldable = {
        URI: exports.URI,
        unfold: exports.unfold
      };
      exports.Alt = {
        URI: exports.URI,
        map: _map,
        alt: _alt
      };
      exports.Zero = {
        URI: exports.URI,
        zero: exports.zero
      };
      exports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);
      exports.Alternative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        alt: _alt,
        zero: exports.zero
      };
      exports.Extend = {
        URI: exports.URI,
        map: _map,
        extend: _extend
      };
      exports.Compactable = {
        URI: exports.URI,
        compact: exports.compact,
        separate: exports.separate
      };
      exports.Filterable = {
        URI: exports.URI,
        map: _map,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap
      };
      exports.FilterableWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex,
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex
      };
      exports.Foldable = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight
      };
      exports.FoldableWithIndex = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex
      };
      exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence
      };
      exports.TraversableWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex,
        traverse: _traverse,
        sequence: exports.sequence,
        traverseWithIndex: _traverseWithIndex
      };
      var chainRecDepthFirst = function(f) {
        return function(a) {
          var todo = __spreadArray([], f(a), true);
          var out = [];
          while (todo.length > 0) {
            var e = todo.shift();
            if (_.isLeft(e)) {
              todo.unshift.apply(todo, f(e.left));
            } else {
              out.push(e.right);
            }
          }
          return out;
        };
      };
      exports.chainRecDepthFirst = chainRecDepthFirst;
      exports.ChainRecDepthFirst = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain,
        chainRec: exports._chainRecDepthFirst
      };
      var chainRecBreadthFirst = function(f) {
        return function(a) {
          var initial = f(a);
          var todo = [];
          var out = [];
          function go(e2) {
            if (_.isLeft(e2)) {
              f(e2.left).forEach(function(v) {
                return todo.push(v);
              });
            } else {
              out.push(e2.right);
            }
          }
          for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {
            var e = initial_1[_i];
            go(e);
          }
          while (todo.length > 0) {
            go(todo.shift());
          }
          return out;
        };
      };
      exports.chainRecBreadthFirst = chainRecBreadthFirst;
      exports.ChainRecBreadthFirst = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain,
        chainRec: exports._chainRecBreadthFirst
      };
      var _wither = /* @__PURE__ */ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
      var _wilt = /* @__PURE__ */ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
      exports.Witherable = {
        URI: exports.URI,
        map: _map,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        wither: _wither,
        wilt: _wilt
      };
      exports.filterE = (0, Witherable_1.filterE)(exports.Witherable);
      exports.FromEither = {
        URI: exports.URI,
        fromEither: exports.fromEither
      };
      exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
      exports.unsafeInsertAt = RNEA.unsafeInsertAt;
      var unsafeUpdateAt = function(i, a, as) {
        return (0, exports.isNonEmpty)(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;
      };
      exports.unsafeUpdateAt = unsafeUpdateAt;
      var unsafeDeleteAt = function(i, as) {
        var xs = as.slice();
        xs.splice(i, 1);
        return xs;
      };
      exports.unsafeDeleteAt = unsafeDeleteAt;
      var toArray = function(as) {
        return as.slice();
      };
      exports.toArray = toArray;
      var fromArray = function(as) {
        return (0, exports.isEmpty)(as) ? exports.empty : as.slice();
      };
      exports.fromArray = fromArray;
      exports.empty = RNEA.empty;
      function every(predicate) {
        return function(as) {
          return as.every(predicate);
        };
      }
      exports.every = every;
      var some = function(predicate) {
        return function(as) {
          return as.some(predicate);
        };
      };
      exports.some = some;
      exports.exists = exports.some;
      var intercalate = function(M) {
        var intercalateM = RNEA.intercalate(M);
        return function(middle) {
          return (0, exports.match)(function() {
            return M.empty;
          }, intercalateM(middle));
        };
      };
      exports.intercalate = intercalate;
      exports.Do = (0, exports.of)(_.emptyRecord);
      exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
      var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
      exports.let = let_;
      exports.bind = (0, Chain_1.bind)(exports.Chain);
      exports.apS = (0, Apply_1.apS)(exports.Apply);
      exports.range = RNEA.range;
      exports.cons = RNEA.cons;
      exports.snoc = RNEA.snoc;
      exports.prependToAll = exports.prependAll;
      exports.readonlyArray = {
        URI: exports.URI,
        compact: exports.compact,
        separate: exports.separate,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        mapWithIndex: _mapWithIndex,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex,
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex,
        alt: _alt,
        zero: exports.zero,
        unfold: exports.unfold,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex,
        traverseWithIndex: _traverseWithIndex,
        extend: _extend,
        wither: _wither,
        wilt: _wilt
      };
    }
  });

  // node_modules/fp-ts/lib/Array.js
  var require_Array = __commonJS({
    "node_modules/fp-ts/lib/Array.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.lefts = exports.rights = exports.reverse = exports.modifyAt = exports.deleteAt = exports.updateAt = exports.insertAt = exports.copy = exports.findLastIndex = exports.findLastMap = exports.findLast = exports.findFirstMap = exports.findFirst = exports.findIndex = exports.dropLeftWhile = exports.dropRight = exports.dropLeft = exports.spanLeft = exports.takeLeftWhile = exports.takeRight = exports.takeLeft = exports.init = exports.tail = exports.last = exports.head = exports.lookup = exports.isOutOfBound = exports.size = exports.scanRight = exports.scanLeft = exports.chainWithIndex = exports.foldRight = exports.matchRight = exports.matchRightW = exports.foldLeft = exports.matchLeft = exports.matchLeftW = exports.match = exports.matchW = exports.fromEither = exports.fromOption = exports.fromPredicate = exports.replicate = exports.makeBy = exports.appendW = exports.append = exports.prependW = exports.prepend = exports.isNonEmpty = exports.isEmpty = void 0;
      exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.reduce = exports.foldMapWithIndex = exports.foldMap = exports.duplicate = exports.extend = exports.filterWithIndex = exports.alt = exports.altW = exports.partitionMapWithIndex = exports.partitionMap = exports.partitionWithIndex = exports.partition = exports.filter = exports.separate = exports.compact = exports.filterMap = exports.filterMapWithIndex = exports.mapWithIndex = exports.flatten = exports.chain = exports.ap = exports.map = exports.zero = exports.of = exports.difference = exports.intersection = exports.union = exports.concat = exports.concatW = exports.comprehension = exports.fromOptionK = exports.chunksOf = exports.splitAt = exports.chop = exports.sortBy = exports.uniq = exports.elem = exports.rotate = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = exports.sort = void 0;
      exports.some = exports.every = exports.unsafeDeleteAt = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.fromEitherK = exports.FromEither = exports.filterE = exports.ChainRecBreadthFirst = exports.chainRecBreadthFirst = exports.ChainRecDepthFirst = exports.chainRecDepthFirst = exports.Witherable = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.Extend = exports.Alternative = exports.guard = exports.Zero = exports.Alt = exports.Unfoldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getOrd = exports.getEq = exports.getMonoid = exports.getSemigroup = exports.getShow = exports.URI = exports.unfold = exports.wilt = exports.wither = void 0;
      exports.array = exports.prependToAll = exports.snoc = exports.cons = exports.empty = exports.range = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.intercalate = exports.exists = void 0;
      var Apply_1 = require_Apply();
      var Chain_1 = require_Chain();
      var FromEither_1 = require_FromEither();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar2(require_internal());
      var NEA = __importStar2(require_NonEmptyArray());
      var RA = __importStar2(require_ReadonlyArray());
      var Separated_1 = require_Separated();
      var Witherable_1 = require_Witherable();
      var Zero_1 = require_Zero();
      var isEmpty = function(as) {
        return as.length === 0;
      };
      exports.isEmpty = isEmpty;
      exports.isNonEmpty = NEA.isNonEmpty;
      exports.prepend = NEA.prepend;
      exports.prependW = NEA.prependW;
      exports.append = NEA.append;
      exports.appendW = NEA.appendW;
      var makeBy = function(n, f) {
        return n <= 0 ? [] : NEA.makeBy(f)(n);
      };
      exports.makeBy = makeBy;
      var replicate = function(n, a) {
        return (0, exports.makeBy)(n, function() {
          return a;
        });
      };
      exports.replicate = replicate;
      function fromPredicate(predicate) {
        return function(a) {
          return predicate(a) ? [a] : [];
        };
      }
      exports.fromPredicate = fromPredicate;
      var fromOption = function(ma) {
        return _.isNone(ma) ? [] : [ma.value];
      };
      exports.fromOption = fromOption;
      var fromEither = function(e) {
        return _.isLeft(e) ? [] : [e.right];
      };
      exports.fromEither = fromEither;
      var matchW = function(onEmpty, onNonEmpty) {
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? onNonEmpty(as) : onEmpty();
        };
      };
      exports.matchW = matchW;
      exports.match = exports.matchW;
      var matchLeftW = function(onEmpty, onNonEmpty) {
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? onNonEmpty(NEA.head(as), NEA.tail(as)) : onEmpty();
        };
      };
      exports.matchLeftW = matchLeftW;
      exports.matchLeft = exports.matchLeftW;
      exports.foldLeft = exports.matchLeft;
      var matchRightW = function(onEmpty, onNonEmpty) {
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? onNonEmpty(NEA.init(as), NEA.last(as)) : onEmpty();
        };
      };
      exports.matchRightW = matchRightW;
      exports.matchRight = exports.matchRightW;
      exports.foldRight = exports.matchRight;
      var chainWithIndex = function(f) {
        return function(as) {
          var out = [];
          for (var i = 0; i < as.length; i++) {
            out.push.apply(out, f(i, as[i]));
          }
          return out;
        };
      };
      exports.chainWithIndex = chainWithIndex;
      var scanLeft = function(b, f) {
        return function(as) {
          var len = as.length;
          var out = new Array(len + 1);
          out[0] = b;
          for (var i = 0; i < len; i++) {
            out[i + 1] = f(out[i], as[i]);
          }
          return out;
        };
      };
      exports.scanLeft = scanLeft;
      var scanRight = function(b, f) {
        return function(as) {
          var len = as.length;
          var out = new Array(len + 1);
          out[len] = b;
          for (var i = len - 1; i >= 0; i--) {
            out[i] = f(as[i], out[i + 1]);
          }
          return out;
        };
      };
      exports.scanRight = scanRight;
      var size = function(as) {
        return as.length;
      };
      exports.size = size;
      exports.isOutOfBound = NEA.isOutOfBound;
      exports.lookup = RA.lookup;
      exports.head = RA.head;
      exports.last = RA.last;
      var tail = function(as) {
        return (0, exports.isNonEmpty)(as) ? _.some(NEA.tail(as)) : _.none;
      };
      exports.tail = tail;
      var init2 = function(as) {
        return (0, exports.isNonEmpty)(as) ? _.some(NEA.init(as)) : _.none;
      };
      exports.init = init2;
      var takeLeft = function(n) {
        return function(as) {
          return (0, exports.isOutOfBound)(n, as) ? (0, exports.copy)(as) : as.slice(0, n);
        };
      };
      exports.takeLeft = takeLeft;
      var takeRight = function(n) {
        return function(as) {
          return (0, exports.isOutOfBound)(n, as) ? (0, exports.copy)(as) : n === 0 ? [] : as.slice(-n);
        };
      };
      exports.takeRight = takeRight;
      function takeLeftWhile(predicate) {
        return function(as) {
          var out = [];
          for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
            var a = as_1[_i];
            if (!predicate(a)) {
              break;
            }
            out.push(a);
          }
          return out;
        };
      }
      exports.takeLeftWhile = takeLeftWhile;
      var spanLeftIndex = function(as, predicate) {
        var l = as.length;
        var i = 0;
        for (; i < l; i++) {
          if (!predicate(as[i])) {
            break;
          }
        }
        return i;
      };
      function spanLeft(predicate) {
        return function(as) {
          var _a = (0, exports.splitAt)(spanLeftIndex(as, predicate))(as), init3 = _a[0], rest = _a[1];
          return { init: init3, rest };
        };
      }
      exports.spanLeft = spanLeft;
      var dropLeft = function(n) {
        return function(as) {
          return n <= 0 || (0, exports.isEmpty)(as) ? (0, exports.copy)(as) : n >= as.length ? [] : as.slice(n, as.length);
        };
      };
      exports.dropLeft = dropLeft;
      var dropRight = function(n) {
        return function(as) {
          return n <= 0 || (0, exports.isEmpty)(as) ? (0, exports.copy)(as) : n >= as.length ? [] : as.slice(0, as.length - n);
        };
      };
      exports.dropRight = dropRight;
      function dropLeftWhile(predicate) {
        return function(as) {
          return as.slice(spanLeftIndex(as, predicate));
        };
      }
      exports.dropLeftWhile = dropLeftWhile;
      exports.findIndex = RA.findIndex;
      function findFirst(predicate) {
        return RA.findFirst(predicate);
      }
      exports.findFirst = findFirst;
      exports.findFirstMap = RA.findFirstMap;
      function findLast(predicate) {
        return RA.findLast(predicate);
      }
      exports.findLast = findLast;
      exports.findLastMap = RA.findLastMap;
      exports.findLastIndex = RA.findLastIndex;
      var copy2 = function(as) {
        return as.slice();
      };
      exports.copy = copy2;
      var insertAt = function(i, a) {
        return function(as) {
          return i < 0 || i > as.length ? _.none : _.some((0, exports.unsafeInsertAt)(i, a, as));
        };
      };
      exports.insertAt = insertAt;
      var updateAt = function(i, a) {
        return (0, exports.modifyAt)(i, function() {
          return a;
        });
      };
      exports.updateAt = updateAt;
      var deleteAt = function(i) {
        return function(as) {
          return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeDeleteAt)(i, as));
        };
      };
      exports.deleteAt = deleteAt;
      var modifyAt = function(i, f) {
        return function(as) {
          return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f(as[i]), as));
        };
      };
      exports.modifyAt = modifyAt;
      var reverse = function(as) {
        return (0, exports.isEmpty)(as) ? [] : as.slice().reverse();
      };
      exports.reverse = reverse;
      var rights = function(as) {
        var r = [];
        for (var i = 0; i < as.length; i++) {
          var a = as[i];
          if (a._tag === "Right") {
            r.push(a.right);
          }
        }
        return r;
      };
      exports.rights = rights;
      var lefts = function(as) {
        var r = [];
        for (var i = 0; i < as.length; i++) {
          var a = as[i];
          if (a._tag === "Left") {
            r.push(a.left);
          }
        }
        return r;
      };
      exports.lefts = lefts;
      var sort = function(O) {
        return function(as) {
          return as.length <= 1 ? (0, exports.copy)(as) : as.slice().sort(O.compare);
        };
      };
      exports.sort = sort;
      var zipWith = function(fa, fb, f) {
        var fc = [];
        var len = Math.min(fa.length, fb.length);
        for (var i = 0; i < len; i++) {
          fc[i] = f(fa[i], fb[i]);
        }
        return fc;
      };
      exports.zipWith = zipWith;
      function zip(as, bs) {
        if (bs === void 0) {
          return function(bs2) {
            return zip(bs2, as);
          };
        }
        return (0, exports.zipWith)(as, bs, function(a, b) {
          return [a, b];
        });
      }
      exports.zip = zip;
      var unzip = function(as) {
        var fa = [];
        var fb = [];
        for (var i = 0; i < as.length; i++) {
          fa[i] = as[i][0];
          fb[i] = as[i][1];
        }
        return [fa, fb];
      };
      exports.unzip = unzip;
      var prependAll = function(middle) {
        var f = NEA.prependAll(middle);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : [];
        };
      };
      exports.prependAll = prependAll;
      var intersperse = function(middle) {
        var f = NEA.intersperse(middle);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : (0, exports.copy)(as);
        };
      };
      exports.intersperse = intersperse;
      var rotate = function(n) {
        var f = NEA.rotate(n);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : (0, exports.copy)(as);
        };
      };
      exports.rotate = rotate;
      exports.elem = RA.elem;
      var uniq = function(E) {
        var f = NEA.uniq(E);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : (0, exports.copy)(as);
        };
      };
      exports.uniq = uniq;
      var sortBy = function(ords) {
        var f = NEA.sortBy(ords);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : (0, exports.copy)(as);
        };
      };
      exports.sortBy = sortBy;
      var chop = function(f) {
        var g = NEA.chop(f);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? g(as) : [];
        };
      };
      exports.chop = chop;
      var splitAt = function(n) {
        return function(as) {
          return n >= 1 && (0, exports.isNonEmpty)(as) ? NEA.splitAt(n)(as) : (0, exports.isEmpty)(as) ? [(0, exports.copy)(as), []] : [[], (0, exports.copy)(as)];
        };
      };
      exports.splitAt = splitAt;
      var chunksOf = function(n) {
        var f = NEA.chunksOf(n);
        return function(as) {
          return (0, exports.isNonEmpty)(as) ? f(as) : [];
        };
      };
      exports.chunksOf = chunksOf;
      var fromOptionK = function(f) {
        return function() {
          var a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
          }
          return (0, exports.fromOption)(f.apply(void 0, a));
        };
      };
      exports.fromOptionK = fromOptionK;
      function comprehension(input, f, g) {
        if (g === void 0) {
          g = function() {
            return true;
          };
        }
        var go = function(scope, input2) {
          return (0, exports.isNonEmpty)(input2) ? (0, function_1.pipe)(NEA.head(input2), (0, exports.chain)(function(x) {
            return go((0, function_1.pipe)(scope, (0, exports.append)(x)), NEA.tail(input2));
          })) : g.apply(void 0, scope) ? [f.apply(void 0, scope)] : [];
        };
        return go([], input);
      }
      exports.comprehension = comprehension;
      var concatW = function(second) {
        return function(first) {
          return (0, exports.isEmpty)(first) ? (0, exports.copy)(second) : (0, exports.isEmpty)(second) ? (0, exports.copy)(first) : first.concat(second);
        };
      };
      exports.concatW = concatW;
      exports.concat = exports.concatW;
      function union(E) {
        var unionE = NEA.union(E);
        return function(first, second) {
          if (second === void 0) {
            var unionE_1 = union(E);
            return function(second2) {
              return unionE_1(second2, first);
            };
          }
          return (0, exports.isNonEmpty)(first) && (0, exports.isNonEmpty)(second) ? unionE(second)(first) : (0, exports.isNonEmpty)(first) ? (0, exports.copy)(first) : (0, exports.copy)(second);
        };
      }
      exports.union = union;
      function intersection(E) {
        var elemE = (0, exports.elem)(E);
        return function(xs, ys) {
          if (ys === void 0) {
            var intersectionE_1 = intersection(E);
            return function(ys2) {
              return intersectionE_1(ys2, xs);
            };
          }
          return xs.filter(function(a) {
            return elemE(a, ys);
          });
        };
      }
      exports.intersection = intersection;
      function difference(E) {
        var elemE = (0, exports.elem)(E);
        return function(xs, ys) {
          if (ys === void 0) {
            var differenceE_1 = difference(E);
            return function(ys2) {
              return differenceE_1(ys2, xs);
            };
          }
          return xs.filter(function(a) {
            return !elemE(a, ys);
          });
        };
      }
      exports.difference = difference;
      var _map = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f));
      };
      var _mapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f));
      };
      var _ap = function(fab, fa) {
        return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
      };
      var _chain = function(ma, f) {
        return (0, function_1.pipe)(ma, (0, exports.chain)(f));
      };
      var _filter = function(fa, predicate) {
        return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));
      };
      var _filterMap = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.filterMap)(f));
      };
      var _partition = function(fa, predicate) {
        return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
      };
      var _partitionMap = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f));
      };
      var _partitionWithIndex = function(fa, predicateWithIndex) {
        return (0, function_1.pipe)(fa, (0, exports.partitionWithIndex)(predicateWithIndex));
      };
      var _partitionMapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.partitionMapWithIndex)(f));
      };
      var _alt = function(fa, that) {
        return (0, function_1.pipe)(fa, (0, exports.alt)(that));
      };
      var _reduce = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f));
      };
      var _foldMap = function(M) {
        var foldMapM = (0, exports.foldMap)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapM(f));
        };
      };
      var _reduceRight = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f));
      };
      var _reduceWithIndex = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f));
      };
      var _foldMapWithIndex = function(M) {
        var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapWithIndexM(f));
        };
      };
      var _reduceRightWithIndex = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f));
      };
      var _filterMapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.filterMapWithIndex)(f));
      };
      var _filterWithIndex = function(fa, predicateWithIndex) {
        return (0, function_1.pipe)(fa, (0, exports.filterWithIndex)(predicateWithIndex));
      };
      var _extend = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.extend)(f));
      };
      var _traverse = function(F) {
        var traverseF = (0, exports.traverse)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseF(f));
        };
      };
      var _traverseWithIndex = function(F) {
        var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseWithIndexF(f));
        };
      };
      var _chainRecDepthFirst = RA._chainRecDepthFirst;
      var _chainRecBreadthFirst = RA._chainRecBreadthFirst;
      exports.of = NEA.of;
      var zero = function() {
        return [];
      };
      exports.zero = zero;
      var map = function(f) {
        return function(fa) {
          return fa.map(function(a) {
            return f(a);
          });
        };
      };
      exports.map = map;
      var ap = function(fa) {
        return (0, exports.chain)(function(f) {
          return (0, function_1.pipe)(fa, (0, exports.map)(f));
        });
      };
      exports.ap = ap;
      var chain = function(f) {
        return function(ma) {
          return (0, function_1.pipe)(ma, (0, exports.chainWithIndex)(function(_2, a) {
            return f(a);
          }));
        };
      };
      exports.chain = chain;
      exports.flatten = (0, exports.chain)(function_1.identity);
      var mapWithIndex = function(f) {
        return function(fa) {
          return fa.map(function(a, i) {
            return f(i, a);
          });
        };
      };
      exports.mapWithIndex = mapWithIndex;
      var filterMapWithIndex = function(f) {
        return function(fa) {
          var out = [];
          for (var i = 0; i < fa.length; i++) {
            var optionB = f(i, fa[i]);
            if (_.isSome(optionB)) {
              out.push(optionB.value);
            }
          }
          return out;
        };
      };
      exports.filterMapWithIndex = filterMapWithIndex;
      var filterMap = function(f) {
        return (0, exports.filterMapWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.filterMap = filterMap;
      exports.compact = (0, exports.filterMap)(function_1.identity);
      var separate = function(fa) {
        var left = [];
        var right = [];
        for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
          var e = fa_1[_i];
          if (e._tag === "Left") {
            left.push(e.left);
          } else {
            right.push(e.right);
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
      exports.separate = separate;
      var filter = function(predicate) {
        return function(as) {
          return as.filter(predicate);
        };
      };
      exports.filter = filter;
      var partition = function(predicate) {
        return (0, exports.partitionWithIndex)(function(_2, a) {
          return predicate(a);
        });
      };
      exports.partition = partition;
      var partitionWithIndex = function(predicateWithIndex) {
        return function(as) {
          var left = [];
          var right = [];
          for (var i = 0; i < as.length; i++) {
            var b = as[i];
            if (predicateWithIndex(i, b)) {
              right.push(b);
            } else {
              left.push(b);
            }
          }
          return (0, Separated_1.separated)(left, right);
        };
      };
      exports.partitionWithIndex = partitionWithIndex;
      var partitionMap = function(f) {
        return (0, exports.partitionMapWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.partitionMap = partitionMap;
      var partitionMapWithIndex = function(f) {
        return function(fa) {
          var left = [];
          var right = [];
          for (var i = 0; i < fa.length; i++) {
            var e = f(i, fa[i]);
            if (e._tag === "Left") {
              left.push(e.left);
            } else {
              right.push(e.right);
            }
          }
          return (0, Separated_1.separated)(left, right);
        };
      };
      exports.partitionMapWithIndex = partitionMapWithIndex;
      var altW = function(that) {
        return function(fa) {
          return fa.concat(that());
        };
      };
      exports.altW = altW;
      exports.alt = exports.altW;
      var filterWithIndex = function(predicateWithIndex) {
        return function(as) {
          return as.filter(function(b, i) {
            return predicateWithIndex(i, b);
          });
        };
      };
      exports.filterWithIndex = filterWithIndex;
      var extend = function(f) {
        return function(wa) {
          return wa.map(function(_2, i) {
            return f(wa.slice(i));
          });
        };
      };
      exports.extend = extend;
      exports.duplicate = (0, exports.extend)(function_1.identity);
      exports.foldMap = RA.foldMap;
      exports.foldMapWithIndex = RA.foldMapWithIndex;
      exports.reduce = RA.reduce;
      exports.reduceWithIndex = RA.reduceWithIndex;
      exports.reduceRight = RA.reduceRight;
      exports.reduceRightWithIndex = RA.reduceRightWithIndex;
      var traverse = function(F) {
        var traverseWithIndexF = (0, exports.traverseWithIndex)(F);
        return function(f) {
          return traverseWithIndexF(function(_2, a) {
            return f(a);
          });
        };
      };
      exports.traverse = traverse;
      var sequence = function(F) {
        return function(ta) {
          return _reduce(ta, F.of((0, exports.zero)()), function(fas, fa) {
            return F.ap(F.map(fas, function(as) {
              return function(a) {
                return (0, function_1.pipe)(as, (0, exports.append)(a));
              };
            }), fa);
          });
        };
      };
      exports.sequence = sequence;
      var traverseWithIndex = function(F) {
        return function(f) {
          return (0, exports.reduceWithIndex)(F.of((0, exports.zero)()), function(i, fbs, a) {
            return F.ap(F.map(fbs, function(bs) {
              return function(b) {
                return (0, function_1.pipe)(bs, (0, exports.append)(b));
              };
            }), f(i, a));
          });
        };
      };
      exports.traverseWithIndex = traverseWithIndex;
      var wither = function(F) {
        var _witherF = _wither(F);
        return function(f) {
          return function(fa) {
            return _witherF(fa, f);
          };
        };
      };
      exports.wither = wither;
      var wilt = function(F) {
        var _wiltF = _wilt(F);
        return function(f) {
          return function(fa) {
            return _wiltF(fa, f);
          };
        };
      };
      exports.wilt = wilt;
      var unfold = function(b, f) {
        var out = [];
        var bb = b;
        while (true) {
          var mt = f(bb);
          if (_.isSome(mt)) {
            var _a = mt.value, a = _a[0], b_1 = _a[1];
            out.push(a);
            bb = b_1;
          } else {
            break;
          }
        }
        return out;
      };
      exports.unfold = unfold;
      exports.URI = "Array";
      exports.getShow = RA.getShow;
      var getSemigroup = function() {
        return {
          concat: function(first, second) {
            return first.concat(second);
          }
        };
      };
      exports.getSemigroup = getSemigroup;
      var getMonoid = function() {
        return {
          concat: (0, exports.getSemigroup)().concat,
          empty: []
        };
      };
      exports.getMonoid = getMonoid;
      exports.getEq = RA.getEq;
      exports.getOrd = RA.getOrd;
      var getUnionSemigroup = function(E) {
        var unionE = union(E);
        return {
          concat: function(first, second) {
            return unionE(second)(first);
          }
        };
      };
      exports.getUnionSemigroup = getUnionSemigroup;
      var getUnionMonoid = function(E) {
        return {
          concat: (0, exports.getUnionSemigroup)(E).concat,
          empty: []
        };
      };
      exports.getUnionMonoid = getUnionMonoid;
      var getIntersectionSemigroup = function(E) {
        var intersectionE = intersection(E);
        return {
          concat: function(first, second) {
            return intersectionE(second)(first);
          }
        };
      };
      exports.getIntersectionSemigroup = getIntersectionSemigroup;
      var getDifferenceMagma = function(E) {
        var differenceE = difference(E);
        return {
          concat: function(first, second) {
            return differenceE(second)(first);
          }
        };
      };
      exports.getDifferenceMagma = getDifferenceMagma;
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.Pointed = {
        URI: exports.URI,
        of: exports.of
      };
      exports.FunctorWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex
      };
      exports.Apply = {
        URI: exports.URI,
        map: _map,
        ap: _ap
      };
      exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
      exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
      exports.Applicative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of
      };
      exports.Chain = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain
      };
      exports.chainFirst = /* @__PURE__ */ (0, Chain_1.chainFirst)(exports.Chain);
      exports.Monad = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain
      };
      exports.Unfoldable = {
        URI: exports.URI,
        unfold: exports.unfold
      };
      exports.Alt = {
        URI: exports.URI,
        map: _map,
        alt: _alt
      };
      exports.Zero = {
        URI: exports.URI,
        zero: exports.zero
      };
      exports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);
      exports.Alternative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        alt: _alt,
        zero: exports.zero
      };
      exports.Extend = {
        URI: exports.URI,
        map: _map,
        extend: _extend
      };
      exports.Compactable = {
        URI: exports.URI,
        compact: exports.compact,
        separate: exports.separate
      };
      exports.Filterable = {
        URI: exports.URI,
        map: _map,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap
      };
      exports.FilterableWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex,
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex
      };
      exports.Foldable = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight
      };
      exports.FoldableWithIndex = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex
      };
      exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence
      };
      exports.TraversableWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex,
        traverse: _traverse,
        sequence: exports.sequence,
        traverseWithIndex: _traverseWithIndex
      };
      var _wither = /* @__PURE__ */ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
      var _wilt = /* @__PURE__ */ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
      exports.Witherable = {
        URI: exports.URI,
        map: _map,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        wither: _wither,
        wilt: _wilt
      };
      exports.chainRecDepthFirst = RA.chainRecDepthFirst;
      exports.ChainRecDepthFirst = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain,
        chainRec: _chainRecDepthFirst
      };
      exports.chainRecBreadthFirst = RA.chainRecBreadthFirst;
      exports.ChainRecBreadthFirst = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain,
        chainRec: _chainRecBreadthFirst
      };
      exports.filterE = (0, Witherable_1.filterE)(exports.Witherable);
      exports.FromEither = {
        URI: exports.URI,
        fromEither: exports.fromEither
      };
      exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
      exports.unsafeInsertAt = NEA.unsafeInsertAt;
      var unsafeUpdateAt = function(i, a, as) {
        return (0, exports.isNonEmpty)(as) ? NEA.unsafeUpdateAt(i, a, as) : [];
      };
      exports.unsafeUpdateAt = unsafeUpdateAt;
      var unsafeDeleteAt = function(i, as) {
        var xs = as.slice();
        xs.splice(i, 1);
        return xs;
      };
      exports.unsafeDeleteAt = unsafeDeleteAt;
      exports.every = RA.every;
      var some = function(predicate) {
        return function(as) {
          return as.some(predicate);
        };
      };
      exports.some = some;
      exports.exists = exports.some;
      exports.intercalate = RA.intercalate;
      exports.Do = (0, exports.of)(_.emptyRecord);
      exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
      var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
      exports.let = let_;
      exports.bind = (0, Chain_1.bind)(exports.Chain);
      exports.apS = (0, Apply_1.apS)(exports.Apply);
      exports.range = NEA.range;
      exports.empty = [];
      exports.cons = NEA.cons;
      exports.snoc = NEA.snoc;
      exports.prependToAll = exports.prependAll;
      exports.array = {
        URI: exports.URI,
        compact: exports.compact,
        separate: exports.separate,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        mapWithIndex: _mapWithIndex,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex,
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex,
        alt: _alt,
        zero: exports.zero,
        unfold: exports.unfold,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        reduceWithIndex: _reduceWithIndex,
        foldMapWithIndex: _foldMapWithIndex,
        reduceRightWithIndex: _reduceRightWithIndex,
        traverseWithIndex: _traverseWithIndex,
        extend: _extend,
        wither: _wither,
        wilt: _wilt
      };
    }
  });

  // node_modules/fp-ts/lib/Predicate.js
  var require_Predicate = __commonJS({
    "node_modules/fp-ts/lib/Predicate.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.and = exports.or = exports.not = exports.Contravariant = exports.getMonoidAll = exports.getSemigroupAll = exports.getMonoidAny = exports.getSemigroupAny = exports.URI = exports.contramap = void 0;
      var function_1 = require_function();
      var contramap_ = function(predicate, f) {
        return (0, function_1.pipe)(predicate, (0, exports.contramap)(f));
      };
      var contramap = function(f) {
        return function(predicate) {
          return (0, function_1.flow)(f, predicate);
        };
      };
      exports.contramap = contramap;
      exports.URI = "Predicate";
      var getSemigroupAny = function() {
        return {
          concat: function(first, second) {
            return (0, function_1.pipe)(first, (0, exports.or)(second));
          }
        };
      };
      exports.getSemigroupAny = getSemigroupAny;
      var getMonoidAny = function() {
        return {
          concat: (0, exports.getSemigroupAny)().concat,
          empty: function_1.constFalse
        };
      };
      exports.getMonoidAny = getMonoidAny;
      var getSemigroupAll = function() {
        return {
          concat: function(first, second) {
            return (0, function_1.pipe)(first, (0, exports.and)(second));
          }
        };
      };
      exports.getSemigroupAll = getSemigroupAll;
      var getMonoidAll = function() {
        return {
          concat: (0, exports.getSemigroupAll)().concat,
          empty: function_1.constTrue
        };
      };
      exports.getMonoidAll = getMonoidAll;
      exports.Contravariant = {
        URI: exports.URI,
        contramap: contramap_
      };
      var not = function(predicate) {
        return function(a) {
          return !predicate(a);
        };
      };
      exports.not = not;
      var or = function(second) {
        return function(first) {
          return function(a) {
            return first(a) || second(a);
          };
        };
      };
      exports.or = or;
      var and = function(second) {
        return function(first) {
          return function(a) {
            return first(a) && second(a);
          };
        };
      };
      exports.and = and;
    }
  });

  // node_modules/fp-ts/lib/Option.js
  var require_Option = __commonJS({
    "node_modules/fp-ts/lib/Option.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromEither = exports.MonadThrow = exports.throwError = exports.Witherable = exports.wilt = exports.wither = exports.Traversable = exports.sequence = exports.traverse = exports.Filterable = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.Compactable = exports.separate = exports.compact = exports.Extend = exports.extend = exports.Alternative = exports.guard = exports.Zero = exports.zero = exports.Alt = exports.alt = exports.altW = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.chain = exports.Applicative = exports.Apply = exports.ap = exports.Pointed = exports.of = exports.Functor = exports.map = exports.getMonoid = exports.getOrd = exports.getEq = exports.getShow = exports.URI = exports.getRight = exports.getLeft = exports.fromPredicate = exports.some = exports.none = void 0;
      exports.getLastMonoid = exports.getFirstMonoid = exports.getApplyMonoid = exports.getApplySemigroup = exports.option = exports.mapNullable = exports.getRefinement = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toUndefined = exports.toNullable = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.duplicate = exports.chainFirst = exports.flatten = exports.apSecond = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = exports.fold = exports.match = exports.foldW = exports.matchW = exports.isNone = exports.isSome = exports.FromEither = void 0;
      var Applicative_1 = require_Applicative();
      var Apply_1 = require_Apply();
      var Chain_1 = require_Chain();
      var FromEither_1 = require_FromEither();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar2(require_internal());
      var Predicate_1 = require_Predicate();
      var Semigroup_1 = require_Semigroup();
      var Separated_1 = require_Separated();
      var Witherable_1 = require_Witherable();
      var Zero_1 = require_Zero();
      exports.none = _.none;
      exports.some = _.some;
      function fromPredicate(predicate) {
        return function(a) {
          return predicate(a) ? (0, exports.some)(a) : exports.none;
        };
      }
      exports.fromPredicate = fromPredicate;
      var getLeft = function(ma) {
        return ma._tag === "Right" ? exports.none : (0, exports.some)(ma.left);
      };
      exports.getLeft = getLeft;
      var getRight = function(ma) {
        return ma._tag === "Left" ? exports.none : (0, exports.some)(ma.right);
      };
      exports.getRight = getRight;
      var _map = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f));
      };
      var _ap = function(fab, fa) {
        return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
      };
      var _chain = function(ma, f) {
        return (0, function_1.pipe)(ma, (0, exports.chain)(f));
      };
      var _reduce = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f));
      };
      var _foldMap = function(M) {
        var foldMapM = (0, exports.foldMap)(M);
        return function(fa, f) {
          return (0, function_1.pipe)(fa, foldMapM(f));
        };
      };
      var _reduceRight = function(fa, b, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f));
      };
      var _traverse = function(F) {
        var traverseF = (0, exports.traverse)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseF(f));
        };
      };
      var _alt = function(fa, that) {
        return (0, function_1.pipe)(fa, (0, exports.alt)(that));
      };
      var _filter = function(fa, predicate) {
        return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));
      };
      var _filterMap = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.filterMap)(f));
      };
      var _extend = function(wa, f) {
        return (0, function_1.pipe)(wa, (0, exports.extend)(f));
      };
      var _partition = function(fa, predicate) {
        return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
      };
      var _partitionMap = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f));
      };
      exports.URI = "Option";
      var getShow = function(S) {
        return {
          show: function(ma) {
            return (0, exports.isNone)(ma) ? "none" : "some(".concat(S.show(ma.value), ")");
          }
        };
      };
      exports.getShow = getShow;
      var getEq = function(E) {
        return {
          equals: function(x, y) {
            return x === y || ((0, exports.isNone)(x) ? (0, exports.isNone)(y) : (0, exports.isNone)(y) ? false : E.equals(x.value, y.value));
          }
        };
      };
      exports.getEq = getEq;
      var getOrd = function(O) {
        return {
          equals: (0, exports.getEq)(O).equals,
          compare: function(x, y) {
            return x === y ? 0 : (0, exports.isSome)(x) ? (0, exports.isSome)(y) ? O.compare(x.value, y.value) : 1 : -1;
          }
        };
      };
      exports.getOrd = getOrd;
      var getMonoid = function(S) {
        return {
          concat: function(x, y) {
            return (0, exports.isNone)(x) ? y : (0, exports.isNone)(y) ? x : (0, exports.some)(S.concat(x.value, y.value));
          },
          empty: exports.none
        };
      };
      exports.getMonoid = getMonoid;
      var map = function(f) {
        return function(fa) {
          return (0, exports.isNone)(fa) ? exports.none : (0, exports.some)(f(fa.value));
        };
      };
      exports.map = map;
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.of = exports.some;
      exports.Pointed = {
        URI: exports.URI,
        of: exports.of
      };
      var ap = function(fa) {
        return function(fab) {
          return (0, exports.isNone)(fab) ? exports.none : (0, exports.isNone)(fa) ? exports.none : (0, exports.some)(fab.value(fa.value));
        };
      };
      exports.ap = ap;
      exports.Apply = {
        URI: exports.URI,
        map: _map,
        ap: _ap
      };
      exports.Applicative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of
      };
      var chain = function(f) {
        return function(ma) {
          return (0, exports.isNone)(ma) ? exports.none : f(ma.value);
        };
      };
      exports.chain = chain;
      exports.Chain = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain
      };
      exports.Monad = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain
      };
      var reduce = function(b, f) {
        return function(fa) {
          return (0, exports.isNone)(fa) ? b : f(b, fa.value);
        };
      };
      exports.reduce = reduce;
      var foldMap = function(M) {
        return function(f) {
          return function(fa) {
            return (0, exports.isNone)(fa) ? M.empty : f(fa.value);
          };
        };
      };
      exports.foldMap = foldMap;
      var reduceRight = function(b, f) {
        return function(fa) {
          return (0, exports.isNone)(fa) ? b : f(fa.value, b);
        };
      };
      exports.reduceRight = reduceRight;
      exports.Foldable = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight
      };
      var altW = function(that) {
        return function(fa) {
          return (0, exports.isNone)(fa) ? that() : fa;
        };
      };
      exports.altW = altW;
      exports.alt = exports.altW;
      exports.Alt = {
        URI: exports.URI,
        map: _map,
        alt: _alt
      };
      var zero = function() {
        return exports.none;
      };
      exports.zero = zero;
      exports.Zero = {
        URI: exports.URI,
        zero: exports.zero
      };
      exports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);
      exports.Alternative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        alt: _alt,
        zero: exports.zero
      };
      var extend = function(f) {
        return function(wa) {
          return (0, exports.isNone)(wa) ? exports.none : (0, exports.some)(f(wa));
        };
      };
      exports.extend = extend;
      exports.Extend = {
        URI: exports.URI,
        map: _map,
        extend: _extend
      };
      exports.compact = (0, exports.chain)(function_1.identity);
      var defaultSeparated = /* @__PURE__ */ (0, Separated_1.separated)(exports.none, exports.none);
      var separate = function(ma) {
        return (0, exports.isNone)(ma) ? defaultSeparated : (0, Separated_1.separated)((0, exports.getLeft)(ma.value), (0, exports.getRight)(ma.value));
      };
      exports.separate = separate;
      exports.Compactable = {
        URI: exports.URI,
        compact: exports.compact,
        separate: exports.separate
      };
      var filter = function(predicate) {
        return function(fa) {
          return (0, exports.isNone)(fa) ? exports.none : predicate(fa.value) ? fa : exports.none;
        };
      };
      exports.filter = filter;
      var filterMap = function(f) {
        return function(fa) {
          return (0, exports.isNone)(fa) ? exports.none : f(fa.value);
        };
      };
      exports.filterMap = filterMap;
      var partition = function(predicate) {
        return function(fa) {
          return (0, Separated_1.separated)(_filter(fa, (0, Predicate_1.not)(predicate)), _filter(fa, predicate));
        };
      };
      exports.partition = partition;
      var partitionMap = function(f) {
        return (0, function_1.flow)((0, exports.map)(f), exports.separate);
      };
      exports.partitionMap = partitionMap;
      exports.Filterable = {
        URI: exports.URI,
        map: _map,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap
      };
      var traverse = function(F) {
        return function(f) {
          return function(ta) {
            return (0, exports.isNone)(ta) ? F.of(exports.none) : F.map(f(ta.value), exports.some);
          };
        };
      };
      exports.traverse = traverse;
      var sequence = function(F) {
        return function(ta) {
          return (0, exports.isNone)(ta) ? F.of(exports.none) : F.map(ta.value, exports.some);
        };
      };
      exports.sequence = sequence;
      exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence
      };
      var _wither = /* @__PURE__ */ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
      var _wilt = /* @__PURE__ */ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
      var wither = function(F) {
        var _witherF = _wither(F);
        return function(f) {
          return function(fa) {
            return _witherF(fa, f);
          };
        };
      };
      exports.wither = wither;
      var wilt = function(F) {
        var _wiltF = _wilt(F);
        return function(f) {
          return function(fa) {
            return _wiltF(fa, f);
          };
        };
      };
      exports.wilt = wilt;
      exports.Witherable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        wither: _wither,
        wilt: _wilt
      };
      var throwError = function() {
        return exports.none;
      };
      exports.throwError = throwError;
      exports.MonadThrow = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain,
        throwError: exports.throwError
      };
      exports.fromEither = exports.getRight;
      exports.FromEither = {
        URI: exports.URI,
        fromEither: exports.fromEither
      };
      exports.isSome = _.isSome;
      var isNone = function(fa) {
        return fa._tag === "None";
      };
      exports.isNone = isNone;
      var matchW = function(onNone, onSome) {
        return function(ma) {
          return (0, exports.isNone)(ma) ? onNone() : onSome(ma.value);
        };
      };
      exports.matchW = matchW;
      exports.foldW = exports.matchW;
      exports.match = exports.matchW;
      exports.fold = exports.match;
      var getOrElseW = function(onNone) {
        return function(ma) {
          return (0, exports.isNone)(ma) ? onNone() : ma.value;
        };
      };
      exports.getOrElseW = getOrElseW;
      exports.getOrElse = exports.getOrElseW;
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
      exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
      exports.flatten = exports.compact;
      exports.chainFirst = /* @__PURE__ */ (0, Chain_1.chainFirst)(exports.Chain);
      exports.duplicate = (0, exports.extend)(function_1.identity);
      exports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);
      exports.chainEitherK = /* @__PURE__ */ (0, FromEither_1.chainEitherK)(exports.FromEither, exports.Chain);
      exports.chainFirstEitherK = /* @__PURE__ */ (0, FromEither_1.chainFirstEitherK)(exports.FromEither, exports.Chain);
      var fromNullable = function(a) {
        return a == null ? exports.none : (0, exports.some)(a);
      };
      exports.fromNullable = fromNullable;
      var tryCatch = function(f) {
        try {
          return (0, exports.some)(f());
        } catch (e) {
          return exports.none;
        }
      };
      exports.tryCatch = tryCatch;
      var tryCatchK = function(f) {
        return function() {
          var a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
          }
          return (0, exports.tryCatch)(function() {
            return f.apply(void 0, a);
          });
        };
      };
      exports.tryCatchK = tryCatchK;
      var fromNullableK = function(f) {
        return (0, function_1.flow)(f, exports.fromNullable);
      };
      exports.fromNullableK = fromNullableK;
      var chainNullableK = function(f) {
        return function(ma) {
          return (0, exports.isNone)(ma) ? exports.none : (0, exports.fromNullable)(f(ma.value));
        };
      };
      exports.chainNullableK = chainNullableK;
      exports.toNullable = (0, exports.match)(function_1.constNull, function_1.identity);
      exports.toUndefined = (0, exports.match)(function_1.constUndefined, function_1.identity);
      function elem(E) {
        return function(a, ma) {
          if (ma === void 0) {
            var elemE_1 = elem(E);
            return function(ma2) {
              return elemE_1(a, ma2);
            };
          }
          return (0, exports.isNone)(ma) ? false : E.equals(a, ma.value);
        };
      }
      exports.elem = elem;
      var exists = function(predicate) {
        return function(ma) {
          return (0, exports.isNone)(ma) ? false : predicate(ma.value);
        };
      };
      exports.exists = exists;
      exports.Do = (0, exports.of)(_.emptyRecord);
      exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
      var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
      exports.let = let_;
      exports.bind = (0, Chain_1.bind)(exports.Chain);
      exports.apS = (0, Apply_1.apS)(exports.Apply);
      exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
      var traverseReadonlyNonEmptyArrayWithIndex = function(f) {
        return function(as) {
          var o = f(0, _.head(as));
          if ((0, exports.isNone)(o)) {
            return exports.none;
          }
          var out = [o.value];
          for (var i = 1; i < as.length; i++) {
            var o_1 = f(i, as[i]);
            if ((0, exports.isNone)(o_1)) {
              return exports.none;
            }
            out.push(o_1.value);
          }
          return (0, exports.some)(out);
        };
      };
      exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
      var traverseReadonlyArrayWithIndex = function(f) {
        var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);
        return function(as) {
          return _.isNonEmpty(as) ? g(as) : exports.ApT;
        };
      };
      exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
      exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
      var traverseArray = function(f) {
        return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
          return f(a);
        });
      };
      exports.traverseArray = traverseArray;
      exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
      function getRefinement(getOption) {
        return function(a) {
          return (0, exports.isSome)(getOption(a));
        };
      }
      exports.getRefinement = getRefinement;
      exports.mapNullable = exports.chainNullableK;
      exports.option = {
        URI: exports.URI,
        map: _map,
        of: exports.of,
        ap: _ap,
        chain: _chain,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        zero: exports.zero,
        alt: _alt,
        extend: _extend,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        wither: _wither,
        wilt: _wilt,
        throwError: exports.throwError
      };
      exports.getApplySemigroup = (0, Apply_1.getApplySemigroup)(exports.Apply);
      exports.getApplyMonoid = (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);
      var getFirstMonoid = function() {
        return (0, exports.getMonoid)((0, Semigroup_1.first)());
      };
      exports.getFirstMonoid = getFirstMonoid;
      var getLastMonoid = function() {
        return (0, exports.getMonoid)((0, Semigroup_1.last)());
      };
      exports.getLastMonoid = getLastMonoid;
    }
  });

  // node_modules/fp-ts/lib/string.js
  var require_string = __commonJS({
    "node_modules/fp-ts/lib/string.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.endsWith = exports.startsWith = exports.includes = exports.split = exports.size = exports.isEmpty = exports.slice = exports.trimRight = exports.trimLeft = exports.trim = exports.replace = exports.toLowerCase = exports.toUpperCase = exports.isString = exports.Show = exports.Ord = exports.Monoid = exports.empty = exports.Semigroup = exports.Eq = void 0;
      var ReadonlyNonEmptyArray_1 = require_ReadonlyNonEmptyArray();
      exports.Eq = {
        equals: function(first, second) {
          return first === second;
        }
      };
      exports.Semigroup = {
        concat: function(first, second) {
          return first + second;
        }
      };
      exports.empty = "";
      exports.Monoid = {
        concat: exports.Semigroup.concat,
        empty: exports.empty
      };
      exports.Ord = {
        equals: exports.Eq.equals,
        compare: function(first, second) {
          return first < second ? -1 : first > second ? 1 : 0;
        }
      };
      exports.Show = {
        show: function(s) {
          return JSON.stringify(s);
        }
      };
      var isString = function(u) {
        return typeof u === "string";
      };
      exports.isString = isString;
      var toUpperCase = function(s) {
        return s.toUpperCase();
      };
      exports.toUpperCase = toUpperCase;
      var toLowerCase = function(s) {
        return s.toLowerCase();
      };
      exports.toLowerCase = toLowerCase;
      var replace = function(searchValue, replaceValue) {
        return function(s) {
          return s.replace(searchValue, replaceValue);
        };
      };
      exports.replace = replace;
      var trim = function(s) {
        return s.trim();
      };
      exports.trim = trim;
      var trimLeft = function(s) {
        return s.trimLeft();
      };
      exports.trimLeft = trimLeft;
      var trimRight = function(s) {
        return s.trimRight();
      };
      exports.trimRight = trimRight;
      var slice2 = function(start, end) {
        return function(s) {
          return s.slice(start, end);
        };
      };
      exports.slice = slice2;
      var isEmpty = function(s) {
        return s.length === 0;
      };
      exports.isEmpty = isEmpty;
      var size = function(s) {
        return s.length;
      };
      exports.size = size;
      var split = function(separator) {
        return function(s) {
          var out = s.split(separator);
          return (0, ReadonlyNonEmptyArray_1.isNonEmpty)(out) ? out : [s];
        };
      };
      exports.split = split;
      var includes2 = function(searchString, position) {
        return function(s) {
          return s.includes(searchString, position);
        };
      };
      exports.includes = includes2;
      var startsWith = function(searchString, position) {
        return function(s) {
          return s.startsWith(searchString, position);
        };
      };
      exports.startsWith = startsWith;
      var endsWith = function(searchString, position) {
        return function(s) {
          return s.endsWith(searchString, position);
        };
      };
      exports.endsWith = endsWith;
    }
  });

  // node_modules/fp-ts/lib/ReadonlyRecord.js
  var require_ReadonlyRecord = __commonJS({
    "node_modules/fp-ts/lib/ReadonlyRecord.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._partition = exports._filterMap = exports._filter = exports._reduceRight = exports._foldMap = exports._reduce = exports._mapWithIndex = exports._map = exports.difference = exports.intersection = exports.union = exports.elem = exports.some = exports.every = exports.fromEntries = exports.toEntries = exports.fromFoldableMap = exports.fromFoldable = exports.filterWithIndex = exports.filterMapWithIndex = exports.partitionWithIndex = exports.partitionMapWithIndex = exports.wilt = exports.wither = exports.sequence = exports.traverse = exports.traverseWithIndex = exports.singleton = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.map = exports.mapWithIndex = exports.empty = exports.lookup = exports.isSubrecord = exports.pop = exports.modifyAt = exports.updateAt = exports.deleteAt = exports.has = exports.upsertAt = exports.toUnfoldable = exports.toReadonlyArray = exports.collect = exports.keys = exports.isEmpty = exports.size = exports.toRecord = exports.fromRecord = void 0;
      exports.readonlyRecord = exports.hasOwnProperty = exports.insertAt = exports.Witherable = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getWitherable = exports.getTraversableWithIndex = exports.getTraversable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.getFoldableWithIndex = exports.getFoldable = exports.FunctorWithIndex = exports.flap = exports.Functor = exports.getMonoid = exports.getEq = exports.getShow = exports.URI = exports.separate = exports.compact = exports.reduceRight = exports.foldMap = exports.reduce = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports._sequence = exports._traverse = exports._filterWithIndex = exports._filterMapWithIndex = exports._partitionWithIndex = exports._partitionMapWithIndex = exports._reduceRightWithIndex = exports._foldMapWithIndex = exports._reduceWithIndex = exports._partitionMap = void 0;
      var Eq_1 = require_Eq();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar2(require_internal());
      var Separated_1 = require_Separated();
      var S = __importStar2(require_string());
      var Witherable_1 = require_Witherable();
      var fromRecord = function(r) {
        return Object.assign({}, r);
      };
      exports.fromRecord = fromRecord;
      var toRecord = function(r) {
        return Object.assign({}, r);
      };
      exports.toRecord = toRecord;
      var size = function(r) {
        return Object.keys(r).length;
      };
      exports.size = size;
      var isEmpty = function(r) {
        for (var k in r) {
          if (_.has.call(r, k)) {
            return false;
          }
        }
        return true;
      };
      exports.isEmpty = isEmpty;
      var keys_ = function(O) {
        return function(r) {
          return Object.keys(r).sort(O.compare);
        };
      };
      exports.keys = keys_(S.Ord);
      function collect(O) {
        if (typeof O === "function") {
          return collect(S.Ord)(O);
        }
        var keysO = keys_(O);
        return function(f) {
          return function(r) {
            var out = [];
            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
              var key = _a[_i];
              out.push(f(key, r[key]));
            }
            return out;
          };
        };
      }
      exports.collect = collect;
      exports.toReadonlyArray = /* @__PURE__ */ collect(S.Ord)(function(k, a) {
        return [k, a];
      });
      function toUnfoldable(U) {
        return function(r) {
          var sas = (0, exports.toReadonlyArray)(r);
          var len = sas.length;
          return U.unfold(0, function(b) {
            return b < len ? _.some([sas[b], b + 1]) : _.none;
          });
        };
      }
      exports.toUnfoldable = toUnfoldable;
      var upsertAt = function(k, a) {
        return function(r) {
          if (_.has.call(r, k) && r[k] === a) {
            return r;
          }
          var out = Object.assign({}, r);
          out[k] = a;
          return out;
        };
      };
      exports.upsertAt = upsertAt;
      var has = function(k, r) {
        return _.has.call(r, k);
      };
      exports.has = has;
      function deleteAt(k) {
        return function(r) {
          if (!_.has.call(r, k)) {
            return r;
          }
          var out = Object.assign({}, r);
          delete out[k];
          return out;
        };
      }
      exports.deleteAt = deleteAt;
      var updateAt = function(k, a) {
        return function(r) {
          if (!(0, exports.has)(k, r)) {
            return _.none;
          }
          if (r[k] === a) {
            return _.some(r);
          }
          var out = Object.assign({}, r);
          out[k] = a;
          return _.some(out);
        };
      };
      exports.updateAt = updateAt;
      var modifyAt = function(k, f) {
        return function(r) {
          if (!(0, exports.has)(k, r)) {
            return _.none;
          }
          var next = f(r[k]);
          if (next === r[k]) {
            return _.some(r);
          }
          var out = Object.assign({}, r);
          out[k] = next;
          return _.some(out);
        };
      };
      exports.modifyAt = modifyAt;
      function pop(k) {
        var deleteAtk = deleteAt(k);
        return function(r) {
          var oa = lookup2(k, r);
          return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);
        };
      }
      exports.pop = pop;
      function isSubrecord(E) {
        return function(me, that) {
          if (that === void 0) {
            var isSubrecordE_1 = isSubrecord(E);
            return function(that2) {
              return isSubrecordE_1(that2, me);
            };
          }
          for (var k in me) {
            if (!_.has.call(that, k) || !E.equals(me[k], that[k])) {
              return false;
            }
          }
          return true;
        };
      }
      exports.isSubrecord = isSubrecord;
      function lookup2(k, r) {
        if (r === void 0) {
          return function(r2) {
            return lookup2(k, r2);
          };
        }
        return _.has.call(r, k) ? _.some(r[k]) : _.none;
      }
      exports.lookup = lookup2;
      exports.empty = {};
      function mapWithIndex(f) {
        return function(r) {
          var out = {};
          for (var k in r) {
            if (_.has.call(r, k)) {
              out[k] = f(k, r[k]);
            }
          }
          return out;
        };
      }
      exports.mapWithIndex = mapWithIndex;
      function map(f) {
        return mapWithIndex(function(_2, a) {
          return f(a);
        });
      }
      exports.map = map;
      function reduceWithIndex() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (args.length === 2) {
          return reduceWithIndex(S.Ord).apply(void 0, args);
        }
        var keysO = keys_(args[0]);
        return function(b, f) {
          return function(fa) {
            var out = b;
            var ks = keysO(fa);
            var len = ks.length;
            for (var i = 0; i < len; i++) {
              var k = ks[i];
              out = f(k, out, fa[k]);
            }
            return out;
          };
        };
      }
      exports.reduceWithIndex = reduceWithIndex;
      function foldMapWithIndex(O) {
        if ("compare" in O) {
          var keysO_1 = keys_(O);
          return function(M) {
            return function(f) {
              return function(fa) {
                var out = M.empty;
                var ks = keysO_1(fa);
                var len = ks.length;
                for (var i = 0; i < len; i++) {
                  var k = ks[i];
                  out = M.concat(out, f(k, fa[k]));
                }
                return out;
              };
            };
          };
        }
        return foldMapWithIndex(S.Ord)(O);
      }
      exports.foldMapWithIndex = foldMapWithIndex;
      function reduceRightWithIndex() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (args.length === 2) {
          return reduceRightWithIndex(S.Ord).apply(void 0, args);
        }
        var keysO = keys_(args[0]);
        return function(b, f) {
          return function(fa) {
            var out = b;
            var ks = keysO(fa);
            var len = ks.length;
            for (var i = len - 1; i >= 0; i--) {
              var k = ks[i];
              out = f(k, fa[k], out);
            }
            return out;
          };
        };
      }
      exports.reduceRightWithIndex = reduceRightWithIndex;
      var singleton = function(k, a) {
        var _a;
        return _a = {}, _a[k] = a, _a;
      };
      exports.singleton = singleton;
      function traverseWithIndex(F) {
        var traverseWithIndexOF = _traverseWithIndex(S.Ord)(F);
        return function(f) {
          return function(ta) {
            return traverseWithIndexOF(ta, f);
          };
        };
      }
      exports.traverseWithIndex = traverseWithIndex;
      function traverse(F) {
        var traverseOF = (0, exports._traverse)(S.Ord)(F);
        return function(f) {
          return function(ta) {
            return traverseOF(ta, f);
          };
        };
      }
      exports.traverse = traverse;
      function sequence(F) {
        return (0, exports._sequence)(S.Ord)(F);
      }
      exports.sequence = sequence;
      var wither = function(F) {
        var traverseF = traverse(F);
        return function(f) {
          return function(fa) {
            return F.map((0, function_1.pipe)(fa, traverseF(f)), exports.compact);
          };
        };
      };
      exports.wither = wither;
      var wilt = function(F) {
        var traverseF = traverse(F);
        return function(f) {
          return function(fa) {
            return F.map((0, function_1.pipe)(fa, traverseF(f)), exports.separate);
          };
        };
      };
      exports.wilt = wilt;
      function partitionMapWithIndex(f) {
        return function(r) {
          var left = {};
          var right = {};
          for (var k in r) {
            if (_.has.call(r, k)) {
              var e = f(k, r[k]);
              switch (e._tag) {
                case "Left":
                  left[k] = e.left;
                  break;
                case "Right":
                  right[k] = e.right;
                  break;
              }
            }
          }
          return (0, Separated_1.separated)(left, right);
        };
      }
      exports.partitionMapWithIndex = partitionMapWithIndex;
      function partitionWithIndex(predicateWithIndex) {
        return function(r) {
          var left = {};
          var right = {};
          for (var k in r) {
            if (_.has.call(r, k)) {
              var a = r[k];
              if (predicateWithIndex(k, a)) {
                right[k] = a;
              } else {
                left[k] = a;
              }
            }
          }
          return (0, Separated_1.separated)(left, right);
        };
      }
      exports.partitionWithIndex = partitionWithIndex;
      function filterMapWithIndex(f) {
        return function(r) {
          var out = {};
          for (var k in r) {
            if (_.has.call(r, k)) {
              var ob = f(k, r[k]);
              if (_.isSome(ob)) {
                out[k] = ob.value;
              }
            }
          }
          return out;
        };
      }
      exports.filterMapWithIndex = filterMapWithIndex;
      function filterWithIndex(predicateWithIndex) {
        return function(fa) {
          var out = {};
          var changed = false;
          for (var key in fa) {
            if (_.has.call(fa, key)) {
              var a = fa[key];
              if (predicateWithIndex(key, a)) {
                out[key] = a;
              } else {
                changed = true;
              }
            }
          }
          return changed ? out : fa;
        };
      }
      exports.filterWithIndex = filterWithIndex;
      function fromFoldable(M, F) {
        var fromFoldableMapM = fromFoldableMap(M, F);
        return function(fka) {
          return fromFoldableMapM(fka, function_1.identity);
        };
      }
      exports.fromFoldable = fromFoldable;
      function fromFoldableMap(M, F) {
        return function(ta, f) {
          return F.reduce(ta, {}, function(r, a) {
            var _a = f(a), k = _a[0], b = _a[1];
            r[k] = _.has.call(r, k) ? M.concat(r[k], b) : b;
            return r;
          });
        };
      }
      exports.fromFoldableMap = fromFoldableMap;
      exports.toEntries = exports.toReadonlyArray;
      var fromEntries = function(fa) {
        var out = {};
        for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
          var a = fa_1[_i];
          out[a[0]] = a[1];
        }
        return out;
      };
      exports.fromEntries = fromEntries;
      function every(predicate) {
        return function(r) {
          for (var k in r) {
            if (!predicate(r[k])) {
              return false;
            }
          }
          return true;
        };
      }
      exports.every = every;
      function some(predicate) {
        return function(r) {
          for (var k in r) {
            if (predicate(r[k])) {
              return true;
            }
          }
          return false;
        };
      }
      exports.some = some;
      function elem(E) {
        return function(a, fa) {
          if (fa === void 0) {
            var elemE_1 = elem(E);
            return function(fa2) {
              return elemE_1(a, fa2);
            };
          }
          for (var k in fa) {
            if (E.equals(fa[k], a)) {
              return true;
            }
          }
          return false;
        };
      }
      exports.elem = elem;
      var union = function(M) {
        return function(second) {
          return function(first) {
            if ((0, exports.isEmpty)(first)) {
              return second;
            }
            if ((0, exports.isEmpty)(second)) {
              return first;
            }
            var out = {};
            for (var k in first) {
              if ((0, exports.has)(k, second)) {
                out[k] = M.concat(first[k], second[k]);
              } else {
                out[k] = first[k];
              }
            }
            for (var k in second) {
              if (!(0, exports.has)(k, out)) {
                out[k] = second[k];
              }
            }
            return out;
          };
        };
      };
      exports.union = union;
      var intersection = function(M) {
        return function(second) {
          return function(first) {
            if ((0, exports.isEmpty)(first) || (0, exports.isEmpty)(second)) {
              return exports.empty;
            }
            var out = {};
            for (var k in first) {
              if ((0, exports.has)(k, second)) {
                out[k] = M.concat(first[k], second[k]);
              }
            }
            return out;
          };
        };
      };
      exports.intersection = intersection;
      var difference = function(second) {
        return function(first) {
          if ((0, exports.isEmpty)(first)) {
            return second;
          }
          if ((0, exports.isEmpty)(second)) {
            return first;
          }
          var out = {};
          for (var k in first) {
            if (!(0, exports.has)(k, second)) {
              out[k] = first[k];
            }
          }
          for (var k in second) {
            if (!(0, exports.has)(k, first)) {
              out[k] = second[k];
            }
          }
          return out;
        };
      };
      exports.difference = difference;
      var _map = function(fa, f) {
        return (0, function_1.pipe)(fa, map(f));
      };
      exports._map = _map;
      var _mapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, mapWithIndex(f));
      };
      exports._mapWithIndex = _mapWithIndex;
      var _reduce = function(O) {
        var reduceO = reduce(O);
        return function(fa, b, f) {
          return (0, function_1.pipe)(fa, reduceO(b, f));
        };
      };
      exports._reduce = _reduce;
      var _foldMap = function(O) {
        return function(M) {
          var foldMapM = foldMap(O)(M);
          return function(fa, f) {
            return (0, function_1.pipe)(fa, foldMapM(f));
          };
        };
      };
      exports._foldMap = _foldMap;
      var _reduceRight = function(O) {
        var reduceRightO = reduceRight(O);
        return function(fa, b, f) {
          return (0, function_1.pipe)(fa, reduceRightO(b, f));
        };
      };
      exports._reduceRight = _reduceRight;
      var _filter = function(fa, predicate) {
        return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));
      };
      exports._filter = _filter;
      var _filterMap = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.filterMap)(f));
      };
      exports._filterMap = _filterMap;
      var _partition = function(fa, predicate) {
        return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));
      };
      exports._partition = _partition;
      var _partitionMap = function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f));
      };
      exports._partitionMap = _partitionMap;
      var _reduceWithIndex = function(O) {
        var reduceWithIndexO = reduceWithIndex(O);
        return function(fa, b, f) {
          return (0, function_1.pipe)(fa, reduceWithIndexO(b, f));
        };
      };
      exports._reduceWithIndex = _reduceWithIndex;
      var _foldMapWithIndex = function(O) {
        var foldMapWithIndexO = foldMapWithIndex(O);
        return function(M) {
          var foldMapWithIndexM = foldMapWithIndexO(M);
          return function(fa, f) {
            return (0, function_1.pipe)(fa, foldMapWithIndexM(f));
          };
        };
      };
      exports._foldMapWithIndex = _foldMapWithIndex;
      var _reduceRightWithIndex = function(O) {
        var reduceRightWithIndexO = reduceRightWithIndex(O);
        return function(fa, b, f) {
          return (0, function_1.pipe)(fa, reduceRightWithIndexO(b, f));
        };
      };
      exports._reduceRightWithIndex = _reduceRightWithIndex;
      var _partitionMapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, partitionMapWithIndex(f));
      };
      exports._partitionMapWithIndex = _partitionMapWithIndex;
      var _partitionWithIndex = function(fa, predicateWithIndex) {
        return (0, function_1.pipe)(fa, partitionWithIndex(predicateWithIndex));
      };
      exports._partitionWithIndex = _partitionWithIndex;
      var _filterMapWithIndex = function(fa, f) {
        return (0, function_1.pipe)(fa, filterMapWithIndex(f));
      };
      exports._filterMapWithIndex = _filterMapWithIndex;
      var _filterWithIndex = function(fa, predicateWithIndex) {
        return (0, function_1.pipe)(fa, filterWithIndex(predicateWithIndex));
      };
      exports._filterWithIndex = _filterWithIndex;
      var _traverse = function(O) {
        var traverseWithIndexO = _traverseWithIndex(O);
        return function(F) {
          var traverseWithIndexOF = traverseWithIndexO(F);
          return function(ta, f) {
            return traverseWithIndexOF(ta, (0, function_1.flow)(function_1.SK, f));
          };
        };
      };
      exports._traverse = _traverse;
      var _sequence = function(O) {
        var traverseO = (0, exports._traverse)(O);
        return function(F) {
          var traverseOF = traverseO(F);
          return function(ta) {
            return traverseOF(ta, function_1.identity);
          };
        };
      };
      exports._sequence = _sequence;
      var _traverseWithIndex = function(O) {
        return function(F) {
          var keysO = keys_(O);
          return function(ta, f) {
            var ks = keysO(ta);
            if (ks.length === 0) {
              return F.of(exports.empty);
            }
            var fr = F.of({});
            var _loop_1 = function(key2) {
              fr = F.ap(F.map(fr, function(r) {
                return function(b) {
                  var _a;
                  return Object.assign({}, r, (_a = {}, _a[key2] = b, _a));
                };
              }), f(key2, ta[key2]));
            };
            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
              var key = ks_1[_i];
              _loop_1(key);
            }
            return fr;
          };
        };
      };
      var filter = function(predicate) {
        return filterWithIndex(function(_2, a) {
          return predicate(a);
        });
      };
      exports.filter = filter;
      var filterMap = function(f) {
        return filterMapWithIndex(function(_2, a) {
          return f(a);
        });
      };
      exports.filterMap = filterMap;
      var partition = function(predicate) {
        return partitionWithIndex(function(_2, a) {
          return predicate(a);
        });
      };
      exports.partition = partition;
      var partitionMap = function(f) {
        return partitionMapWithIndex(function(_2, a) {
          return f(a);
        });
      };
      exports.partitionMap = partitionMap;
      function reduce() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (args.length === 1) {
          var reduceWithIndexO_1 = reduceWithIndex(args[0]);
          return function(b, f) {
            return reduceWithIndexO_1(b, function(_2, b2, a) {
              return f(b2, a);
            });
          };
        }
        return reduce(S.Ord).apply(void 0, args);
      }
      exports.reduce = reduce;
      function foldMap(O) {
        if ("compare" in O) {
          var foldMapWithIndexO_1 = foldMapWithIndex(O);
          return function(M) {
            var foldMapWithIndexM = foldMapWithIndexO_1(M);
            return function(f) {
              return foldMapWithIndexM(function(_2, a) {
                return f(a);
              });
            };
          };
        }
        return foldMap(S.Ord)(O);
      }
      exports.foldMap = foldMap;
      function reduceRight() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (args.length === 1) {
          var reduceRightWithIndexO_1 = reduceRightWithIndex(args[0]);
          return function(b, f) {
            return reduceRightWithIndexO_1(b, function(_2, b2, a) {
              return f(b2, a);
            });
          };
        }
        return reduceRight(S.Ord).apply(void 0, args);
      }
      exports.reduceRight = reduceRight;
      var compact = function(r) {
        var out = {};
        for (var k in r) {
          if (_.has.call(r, k)) {
            var oa = r[k];
            if (_.isSome(oa)) {
              out[k] = oa.value;
            }
          }
        }
        return out;
      };
      exports.compact = compact;
      var separate = function(r) {
        var left = {};
        var right = {};
        for (var k in r) {
          if (_.has.call(r, k)) {
            var e = r[k];
            if (_.isLeft(e)) {
              left[k] = e.left;
            } else {
              right[k] = e.right;
            }
          }
        }
        return (0, Separated_1.separated)(left, right);
      };
      exports.separate = separate;
      exports.URI = "ReadonlyRecord";
      function getShow(O) {
        if ("compare" in O) {
          return function(S2) {
            return {
              show: function(r) {
                var elements = collect(O)(function(k, a) {
                  return "".concat(JSON.stringify(k), ": ").concat(S2.show(a));
                })(r).join(", ");
                return elements === "" ? "{}" : "{ ".concat(elements, " }");
              }
            };
          };
        }
        return getShow(S.Ord)(O);
      }
      exports.getShow = getShow;
      function getEq(E) {
        var isSubrecordE = isSubrecord(E);
        return (0, Eq_1.fromEquals)(function(x, y) {
          return isSubrecordE(x)(y) && isSubrecordE(y)(x);
        });
      }
      exports.getEq = getEq;
      function getMonoid(S2) {
        return {
          concat: function(first, second) {
            if ((0, exports.isEmpty)(first)) {
              return second;
            }
            if ((0, exports.isEmpty)(second)) {
              return first;
            }
            var r = Object.assign({}, first);
            for (var k in second) {
              if (_.has.call(second, k)) {
                r[k] = _.has.call(first, k) ? S2.concat(first[k], second[k]) : second[k];
              }
            }
            return r;
          },
          empty: exports.empty
        };
      }
      exports.getMonoid = getMonoid;
      exports.Functor = {
        URI: exports.URI,
        map: exports._map
      };
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.FunctorWithIndex = {
        URI: exports.URI,
        map: exports._map,
        mapWithIndex: exports._mapWithIndex
      };
      var getFoldable = function(O) {
        return {
          URI: exports.URI,
          reduce: (0, exports._reduce)(O),
          foldMap: (0, exports._foldMap)(O),
          reduceRight: (0, exports._reduceRight)(O)
        };
      };
      exports.getFoldable = getFoldable;
      var getFoldableWithIndex = function(O) {
        return {
          URI: exports.URI,
          reduce: (0, exports._reduce)(O),
          foldMap: (0, exports._foldMap)(O),
          reduceRight: (0, exports._reduceRight)(O),
          reduceWithIndex: (0, exports._reduceWithIndex)(O),
          foldMapWithIndex: (0, exports._foldMapWithIndex)(O),
          reduceRightWithIndex: (0, exports._reduceRightWithIndex)(O)
        };
      };
      exports.getFoldableWithIndex = getFoldableWithIndex;
      exports.Compactable = {
        URI: exports.URI,
        compact: exports.compact,
        separate: exports.separate
      };
      exports.Filterable = {
        URI: exports.URI,
        map: exports._map,
        compact: exports.compact,
        separate: exports.separate,
        filter: exports._filter,
        filterMap: exports._filterMap,
        partition: exports._partition,
        partitionMap: exports._partitionMap
      };
      exports.FilterableWithIndex = {
        URI: exports.URI,
        map: exports._map,
        mapWithIndex: exports._mapWithIndex,
        compact: exports.compact,
        separate: exports.separate,
        filter: exports._filter,
        filterMap: exports._filterMap,
        partition: exports._partition,
        partitionMap: exports._partitionMap,
        filterMapWithIndex: exports._filterMapWithIndex,
        filterWithIndex: exports._filterWithIndex,
        partitionMapWithIndex: exports._partitionMapWithIndex,
        partitionWithIndex: exports._partitionWithIndex
      };
      var getTraversable = function(O) {
        return {
          URI: exports.URI,
          map: exports._map,
          reduce: (0, exports._reduce)(O),
          foldMap: (0, exports._foldMap)(O),
          reduceRight: (0, exports._reduceRight)(O),
          traverse: (0, exports._traverse)(O),
          sequence: (0, exports._sequence)(O)
        };
      };
      exports.getTraversable = getTraversable;
      var getTraversableWithIndex = function(O) {
        return {
          URI: exports.URI,
          map: exports._map,
          mapWithIndex: exports._mapWithIndex,
          reduce: (0, exports._reduce)(O),
          foldMap: (0, exports._foldMap)(O),
          reduceRight: (0, exports._reduceRight)(O),
          reduceWithIndex: (0, exports._reduceWithIndex)(O),
          foldMapWithIndex: (0, exports._foldMapWithIndex)(O),
          reduceRightWithIndex: (0, exports._reduceRightWithIndex)(O),
          traverse: (0, exports._traverse)(O),
          sequence: (0, exports._sequence)(O),
          traverseWithIndex: _traverseWithIndex(O)
        };
      };
      exports.getTraversableWithIndex = getTraversableWithIndex;
      var getWitherable = function(O) {
        var T = (0, exports.getTraversable)(O);
        return {
          URI: exports.URI,
          map: exports._map,
          reduce: (0, exports._reduce)(O),
          foldMap: (0, exports._foldMap)(O),
          reduceRight: (0, exports._reduceRight)(O),
          traverse: T.traverse,
          sequence: T.sequence,
          compact: exports.compact,
          separate: exports.separate,
          filter: exports._filter,
          filterMap: exports._filterMap,
          partition: exports._partition,
          partitionMap: exports._partitionMap,
          wither: (0, Witherable_1.witherDefault)(T, exports.Compactable),
          wilt: (0, Witherable_1.wiltDefault)(T, exports.Compactable)
        };
      };
      exports.getWitherable = getWitherable;
      var getUnionSemigroup = function(S2) {
        var unionS = (0, exports.union)(S2);
        return {
          concat: function(first, second) {
            return unionS(second)(first);
          }
        };
      };
      exports.getUnionSemigroup = getUnionSemigroup;
      var getUnionMonoid = function(S2) {
        return {
          concat: (0, exports.getUnionSemigroup)(S2).concat,
          empty: exports.empty
        };
      };
      exports.getUnionMonoid = getUnionMonoid;
      var getIntersectionSemigroup = function(S2) {
        var intersectionS = (0, exports.intersection)(S2);
        return {
          concat: function(first, second) {
            return intersectionS(second)(first);
          }
        };
      };
      exports.getIntersectionSemigroup = getIntersectionSemigroup;
      var getDifferenceMagma = function() {
        return {
          concat: function(first, second) {
            return (0, exports.difference)(second)(first);
          }
        };
      };
      exports.getDifferenceMagma = getDifferenceMagma;
      exports.Foldable = {
        URI: exports.URI,
        reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
        foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
        reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord)
      };
      exports.FoldableWithIndex = {
        URI: exports.URI,
        reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
        foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
        reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord),
        reduceWithIndex: /* @__PURE__ */ (0, exports._reduceWithIndex)(S.Ord),
        foldMapWithIndex: /* @__PURE__ */ (0, exports._foldMapWithIndex)(S.Ord),
        reduceRightWithIndex: /* @__PURE__ */ (0, exports._reduceRightWithIndex)(S.Ord)
      };
      exports.Traversable = {
        URI: exports.URI,
        map: exports._map,
        reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
        foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
        reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord),
        traverse: /* @__PURE__ */ (0, exports._traverse)(S.Ord),
        sequence
      };
      exports.TraversableWithIndex = {
        URI: exports.URI,
        map: exports._map,
        mapWithIndex: exports._mapWithIndex,
        reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
        foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
        reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord),
        reduceWithIndex: /* @__PURE__ */ (0, exports._reduceWithIndex)(S.Ord),
        foldMapWithIndex: /* @__PURE__ */ (0, exports._foldMapWithIndex)(S.Ord),
        reduceRightWithIndex: /* @__PURE__ */ (0, exports._reduceRightWithIndex)(S.Ord),
        traverse: /* @__PURE__ */ (0, exports._traverse)(S.Ord),
        sequence,
        traverseWithIndex: /* @__PURE__ */ _traverseWithIndex(S.Ord)
      };
      var _wither = /* @__PURE__ */ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
      var _wilt = /* @__PURE__ */ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
      exports.Witherable = {
        URI: exports.URI,
        map: exports._map,
        reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
        foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
        reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord),
        traverse: /* @__PURE__ */ (0, exports._traverse)(S.Ord),
        sequence,
        compact: exports.compact,
        separate: exports.separate,
        filter: exports._filter,
        filterMap: exports._filterMap,
        partition: exports._partition,
        partitionMap: exports._partitionMap,
        wither: _wither,
        wilt: _wilt
      };
      exports.insertAt = exports.upsertAt;
      function hasOwnProperty(k, r) {
        return _.has.call(r === void 0 ? this : r, k);
      }
      exports.hasOwnProperty = hasOwnProperty;
      exports.readonlyRecord = {
        URI: exports.URI,
        map: exports._map,
        reduce: /* @__PURE__ */ (0, exports._reduce)(S.Ord),
        foldMap: /* @__PURE__ */ (0, exports._foldMap)(S.Ord),
        reduceRight: /* @__PURE__ */ (0, exports._reduceRight)(S.Ord),
        traverse: /* @__PURE__ */ (0, exports._traverse)(S.Ord),
        sequence,
        compact: exports.compact,
        separate: exports.separate,
        filter: exports._filter,
        filterMap: exports._filterMap,
        partition: exports._partition,
        partitionMap: exports._partitionMap,
        mapWithIndex: exports._mapWithIndex,
        reduceWithIndex: /* @__PURE__ */ (0, exports._reduceWithIndex)(S.Ord),
        foldMapWithIndex: /* @__PURE__ */ (0, exports._foldMapWithIndex)(S.Ord),
        reduceRightWithIndex: /* @__PURE__ */ (0, exports._reduceRightWithIndex)(S.Ord),
        filterMapWithIndex: exports._filterMapWithIndex,
        filterWithIndex: exports._filterWithIndex,
        partitionMapWithIndex: exports._partitionMapWithIndex,
        partitionWithIndex: exports._partitionWithIndex,
        traverseWithIndex: /* @__PURE__ */ _traverseWithIndex(S.Ord),
        wither: _wither,
        wilt: _wilt
      };
    }
  });

  // node_modules/fp-ts/lib/Record.js
  var require_Record = __commonJS({
    "node_modules/fp-ts/lib/Record.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __assign2 = exports && exports.__assign || function() {
        __assign2 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign2.apply(this, arguments);
      };
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getShow = exports.URI = exports.separate = exports.compact = exports.reduceRight = exports.foldMap = exports.reduce = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.difference = exports.intersection = exports.union = exports.elem = exports.some = exports.every = exports.fromFoldableMap = exports.fromEntries = exports.toEntries = exports.fromFoldable = exports.filterWithIndex = exports.filterMapWithIndex = exports.partitionWithIndex = exports.partitionMapWithIndex = exports.wilt = exports.wither = exports.sequence = exports.traverse = exports.traverseWithIndex = exports.singleton = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.map = exports.mapWithIndex = exports.lookup = exports.isSubrecord = exports.pop = exports.modifyAt = exports.updateAt = exports.deleteAt = exports.has = exports.upsertAt = exports.toUnfoldable = exports.toArray = exports.collect = exports.keys = exports.isEmpty = exports.size = void 0;
      exports.record = exports.hasOwnProperty = exports.insertAt = exports.empty = exports.Witherable = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getWitherable = exports.getTraversableWithIndex = exports.getTraversable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.getFoldableWithIndex = exports.getFoldable = exports.FunctorWithIndex = exports.flap = exports.Functor = exports.getMonoid = exports.getEq = void 0;
      var A = __importStar2(require_Array());
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar2(require_internal());
      var RR = __importStar2(require_ReadonlyRecord());
      var Se = __importStar2(require_Semigroup());
      var S = __importStar2(require_string());
      var Witherable_1 = require_Witherable();
      exports.size = RR.size;
      exports.isEmpty = RR.isEmpty;
      var keys_ = function(O) {
        return function(r) {
          return Object.keys(r).sort(O.compare);
        };
      };
      exports.keys = keys_(S.Ord);
      function collect(O) {
        if (typeof O === "function") {
          return collect(S.Ord)(O);
        }
        var keysO = keys_(O);
        return function(f) {
          return function(r) {
            var out = [];
            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
              var key = _a[_i];
              out.push(f(key, r[key]));
            }
            return out;
          };
        };
      }
      exports.collect = collect;
      exports.toArray = collect(S.Ord)(function(k, a) {
        return [
          k,
          a
        ];
      });
      function toUnfoldable(U) {
        return function(r) {
          var sas = (0, exports.toArray)(r);
          var len = sas.length;
          return U.unfold(0, function(b) {
            return b < len ? _.some([sas[b], b + 1]) : _.none;
          });
        };
      }
      exports.toUnfoldable = toUnfoldable;
      exports.upsertAt = RR.upsertAt;
      exports.has = RR.has;
      function deleteAt(k) {
        return function(r) {
          if (!_.has.call(r, k)) {
            return r;
          }
          var out = Object.assign({}, r);
          delete out[k];
          return out;
        };
      }
      exports.deleteAt = deleteAt;
      var updateAt = function(k, a) {
        return (0, exports.modifyAt)(k, function() {
          return a;
        });
      };
      exports.updateAt = updateAt;
      var modifyAt = function(k, f) {
        return function(r) {
          if (!(0, exports.has)(k, r)) {
            return _.none;
          }
          var out = Object.assign({}, r);
          out[k] = f(r[k]);
          return _.some(out);
        };
      };
      exports.modifyAt = modifyAt;
      function pop(k) {
        var deleteAtk = deleteAt(k);
        return function(r) {
          var oa = (0, exports.lookup)(k, r);
          return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);
        };
      }
      exports.pop = pop;
      exports.isSubrecord = RR.isSubrecord;
      exports.lookup = RR.lookup;
      exports.mapWithIndex = RR.mapWithIndex;
      exports.map = RR.map;
      function reduceWithIndex() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return args.length === 1 ? RR.reduceWithIndex(args[0]) : RR.reduceWithIndex(S.Ord).apply(void 0, args);
      }
      exports.reduceWithIndex = reduceWithIndex;
      function foldMapWithIndex(O) {
        return "compare" in O ? RR.foldMapWithIndex(O) : RR.foldMapWithIndex(S.Ord)(O);
      }
      exports.foldMapWithIndex = foldMapWithIndex;
      function reduceRightWithIndex() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return args.length === 1 ? RR.reduceRightWithIndex(args[0]) : RR.reduceRightWithIndex(S.Ord).apply(void 0, args);
      }
      exports.reduceRightWithIndex = reduceRightWithIndex;
      exports.singleton = RR.singleton;
      function traverseWithIndex(F) {
        return RR.traverseWithIndex(F);
      }
      exports.traverseWithIndex = traverseWithIndex;
      function traverse(F) {
        return RR.traverse(F);
      }
      exports.traverse = traverse;
      function sequence(F) {
        return RR.sequence(F);
      }
      exports.sequence = sequence;
      var wither = function(F) {
        var traverseF = traverse(F);
        return function(f) {
          return function(fa) {
            return F.map((0, function_1.pipe)(fa, traverseF(f)), exports.compact);
          };
        };
      };
      exports.wither = wither;
      var wilt = function(F) {
        var traverseF = traverse(F);
        return function(f) {
          return function(fa) {
            return F.map((0, function_1.pipe)(fa, traverseF(f)), exports.separate);
          };
        };
      };
      exports.wilt = wilt;
      exports.partitionMapWithIndex = RR.partitionMapWithIndex;
      function partitionWithIndex(predicateWithIndex) {
        return RR.partitionWithIndex(predicateWithIndex);
      }
      exports.partitionWithIndex = partitionWithIndex;
      exports.filterMapWithIndex = RR.filterMapWithIndex;
      function filterWithIndex(predicateWithIndex) {
        return RR.filterWithIndex(predicateWithIndex);
      }
      exports.filterWithIndex = filterWithIndex;
      function fromFoldable(M, F) {
        return RR.fromFoldable(M, F);
      }
      exports.fromFoldable = fromFoldable;
      exports.toEntries = exports.toArray;
      var fromEntries = function(fa) {
        return fromFoldable(Se.last(), A.Foldable)(fa);
      };
      exports.fromEntries = fromEntries;
      function fromFoldableMap(M, F) {
        return RR.fromFoldableMap(M, F);
      }
      exports.fromFoldableMap = fromFoldableMap;
      exports.every = RR.every;
      exports.some = RR.some;
      exports.elem = RR.elem;
      var union = function(M) {
        var unionM = RR.union(M);
        return function(second) {
          return function(first) {
            if ((0, exports.isEmpty)(first)) {
              return __assign2({}, second);
            }
            if ((0, exports.isEmpty)(second)) {
              return __assign2({}, first);
            }
            return unionM(second)(first);
          };
        };
      };
      exports.union = union;
      var intersection = function(M) {
        return function(second) {
          return function(first) {
            if ((0, exports.isEmpty)(first) || (0, exports.isEmpty)(second)) {
              return {};
            }
            return RR.intersection(M)(second)(first);
          };
        };
      };
      exports.intersection = intersection;
      var difference = function(second) {
        return function(first) {
          if ((0, exports.isEmpty)(first)) {
            return __assign2({}, second);
          }
          if ((0, exports.isEmpty)(second)) {
            return __assign2({}, first);
          }
          return RR.difference(second)(first);
        };
      };
      exports.difference = difference;
      var _map = RR._map;
      var _mapWithIndex = RR._mapWithIndex;
      var _reduce = RR._reduce;
      var _foldMap = RR._foldMap;
      var _reduceRight = RR._reduceRight;
      var _filter = RR._filter;
      var _filterMap = RR._filterMap;
      var _partition = RR._partition;
      var _partitionMap = RR._partitionMap;
      var _reduceWithIndex = RR._reduceWithIndex;
      var _foldMapWithIndex = RR._foldMapWithIndex;
      var _reduceRightWithIndex = RR._reduceRightWithIndex;
      var _partitionMapWithIndex = RR._partitionMapWithIndex;
      var _partitionWithIndex = RR._partitionWithIndex;
      var _filterMapWithIndex = RR._filterMapWithIndex;
      var _filterWithIndex = RR._filterWithIndex;
      var _traverse = RR._traverse;
      var _sequence = RR._sequence;
      var _traverseWithIndex = function(O) {
        return function(F) {
          var keysO = keys_(O);
          return function(ta, f) {
            var ks = keysO(ta);
            if (ks.length === 0) {
              return F.of({});
            }
            var fr = F.of({});
            var _loop_1 = function(key2) {
              fr = F.ap(F.map(fr, function(r) {
                return function(b) {
                  r[key2] = b;
                  return r;
                };
              }), f(key2, ta[key2]));
            };
            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
              var key = ks_1[_i];
              _loop_1(key);
            }
            return fr;
          };
        };
      };
      exports.filter = RR.filter;
      exports.filterMap = RR.filterMap;
      exports.partition = RR.partition;
      exports.partitionMap = RR.partitionMap;
      function reduce() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return args.length === 1 ? RR.reduce(args[0]) : RR.reduce(S.Ord).apply(void 0, args);
      }
      exports.reduce = reduce;
      function foldMap(O) {
        return "compare" in O ? RR.foldMap(O) : RR.foldMap(S.Ord)(O);
      }
      exports.foldMap = foldMap;
      function reduceRight() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return args.length === 1 ? RR.reduceRight(args[0]) : RR.reduceRight(S.Ord).apply(void 0, args);
      }
      exports.reduceRight = reduceRight;
      exports.compact = RR.compact;
      exports.separate = RR.separate;
      exports.URI = "Record";
      function getShow(O) {
        return "compare" in O ? RR.getShow(O) : RR.getShow(S.Ord)(O);
      }
      exports.getShow = getShow;
      exports.getEq = RR.getEq;
      exports.getMonoid = RR.getMonoid;
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.FunctorWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex
      };
      var getFoldable = function(O) {
        return {
          URI: exports.URI,
          reduce: _reduce(O),
          foldMap: _foldMap(O),
          reduceRight: _reduceRight(O)
        };
      };
      exports.getFoldable = getFoldable;
      var getFoldableWithIndex = function(O) {
        return {
          URI: exports.URI,
          reduce: _reduce(O),
          foldMap: _foldMap(O),
          reduceRight: _reduceRight(O),
          reduceWithIndex: _reduceWithIndex(O),
          foldMapWithIndex: _foldMapWithIndex(O),
          reduceRightWithIndex: _reduceRightWithIndex(O)
        };
      };
      exports.getFoldableWithIndex = getFoldableWithIndex;
      exports.Compactable = {
        URI: exports.URI,
        compact: exports.compact,
        separate: exports.separate
      };
      exports.Filterable = {
        URI: exports.URI,
        map: _map,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap
      };
      exports.FilterableWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex
      };
      var getTraversable = function(O) {
        return {
          URI: exports.URI,
          map: _map,
          reduce: _reduce(O),
          foldMap: _foldMap(O),
          reduceRight: _reduceRight(O),
          traverse: _traverse(O),
          sequence: _sequence(O)
        };
      };
      exports.getTraversable = getTraversable;
      var getTraversableWithIndex = function(O) {
        return {
          URI: exports.URI,
          map: _map,
          mapWithIndex: _mapWithIndex,
          reduce: _reduce(O),
          foldMap: _foldMap(O),
          reduceRight: _reduceRight(O),
          reduceWithIndex: _reduceWithIndex(O),
          foldMapWithIndex: _foldMapWithIndex(O),
          reduceRightWithIndex: _reduceRightWithIndex(O),
          traverse: _traverse(O),
          sequence: _sequence(O),
          traverseWithIndex: _traverseWithIndex(O)
        };
      };
      exports.getTraversableWithIndex = getTraversableWithIndex;
      var getWitherable = function(O) {
        var T = (0, exports.getTraversable)(O);
        return {
          URI: exports.URI,
          map: _map,
          reduce: _reduce(O),
          foldMap: _foldMap(O),
          reduceRight: _reduceRight(O),
          traverse: T.traverse,
          sequence: T.sequence,
          compact: exports.compact,
          separate: exports.separate,
          filter: _filter,
          filterMap: _filterMap,
          partition: _partition,
          partitionMap: _partitionMap,
          wither: (0, Witherable_1.witherDefault)(T, exports.Compactable),
          wilt: (0, Witherable_1.wiltDefault)(T, exports.Compactable)
        };
      };
      exports.getWitherable = getWitherable;
      var getUnionSemigroup = function(S2) {
        var unionS = (0, exports.union)(S2);
        return {
          concat: function(first, second) {
            return unionS(second)(first);
          }
        };
      };
      exports.getUnionSemigroup = getUnionSemigroup;
      var getUnionMonoid = function(S2) {
        return {
          concat: (0, exports.getUnionSemigroup)(S2).concat,
          empty: {}
        };
      };
      exports.getUnionMonoid = getUnionMonoid;
      var getIntersectionSemigroup = function(S2) {
        var intersectionS = (0, exports.intersection)(S2);
        return {
          concat: function(first, second) {
            return intersectionS(second)(first);
          }
        };
      };
      exports.getIntersectionSemigroup = getIntersectionSemigroup;
      var getDifferenceMagma = function() {
        return {
          concat: function(first, second) {
            return (0, exports.difference)(second)(first);
          }
        };
      };
      exports.getDifferenceMagma = getDifferenceMagma;
      exports.Foldable = {
        URI: exports.URI,
        reduce: /* @__PURE__ */ _reduce(S.Ord),
        foldMap: /* @__PURE__ */ _foldMap(S.Ord),
        reduceRight: /* @__PURE__ */ _reduceRight(S.Ord)
      };
      exports.FoldableWithIndex = {
        URI: exports.URI,
        reduce: /* @__PURE__ */ _reduce(S.Ord),
        foldMap: /* @__PURE__ */ _foldMap(S.Ord),
        reduceRight: /* @__PURE__ */ _reduceRight(S.Ord),
        reduceWithIndex: /* @__PURE__ */ _reduceWithIndex(S.Ord),
        foldMapWithIndex: /* @__PURE__ */ _foldMapWithIndex(S.Ord),
        reduceRightWithIndex: /* @__PURE__ */ _reduceRightWithIndex(S.Ord)
      };
      exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: /* @__PURE__ */ _reduce(S.Ord),
        foldMap: /* @__PURE__ */ _foldMap(S.Ord),
        reduceRight: /* @__PURE__ */ _reduceRight(S.Ord),
        traverse: /* @__PURE__ */ _traverse(S.Ord),
        sequence
      };
      exports.TraversableWithIndex = {
        URI: exports.URI,
        map: _map,
        mapWithIndex: _mapWithIndex,
        reduce: /* @__PURE__ */ _reduce(S.Ord),
        foldMap: /* @__PURE__ */ _foldMap(S.Ord),
        reduceRight: /* @__PURE__ */ _reduceRight(S.Ord),
        reduceWithIndex: /* @__PURE__ */ _reduceWithIndex(S.Ord),
        foldMapWithIndex: /* @__PURE__ */ _foldMapWithIndex(S.Ord),
        reduceRightWithIndex: /* @__PURE__ */ _reduceRightWithIndex(S.Ord),
        traverse: /* @__PURE__ */ _traverse(S.Ord),
        sequence,
        traverseWithIndex: /* @__PURE__ */ _traverseWithIndex(S.Ord)
      };
      var _wither = /* @__PURE__ */ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);
      var _wilt = /* @__PURE__ */ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);
      exports.Witherable = {
        URI: exports.URI,
        map: _map,
        reduce: /* @__PURE__ */ _reduce(S.Ord),
        foldMap: /* @__PURE__ */ _foldMap(S.Ord),
        reduceRight: /* @__PURE__ */ _reduceRight(S.Ord),
        traverse: /* @__PURE__ */ _traverse(S.Ord),
        sequence,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        wither: _wither,
        wilt: _wilt
      };
      exports.empty = {};
      exports.insertAt = exports.upsertAt;
      exports.hasOwnProperty = RR.hasOwnProperty;
      exports.record = {
        URI: exports.URI,
        map: _map,
        reduce: /* @__PURE__ */ _reduce(S.Ord),
        foldMap: /* @__PURE__ */ _foldMap(S.Ord),
        reduceRight: /* @__PURE__ */ _reduceRight(S.Ord),
        traverse: /* @__PURE__ */ _traverse(S.Ord),
        sequence,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        mapWithIndex: _mapWithIndex,
        reduceWithIndex: /* @__PURE__ */ _reduceWithIndex(S.Ord),
        foldMapWithIndex: /* @__PURE__ */ _foldMapWithIndex(S.Ord),
        reduceRightWithIndex: /* @__PURE__ */ _reduceRightWithIndex(S.Ord),
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex,
        traverseWithIndex: /* @__PURE__ */ _traverseWithIndex(S.Ord),
        wither: _wither,
        wilt: _wilt
      };
    }
  });

  // node_modules/fp-ts/lib/pipeable.js
  var require_pipeable = __commonJS({
    "node_modules/fp-ts/lib/pipeable.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pipe = exports.pipeable = exports.compose = exports.promap = exports.partitionMapWithIndex = exports.partitionWithIndex = exports.filterMapWithIndex = exports.filterWithIndex = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.alt = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.reduceRight = exports.foldMap = exports.reduce = exports.extend = exports.mapLeft = exports.bimap = exports.chain = exports.ap = exports.mapWithIndex = exports.contramap = exports.map = void 0;
      var Apply_1 = require_Apply();
      var Chain_1 = require_Chain();
      var function_1 = require_function();
      function map(F) {
        return function(f) {
          return function(fa) {
            return F.map(fa, f);
          };
        };
      }
      exports.map = map;
      function contramap(F) {
        return function(f) {
          return function(fa) {
            return F.contramap(fa, f);
          };
        };
      }
      exports.contramap = contramap;
      function mapWithIndex(F) {
        return function(f) {
          return function(fa) {
            return F.mapWithIndex(fa, f);
          };
        };
      }
      exports.mapWithIndex = mapWithIndex;
      function ap(F) {
        return function(fa) {
          return function(fab) {
            return F.ap(fab, fa);
          };
        };
      }
      exports.ap = ap;
      function chain(F) {
        return function(f) {
          return function(fa) {
            return F.chain(fa, f);
          };
        };
      }
      exports.chain = chain;
      function bimap(F) {
        return function(f, g) {
          return function(fea) {
            return F.bimap(fea, f, g);
          };
        };
      }
      exports.bimap = bimap;
      function mapLeft(F) {
        return function(f) {
          return function(fea) {
            return F.mapLeft(fea, f);
          };
        };
      }
      exports.mapLeft = mapLeft;
      function extend(F) {
        return function(f) {
          return function(wa) {
            return F.extend(wa, f);
          };
        };
      }
      exports.extend = extend;
      function reduce(F) {
        return function(b, f) {
          return function(fa) {
            return F.reduce(fa, b, f);
          };
        };
      }
      exports.reduce = reduce;
      function foldMap(F) {
        return function(M) {
          var foldMapM = F.foldMap(M);
          return function(f) {
            return function(fa) {
              return foldMapM(fa, f);
            };
          };
        };
      }
      exports.foldMap = foldMap;
      function reduceRight(F) {
        return function(b, f) {
          return function(fa) {
            return F.reduceRight(fa, b, f);
          };
        };
      }
      exports.reduceRight = reduceRight;
      function reduceWithIndex(F) {
        return function(b, f) {
          return function(fa) {
            return F.reduceWithIndex(fa, b, f);
          };
        };
      }
      exports.reduceWithIndex = reduceWithIndex;
      function foldMapWithIndex(F) {
        return function(M) {
          var foldMapWithIndexM = F.foldMapWithIndex(M);
          return function(f) {
            return function(fa) {
              return foldMapWithIndexM(fa, f);
            };
          };
        };
      }
      exports.foldMapWithIndex = foldMapWithIndex;
      function reduceRightWithIndex(F) {
        return function(b, f) {
          return function(fa) {
            return F.reduceRightWithIndex(fa, b, f);
          };
        };
      }
      exports.reduceRightWithIndex = reduceRightWithIndex;
      function alt(F) {
        return function(that) {
          return function(fa) {
            return F.alt(fa, that);
          };
        };
      }
      exports.alt = alt;
      function filter(F) {
        return function(predicate) {
          return function(fa) {
            return F.filter(fa, predicate);
          };
        };
      }
      exports.filter = filter;
      function filterMap(F) {
        return function(f) {
          return function(fa) {
            return F.filterMap(fa, f);
          };
        };
      }
      exports.filterMap = filterMap;
      function partition(F) {
        return function(f) {
          return function(fa) {
            return F.partition(fa, f);
          };
        };
      }
      exports.partition = partition;
      function partitionMap(F) {
        return function(f) {
          return function(fa) {
            return F.partitionMap(fa, f);
          };
        };
      }
      exports.partitionMap = partitionMap;
      function filterWithIndex(F) {
        return function(predicate) {
          return function(fa) {
            return F.filterWithIndex(fa, predicate);
          };
        };
      }
      exports.filterWithIndex = filterWithIndex;
      function filterMapWithIndex(F) {
        return function(f) {
          return function(fa) {
            return F.filterMapWithIndex(fa, f);
          };
        };
      }
      exports.filterMapWithIndex = filterMapWithIndex;
      function partitionWithIndex(F) {
        return function(f) {
          return function(fa) {
            return F.partitionWithIndex(fa, f);
          };
        };
      }
      exports.partitionWithIndex = partitionWithIndex;
      function partitionMapWithIndex(F) {
        return function(f) {
          return function(fa) {
            return F.partitionMapWithIndex(fa, f);
          };
        };
      }
      exports.partitionMapWithIndex = partitionMapWithIndex;
      function promap(F) {
        return function(f, g) {
          return function(fbc) {
            return F.promap(fbc, f, g);
          };
        };
      }
      exports.promap = promap;
      function compose(F) {
        return function(ea) {
          return function(ab) {
            return F.compose(ab, ea);
          };
        };
      }
      exports.compose = compose;
      var isFunctor = function(I) {
        return typeof I.map === "function";
      };
      var isContravariant = function(I) {
        return typeof I.contramap === "function";
      };
      var isFunctorWithIndex = function(I) {
        return typeof I.mapWithIndex === "function";
      };
      var isApply = function(I) {
        return typeof I.ap === "function";
      };
      var isChain = function(I) {
        return typeof I.chain === "function";
      };
      var isBifunctor = function(I) {
        return typeof I.bimap === "function";
      };
      var isExtend = function(I) {
        return typeof I.extend === "function";
      };
      var isFoldable = function(I) {
        return typeof I.reduce === "function";
      };
      var isFoldableWithIndex = function(I) {
        return typeof I.reduceWithIndex === "function";
      };
      var isAlt = function(I) {
        return typeof I.alt === "function";
      };
      var isCompactable = function(I) {
        return typeof I.compact === "function";
      };
      var isFilterable = function(I) {
        return typeof I.filter === "function";
      };
      var isFilterableWithIndex = function(I) {
        return typeof I.filterWithIndex === "function";
      };
      var isProfunctor = function(I) {
        return typeof I.promap === "function";
      };
      var isSemigroupoid = function(I) {
        return typeof I.compose === "function";
      };
      var isMonadThrow = function(I) {
        return typeof I.throwError === "function";
      };
      function pipeable(I) {
        var r = {};
        if (isFunctor(I)) {
          r.map = map(I);
        }
        if (isContravariant(I)) {
          r.contramap = contramap(I);
        }
        if (isFunctorWithIndex(I)) {
          r.mapWithIndex = mapWithIndex(I);
        }
        if (isApply(I)) {
          r.ap = ap(I);
          r.apFirst = (0, Apply_1.apFirst)(I);
          r.apSecond = (0, Apply_1.apSecond)(I);
        }
        if (isChain(I)) {
          r.chain = chain(I);
          r.chainFirst = (0, Chain_1.chainFirst)(I);
          r.flatten = r.chain(function_1.identity);
        }
        if (isBifunctor(I)) {
          r.bimap = bimap(I);
          r.mapLeft = mapLeft(I);
        }
        if (isExtend(I)) {
          r.extend = extend(I);
          r.duplicate = r.extend(function_1.identity);
        }
        if (isFoldable(I)) {
          r.reduce = reduce(I);
          r.foldMap = foldMap(I);
          r.reduceRight = reduceRight(I);
        }
        if (isFoldableWithIndex(I)) {
          r.reduceWithIndex = reduceWithIndex(I);
          r.foldMapWithIndex = foldMapWithIndex(I);
          r.reduceRightWithIndex = reduceRightWithIndex(I);
        }
        if (isAlt(I)) {
          r.alt = alt(I);
        }
        if (isCompactable(I)) {
          r.compact = I.compact;
          r.separate = I.separate;
        }
        if (isFilterable(I)) {
          r.filter = filter(I);
          r.filterMap = filterMap(I);
          r.partition = partition(I);
          r.partitionMap = partitionMap(I);
        }
        if (isFilterableWithIndex(I)) {
          r.filterWithIndex = filterWithIndex(I);
          r.filterMapWithIndex = filterMapWithIndex(I);
          r.partitionWithIndex = partitionWithIndex(I);
          r.partitionMapWithIndex = partitionMapWithIndex(I);
        }
        if (isProfunctor(I)) {
          r.promap = promap(I);
        }
        if (isSemigroupoid(I)) {
          r.compose = compose(I);
        }
        if (isMonadThrow(I)) {
          var fromOption = function(onNone) {
            return function(ma) {
              return ma._tag === "None" ? I.throwError(onNone()) : I.of(ma.value);
            };
          };
          var fromEither = function(ma) {
            return ma._tag === "Left" ? I.throwError(ma.left) : I.of(ma.right);
          };
          var fromPredicate = function(predicate, onFalse) {
            return function(a) {
              return predicate(a) ? I.of(a) : I.throwError(onFalse(a));
            };
          };
          var filterOrElse = function(predicate, onFalse) {
            return function(ma) {
              return I.chain(ma, function(a) {
                return predicate(a) ? I.of(a) : I.throwError(onFalse(a));
              });
            };
          };
          r.fromOption = fromOption;
          r.fromEither = fromEither;
          r.fromPredicate = fromPredicate;
          r.filterOrElse = filterOrElse;
        }
        return r;
      }
      exports.pipeable = pipeable;
      exports.pipe = function_1.pipe;
    }
  });

  // node_modules/io-ts-reporters/target/src/utils.js
  var require_utils = __commonJS({
    "node_modules/io-ts-reporters/target/src/utils.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.takeUntil = void 0;
      var takeUntil = function(predicate) {
        return function(as) {
          var init2 = [];
          for (var i = 0; i < as.length; i++) {
            init2[i] = as[i];
            if (predicate(as[i])) {
              return init2;
            }
          }
          return init2;
        };
      };
      exports.takeUntil = takeUntil;
    }
  });

  // node_modules/io-ts-reporters/target/src/index.js
  var require_src = __commonJS({
    "node_modules/io-ts-reporters/target/src/index.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.reporter = exports.formatValidationErrors = exports.formatValidationError = exports.TYPE_MAX_LEN = void 0;
      var A = require_Array();
      var E = require_Either();
      var NEA = require_NonEmptyArray();
      var O = require_Option();
      var R = require_Record();
      var pipeable_1 = require_pipeable();
      var t = require_lib();
      var utils_1 = require_utils();
      var isUnionType = function(_a) {
        var type = _a.type;
        return type instanceof t.UnionType;
      };
      var jsToString = function(value) {
        return value === void 0 ? "undefined" : JSON.stringify(value);
      };
      var keyPath = function(ctx) {
        return ctx.map(function(c) {
          return c.key;
        }).filter(Boolean).join(".");
      };
      var getErrorFromCtx = function(validation) {
        return A.last(validation.context);
      };
      var getValidationContext = function(validation) {
        return validation.context;
      };
      exports.TYPE_MAX_LEN = 160;
      var truncateType = function(type, options) {
        if (options === void 0) {
          options = {};
        }
        var _a = options.truncateLongTypes, truncateLongTypes = _a === void 0 ? true : _a;
        if (truncateLongTypes && type.length > exports.TYPE_MAX_LEN) {
          return type.slice(0, exports.TYPE_MAX_LEN - 3) + "...";
        }
        return type;
      };
      var errorMessageSimple = function(expectedType, path, error, options) {
        return [
          "Expecting " + truncateType(expectedType, options),
          path === "" ? "" : "at " + path,
          "but instead got: " + jsToString(error.value),
          error.message ? "(" + error.message + ")" : ""
        ].filter(Boolean).join(" ");
      };
      var errorMessageUnion = function(expectedTypes, path, value, options) {
        return [
          "Expecting one of:\n",
          expectedTypes.map(function(type) {
            return "    " + truncateType(type, options);
          }).join("\n"),
          path === "" ? "\n" : "\nat " + path + " ",
          "but instead got: " + jsToString(value)
        ].filter(Boolean).join("");
      };
      var findExpectedType = function(ctx) {
        return pipeable_1.pipe(ctx, A.findIndex(isUnionType), O.chain(function(n) {
          return A.lookup(n + 1, ctx);
        }));
      };
      var formatValidationErrorOfUnion = function(path, errors, options) {
        var expectedTypes = pipeable_1.pipe(errors, A.map(getValidationContext), A.map(findExpectedType), A.compact);
        var value = pipeable_1.pipe(expectedTypes, A.head, O.map(function(v) {
          return v.actual;
        }), O.getOrElse(function() {
          return void 0;
        }));
        var expected = expectedTypes.map(function(_a) {
          var type = _a.type;
          return type.name;
        });
        return expected.length > 0 ? O.some(errorMessageUnion(expected, path, value, options)) : O.none;
      };
      var formatValidationCommonError = function(path, error, options) {
        return pipeable_1.pipe(error, getErrorFromCtx, O.map(function(errorContext) {
          return errorMessageSimple(errorContext.type.name, path, error, options);
        }));
      };
      var groupByKey = NEA.groupBy(function(error) {
        return pipeable_1.pipe(error.context, utils_1.takeUntil(isUnionType), keyPath);
      });
      var format = function(path, errors, options) {
        return NEA.tail(errors).length > 0 ? formatValidationErrorOfUnion(path, errors, options) : formatValidationCommonError(path, NEA.head(errors), options);
      };
      var formatValidationError = function(error, options) {
        return formatValidationCommonError(keyPath(error.context), error, options);
      };
      exports.formatValidationError = formatValidationError;
      var formatValidationErrors = function(errors, options) {
        return pipeable_1.pipe(errors, groupByKey, R.mapWithIndex(function(path, errors2) {
          return format(path, errors2, options);
        }), R.compact, R.toArray, A.map(function(_a) {
          var _key = _a[0], error = _a[1];
          return error;
        }));
      };
      exports.formatValidationErrors = formatValidationErrors;
      var reporter = function(validation, options) {
        return pipeable_1.pipe(validation, E.mapLeft(function(errors) {
          return exports.formatValidationErrors(errors, options);
        }), E.fold(function(errors) {
          return errors;
        }, function() {
          return [];
        }));
      };
      exports.reporter = reporter;
      var prettyReporter = { report: exports.reporter };
      exports.default = prettyReporter;
    }
  });

  // node_modules/ton/dist/client/api/TonCache.js
  var require_TonCache = __commonJS({
    "node_modules/ton/dist/client/api/TonCache.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InMemoryCache = void 0;
      var InMemoryCache = class {
        constructor() {
          this.cache = /* @__PURE__ */ new Map();
          this.set = async (namespace, key, value) => {
            if (value !== null) {
              this.cache.set(namespace + "$$" + key, value);
            } else {
              this.cache.delete(namespace + "$$" + key);
            }
          };
          this.get = async (namespace, key) => {
            let res = this.cache.get(namespace + "$$" + key);
            if (res !== void 0) {
              return res;
            } else {
              return null;
            }
          };
        }
      };
      exports.InMemoryCache = InMemoryCache;
    }
  });

  // node_modules/dataloader/index.js
  var require_dataloader = __commonJS({
    "node_modules/dataloader/index.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var DataLoader = /* @__PURE__ */ function() {
        function DataLoader2(batchLoadFn, options) {
          if (typeof batchLoadFn !== "function") {
            throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
          }
          this._batchLoadFn = batchLoadFn;
          this._maxBatchSize = getValidMaxBatchSize(options);
          this._batchScheduleFn = getValidBatchScheduleFn(options);
          this._cacheKeyFn = getValidCacheKeyFn(options);
          this._cacheMap = getValidCacheMap(options);
          this._batch = null;
        }
        var _proto = DataLoader2.prototype;
        _proto.load = function load(key) {
          if (key === null || key === void 0) {
            throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key) + "."));
          }
          var batch = getCurrentBatch(this);
          var cacheMap = this._cacheMap;
          var cacheKey = this._cacheKeyFn(key);
          if (cacheMap) {
            var cachedPromise = cacheMap.get(cacheKey);
            if (cachedPromise) {
              var cacheHits = batch.cacheHits || (batch.cacheHits = []);
              return new Promise(function(resolve) {
                cacheHits.push(function() {
                  resolve(cachedPromise);
                });
              });
            }
          }
          batch.keys.push(key);
          var promise = new Promise(function(resolve, reject) {
            batch.callbacks.push({
              resolve,
              reject
            });
          });
          if (cacheMap) {
            cacheMap.set(cacheKey, promise);
          }
          return promise;
        };
        _proto.loadMany = function loadMany(keys) {
          if (!isArrayLike(keys)) {
            throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys + "."));
          }
          var loadPromises = [];
          for (var i = 0; i < keys.length; i++) {
            loadPromises.push(this.load(keys[i])["catch"](function(error) {
              return error;
            }));
          }
          return Promise.all(loadPromises);
        };
        _proto.clear = function clear(key) {
          var cacheMap = this._cacheMap;
          if (cacheMap) {
            var cacheKey = this._cacheKeyFn(key);
            cacheMap["delete"](cacheKey);
          }
          return this;
        };
        _proto.clearAll = function clearAll() {
          var cacheMap = this._cacheMap;
          if (cacheMap) {
            cacheMap.clear();
          }
          return this;
        };
        _proto.prime = function prime(key, value) {
          var cacheMap = this._cacheMap;
          if (cacheMap) {
            var cacheKey = this._cacheKeyFn(key);
            if (cacheMap.get(cacheKey) === void 0) {
              var promise;
              if (value instanceof Error) {
                promise = Promise.reject(value);
                promise["catch"](function() {
                });
              } else {
                promise = Promise.resolve(value);
              }
              cacheMap.set(cacheKey, promise);
            }
          }
          return this;
        };
        return DataLoader2;
      }();
      var enqueuePostPromiseJob = typeof browser_exports === "object" && typeof browser_exports.nextTick === "function" ? function(fn) {
        if (!resolvedPromise) {
          resolvedPromise = Promise.resolve();
        }
        resolvedPromise.then(function() {
          browser_exports.nextTick(fn);
        });
      } : typeof setImmediate === "function" ? function(fn) {
        setImmediate(fn);
      } : function(fn) {
        setTimeout(fn);
      };
      var resolvedPromise;
      function getCurrentBatch(loader) {
        var existingBatch = loader._batch;
        if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize && (!existingBatch.cacheHits || existingBatch.cacheHits.length < loader._maxBatchSize)) {
          return existingBatch;
        }
        var newBatch = {
          hasDispatched: false,
          keys: [],
          callbacks: []
        };
        loader._batch = newBatch;
        loader._batchScheduleFn(function() {
          dispatchBatch(loader, newBatch);
        });
        return newBatch;
      }
      function dispatchBatch(loader, batch) {
        batch.hasDispatched = true;
        if (batch.keys.length === 0) {
          resolveCacheHits(batch);
          return;
        }
        var batchPromise = loader._batchLoadFn(batch.keys);
        if (!batchPromise || typeof batchPromise.then !== "function") {
          return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
        }
        batchPromise.then(function(values) {
          if (!isArrayLike(values)) {
            throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
          }
          if (values.length !== batch.keys.length) {
            throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
          }
          resolveCacheHits(batch);
          for (var i = 0; i < batch.callbacks.length; i++) {
            var value = values[i];
            if (value instanceof Error) {
              batch.callbacks[i].reject(value);
            } else {
              batch.callbacks[i].resolve(value);
            }
          }
        })["catch"](function(error) {
          failedDispatch(loader, batch, error);
        });
      }
      function failedDispatch(loader, batch, error) {
        resolveCacheHits(batch);
        for (var i = 0; i < batch.keys.length; i++) {
          loader.clear(batch.keys[i]);
          batch.callbacks[i].reject(error);
        }
      }
      function resolveCacheHits(batch) {
        if (batch.cacheHits) {
          for (var i = 0; i < batch.cacheHits.length; i++) {
            batch.cacheHits[i]();
          }
        }
      }
      function getValidMaxBatchSize(options) {
        var shouldBatch = !options || options.batch !== false;
        if (!shouldBatch) {
          return 1;
        }
        var maxBatchSize = options && options.maxBatchSize;
        if (maxBatchSize === void 0) {
          return Infinity;
        }
        if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
          throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
        }
        return maxBatchSize;
      }
      function getValidBatchScheduleFn(options) {
        var batchScheduleFn = options && options.batchScheduleFn;
        if (batchScheduleFn === void 0) {
          return enqueuePostPromiseJob;
        }
        if (typeof batchScheduleFn !== "function") {
          throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
        }
        return batchScheduleFn;
      }
      function getValidCacheKeyFn(options) {
        var cacheKeyFn = options && options.cacheKeyFn;
        if (cacheKeyFn === void 0) {
          return function(key) {
            return key;
          };
        }
        if (typeof cacheKeyFn !== "function") {
          throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
        }
        return cacheKeyFn;
      }
      function getValidCacheMap(options) {
        var shouldCache = !options || options.cache !== false;
        if (!shouldCache) {
          return null;
        }
        var cacheMap = options && options.cacheMap;
        if (cacheMap === void 0) {
          return /* @__PURE__ */ new Map();
        }
        if (cacheMap !== null) {
          var cacheFunctions = ["get", "set", "delete", "clear"];
          var missingFunctions = cacheFunctions.filter(function(fnName) {
            return cacheMap && typeof cacheMap[fnName] !== "function";
          });
          if (missingFunctions.length !== 0) {
            throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
          }
        }
        return cacheMap;
      }
      function isArrayLike(x) {
        return typeof x === "object" && x !== null && typeof x.length === "number" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
      }
      module.exports = DataLoader;
    }
  });

  // node_modules/axios/lib/helpers/bind.js
  var require_bind = __commonJS({
    "node_modules/axios/lib/helpers/bind.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      module.exports = function bind(fn, thisArg) {
        return function wrap() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          return fn.apply(thisArg, args);
        };
      };
    }
  });

  // node_modules/axios/lib/utils.js
  var require_utils2 = __commonJS({
    "node_modules/axios/lib/utils.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var bind = require_bind();
      var toString3 = Object.prototype.toString;
      function isArray(val) {
        return Array.isArray(val);
      }
      function isUndefined(val) {
        return typeof val === "undefined";
      }
      function isBuffer2(val) {
        return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
      }
      function isArrayBuffer(val) {
        return toString3.call(val) === "[object ArrayBuffer]";
      }
      function isFormData(val) {
        return toString3.call(val) === "[object FormData]";
      }
      function isArrayBufferView(val) {
        var result;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && isArrayBuffer(val.buffer);
        }
        return result;
      }
      function isString(val) {
        return typeof val === "string";
      }
      function isNumber(val) {
        return typeof val === "number";
      }
      function isObject(val) {
        return val !== null && typeof val === "object";
      }
      function isPlainObject(val) {
        if (toString3.call(val) !== "[object Object]") {
          return false;
        }
        var prototype = Object.getPrototypeOf(val);
        return prototype === null || prototype === Object.prototype;
      }
      function isDate(val) {
        return toString3.call(val) === "[object Date]";
      }
      function isFile(val) {
        return toString3.call(val) === "[object File]";
      }
      function isBlob(val) {
        return toString3.call(val) === "[object Blob]";
      }
      function isFunction(val) {
        return toString3.call(val) === "[object Function]";
      }
      function isStream(val) {
        return isObject(val) && isFunction(val.pipe);
      }
      function isURLSearchParams(val) {
        return toString3.call(val) === "[object URLSearchParams]";
      }
      function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function isStandardBrowserEnv() {
        if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
          return false;
        }
        return typeof window !== "undefined" && typeof document !== "undefined";
      }
      function forEach(obj, fn) {
        if (obj === null || typeof obj === "undefined") {
          return;
        }
        if (typeof obj !== "object") {
          obj = [obj];
        }
        if (isArray(obj)) {
          for (var i = 0, l = obj.length; i < l; i++) {
            fn.call(null, obj[i], i, obj);
          }
        } else {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              fn.call(null, obj[key], key, obj);
            }
          }
        }
      }
      function merge() {
        var result = {};
        function assignValue(val, key) {
          if (isPlainObject(result[key]) && isPlainObject(val)) {
            result[key] = merge(result[key], val);
          } else if (isPlainObject(val)) {
            result[key] = merge({}, val);
          } else if (isArray(val)) {
            result[key] = val.slice();
          } else {
            result[key] = val;
          }
        }
        for (var i = 0, l = arguments.length; i < l; i++) {
          forEach(arguments[i], assignValue);
        }
        return result;
      }
      function extend(a, b, thisArg) {
        forEach(b, function assignValue(val, key) {
          if (thisArg && typeof val === "function") {
            a[key] = bind(val, thisArg);
          } else {
            a[key] = val;
          }
        });
        return a;
      }
      function stripBOM(content) {
        if (content.charCodeAt(0) === 65279) {
          content = content.slice(1);
        }
        return content;
      }
      module.exports = {
        isArray,
        isArrayBuffer,
        isBuffer: isBuffer2,
        isFormData,
        isArrayBufferView,
        isString,
        isNumber,
        isObject,
        isPlainObject,
        isUndefined,
        isDate,
        isFile,
        isBlob,
        isFunction,
        isStream,
        isURLSearchParams,
        isStandardBrowserEnv,
        forEach,
        merge,
        extend,
        trim,
        stripBOM
      };
    }
  });

  // node_modules/axios/lib/helpers/buildURL.js
  var require_buildURL = __commonJS({
    "node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var utils = require_utils2();
      function encode(val) {
        return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      module.exports = function buildURL(url, params, paramsSerializer) {
        if (!params) {
          return url;
        }
        var serializedParams;
        if (paramsSerializer) {
          serializedParams = paramsSerializer(params);
        } else if (utils.isURLSearchParams(params)) {
          serializedParams = params.toString();
        } else {
          var parts = [];
          utils.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === "undefined") {
              return;
            }
            if (utils.isArray(val)) {
              key = key + "[]";
            } else {
              val = [val];
            }
            utils.forEach(val, function parseValue(v) {
              if (utils.isDate(v)) {
                v = v.toISOString();
              } else if (utils.isObject(v)) {
                v = JSON.stringify(v);
              }
              parts.push(encode(key) + "=" + encode(v));
            });
          });
          serializedParams = parts.join("&");
        }
        if (serializedParams) {
          var hashmarkIndex = url.indexOf("#");
          if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
          }
          url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }
        return url;
      };
    }
  });

  // node_modules/axios/lib/core/InterceptorManager.js
  var require_InterceptorManager = __commonJS({
    "node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var utils = require_utils2();
      function InterceptorManager() {
        this.handlers = [];
      }
      InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      };
      InterceptorManager.prototype.eject = function eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      };
      InterceptorManager.prototype.forEach = function forEach(fn) {
        utils.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      };
      module.exports = InterceptorManager;
    }
  });

  // node_modules/axios/lib/helpers/normalizeHeaderName.js
  var require_normalizeHeaderName = __commonJS({
    "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var utils = require_utils2();
      module.exports = function normalizeHeaderName(headers, normalizedName) {
        utils.forEach(headers, function processHeader(value, name) {
          if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
            headers[normalizedName] = value;
            delete headers[name];
          }
        });
      };
    }
  });

  // node_modules/axios/lib/core/enhanceError.js
  var require_enhanceError = __commonJS({
    "node_modules/axios/lib/core/enhanceError.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      module.exports = function enhanceError(error, config2, code, request, response) {
        error.config = config2;
        if (code) {
          error.code = code;
        }
        error.request = request;
        error.response = response;
        error.isAxiosError = true;
        error.toJSON = function toJSON2() {
          return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: this.config,
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
          };
        };
        return error;
      };
    }
  });

  // node_modules/axios/lib/core/createError.js
  var require_createError = __commonJS({
    "node_modules/axios/lib/core/createError.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var enhanceError = require_enhanceError();
      module.exports = function createError(message, config2, code, request, response) {
        var error = new Error(message);
        return enhanceError(error, config2, code, request, response);
      };
    }
  });

  // node_modules/axios/lib/core/settle.js
  var require_settle = __commonJS({
    "node_modules/axios/lib/core/settle.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var createError = require_createError();
      module.exports = function settle(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;
        if (!response.status || !validateStatus || validateStatus(response.status)) {
          resolve(response);
        } else {
          reject(createError(
            "Request failed with status code " + response.status,
            response.config,
            null,
            response.request,
            response
          ));
        }
      };
    }
  });

  // node_modules/axios/lib/helpers/cookies.js
  var require_cookies = __commonJS({
    "node_modules/axios/lib/helpers/cookies.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var utils = require_utils2();
      module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
        return {
          write: function write3(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read2(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }() : function nonStandardBrowserEnv() {
        return {
          write: function write3() {
          },
          read: function read2() {
            return null;
          },
          remove: function remove() {
          }
        };
      }();
    }
  });

  // node_modules/axios/lib/helpers/isAbsoluteURL.js
  var require_isAbsoluteURL = __commonJS({
    "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      module.exports = function isAbsoluteURL(url) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
      };
    }
  });

  // node_modules/axios/lib/helpers/combineURLs.js
  var require_combineURLs = __commonJS({
    "node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      module.exports = function combineURLs(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      };
    }
  });

  // node_modules/axios/lib/core/buildFullPath.js
  var require_buildFullPath = __commonJS({
    "node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var isAbsoluteURL = require_isAbsoluteURL();
      var combineURLs = require_combineURLs();
      module.exports = function buildFullPath(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL(requestedURL)) {
          return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
      };
    }
  });

  // node_modules/axios/lib/helpers/parseHeaders.js
  var require_parseHeaders = __commonJS({
    "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var utils = require_utils2();
      var ignoreDuplicateOf = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ];
      module.exports = function parseHeaders(headers) {
        var parsed = {};
        var key;
        var val;
        var i;
        if (!headers) {
          return parsed;
        }
        utils.forEach(headers.split("\n"), function parser(line) {
          i = line.indexOf(":");
          key = utils.trim(line.substr(0, i)).toLowerCase();
          val = utils.trim(line.substr(i + 1));
          if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
              return;
            }
            if (key === "set-cookie") {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
          }
        });
        return parsed;
      };
    }
  });

  // node_modules/axios/lib/helpers/isURLSameOrigin.js
  var require_isURLSameOrigin = __commonJS({
    "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var utils = require_utils2();
      module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }() : function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }();
    }
  });

  // node_modules/axios/lib/cancel/Cancel.js
  var require_Cancel = __commonJS({
    "node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      function Cancel(message) {
        this.message = message;
      }
      Cancel.prototype.toString = function toString3() {
        return "Cancel" + (this.message ? ": " + this.message : "");
      };
      Cancel.prototype.__CANCEL__ = true;
      module.exports = Cancel;
    }
  });

  // node_modules/axios/lib/adapters/xhr.js
  var require_xhr = __commonJS({
    "node_modules/axios/lib/adapters/xhr.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var utils = require_utils2();
      var settle = require_settle();
      var cookies = require_cookies();
      var buildURL = require_buildURL();
      var buildFullPath = require_buildFullPath();
      var parseHeaders = require_parseHeaders();
      var isURLSameOrigin = require_isURLSameOrigin();
      var createError = require_createError();
      var defaults = require_defaults();
      var Cancel = require_Cancel();
      module.exports = function xhrAdapter(config2) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          var requestData = config2.data;
          var requestHeaders = config2.headers;
          var responseType = config2.responseType;
          var onCanceled;
          function done() {
            if (config2.cancelToken) {
              config2.cancelToken.unsubscribe(onCanceled);
            }
            if (config2.signal) {
              config2.signal.removeEventListener("abort", onCanceled);
            }
          }
          if (utils.isFormData(requestData)) {
            delete requestHeaders["Content-Type"];
          }
          var request = new XMLHttpRequest();
          if (config2.auth) {
            var username = config2.auth.username || "";
            var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
            requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
          }
          var fullPath = buildFullPath(config2.baseURL, config2.url);
          request.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
          request.timeout = config2.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config: config2,
              request
            };
            settle(function _resolve(value) {
              resolve(value);
              done();
            }, function _reject(err) {
              reject(err);
              done();
            }, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(createError("Request aborted", config2, "ECONNABORTED", request));
            request = null;
          };
          request.onerror = function handleError() {
            reject(createError("Network Error", config2, null, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
            var transitional = config2.transitional || defaults.transitional;
            if (config2.timeoutErrorMessage) {
              timeoutErrorMessage = config2.timeoutErrorMessage;
            }
            reject(createError(
              timeoutErrorMessage,
              config2,
              transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
              request
            ));
            request = null;
          };
          if (utils.isStandardBrowserEnv()) {
            var xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName ? cookies.read(config2.xsrfCookieName) : void 0;
            if (xsrfValue) {
              requestHeaders[config2.xsrfHeaderName] = xsrfValue;
            }
          }
          if ("setRequestHeader" in request) {
            utils.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                delete requestHeaders[key];
              } else {
                request.setRequestHeader(key, val);
              }
            });
          }
          if (!utils.isUndefined(config2.withCredentials)) {
            request.withCredentials = !!config2.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = config2.responseType;
          }
          if (typeof config2.onDownloadProgress === "function") {
            request.addEventListener("progress", config2.onDownloadProgress);
          }
          if (typeof config2.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", config2.onUploadProgress);
          }
          if (config2.cancelToken || config2.signal) {
            onCanceled = function(cancel) {
              if (!request) {
                return;
              }
              reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
              request.abort();
              request = null;
            };
            config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
            if (config2.signal) {
              config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
            }
          }
          if (!requestData) {
            requestData = null;
          }
          request.send(requestData);
        });
      };
    }
  });

  // node_modules/axios/lib/defaults.js
  var require_defaults = __commonJS({
    "node_modules/axios/lib/defaults.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var utils = require_utils2();
      var normalizeHeaderName = require_normalizeHeaderName();
      var enhanceError = require_enhanceError();
      var DEFAULT_CONTENT_TYPE = {
        "Content-Type": "application/x-www-form-urlencoded"
      };
      function setContentTypeIfUnset(headers, value) {
        if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
          headers["Content-Type"] = value;
        }
      }
      function getDefaultAdapter() {
        var adapter;
        if (typeof XMLHttpRequest !== "undefined") {
          adapter = require_xhr();
        } else if (typeof browser_exports !== "undefined" && Object.prototype.toString.call(browser_exports) === "[object process]") {
          adapter = require_xhr();
        }
        return adapter;
      }
      function stringifySafely(rawValue, parser, encoder) {
        if (utils.isString(rawValue)) {
          try {
            (parser || JSON.parse)(rawValue);
            return utils.trim(rawValue);
          } catch (e) {
            if (e.name !== "SyntaxError") {
              throw e;
            }
          }
        }
        return (encoder || JSON.stringify)(rawValue);
      }
      var defaults = {
        transitional: {
          silentJSONParsing: true,
          forcedJSONParsing: true,
          clarifyTimeoutError: false
        },
        adapter: getDefaultAdapter(),
        transformRequest: [function transformRequest(data, headers) {
          normalizeHeaderName(headers, "Accept");
          normalizeHeaderName(headers, "Content-Type");
          if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
            return data;
          }
          if (utils.isArrayBufferView(data)) {
            return data.buffer;
          }
          if (utils.isURLSearchParams(data)) {
            setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
            return data.toString();
          }
          if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
            setContentTypeIfUnset(headers, "application/json");
            return stringifySafely(data);
          }
          return data;
        }],
        transformResponse: [function transformResponse(data) {
          var transitional = this.transitional || defaults.transitional;
          var silentJSONParsing = transitional && transitional.silentJSONParsing;
          var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
          var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
          if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
            try {
              return JSON.parse(data);
            } catch (e) {
              if (strictJSONParsing) {
                if (e.name === "SyntaxError") {
                  throw enhanceError(e, this, "E_JSON_PARSE");
                }
                throw e;
              }
            }
          }
          return data;
        }],
        /**
         * A timeout in milliseconds to abort a request. If set to 0 (default) a
         * timeout is not created.
         */
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        validateStatus: function validateStatus(status) {
          return status >= 200 && status < 300;
        },
        headers: {
          common: {
            "Accept": "application/json, text/plain, */*"
          }
        }
      };
      utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
        defaults.headers[method] = {};
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
      });
      module.exports = defaults;
    }
  });

  // node_modules/axios/lib/core/transformData.js
  var require_transformData = __commonJS({
    "node_modules/axios/lib/core/transformData.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var utils = require_utils2();
      var defaults = require_defaults();
      module.exports = function transformData(data, headers, fns) {
        var context = this || defaults;
        utils.forEach(fns, function transform(fn) {
          data = fn.call(context, data, headers);
        });
        return data;
      };
    }
  });

  // node_modules/axios/lib/cancel/isCancel.js
  var require_isCancel = __commonJS({
    "node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      module.exports = function isCancel(value) {
        return !!(value && value.__CANCEL__);
      };
    }
  });

  // node_modules/axios/lib/core/dispatchRequest.js
  var require_dispatchRequest = __commonJS({
    "node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var utils = require_utils2();
      var transformData = require_transformData();
      var isCancel = require_isCancel();
      var defaults = require_defaults();
      var Cancel = require_Cancel();
      function throwIfCancellationRequested(config2) {
        if (config2.cancelToken) {
          config2.cancelToken.throwIfRequested();
        }
        if (config2.signal && config2.signal.aborted) {
          throw new Cancel("canceled");
        }
      }
      module.exports = function dispatchRequest(config2) {
        throwIfCancellationRequested(config2);
        config2.headers = config2.headers || {};
        config2.data = transformData.call(
          config2,
          config2.data,
          config2.headers,
          config2.transformRequest
        );
        config2.headers = utils.merge(
          config2.headers.common || {},
          config2.headers[config2.method] || {},
          config2.headers
        );
        utils.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          function cleanHeaderConfig(method) {
            delete config2.headers[method];
          }
        );
        var adapter = config2.adapter || defaults.adapter;
        return adapter(config2).then(function onAdapterResolution(response) {
          throwIfCancellationRequested(config2);
          response.data = transformData.call(
            config2,
            response.data,
            response.headers,
            config2.transformResponse
          );
          return response;
        }, function onAdapterRejection(reason) {
          if (!isCancel(reason)) {
            throwIfCancellationRequested(config2);
            if (reason && reason.response) {
              reason.response.data = transformData.call(
                config2,
                reason.response.data,
                reason.response.headers,
                config2.transformResponse
              );
            }
          }
          return Promise.reject(reason);
        });
      };
    }
  });

  // node_modules/axios/lib/core/mergeConfig.js
  var require_mergeConfig = __commonJS({
    "node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var utils = require_utils2();
      module.exports = function mergeConfig(config1, config2) {
        config2 = config2 || {};
        var config3 = {};
        function getMergedValue(target, source) {
          if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
            return utils.merge(target, source);
          } else if (utils.isPlainObject(source)) {
            return utils.merge({}, source);
          } else if (utils.isArray(source)) {
            return source.slice();
          }
          return source;
        }
        function mergeDeepProperties(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(config1[prop], config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        function valueFromConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(void 0, config2[prop]);
          }
        }
        function defaultToConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(void 0, config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        function mergeDirectKeys(prop) {
          if (prop in config2) {
            return getMergedValue(config1[prop], config2[prop]);
          } else if (prop in config1) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        var mergeMap = {
          "url": valueFromConfig2,
          "method": valueFromConfig2,
          "data": valueFromConfig2,
          "baseURL": defaultToConfig2,
          "transformRequest": defaultToConfig2,
          "transformResponse": defaultToConfig2,
          "paramsSerializer": defaultToConfig2,
          "timeout": defaultToConfig2,
          "timeoutMessage": defaultToConfig2,
          "withCredentials": defaultToConfig2,
          "adapter": defaultToConfig2,
          "responseType": defaultToConfig2,
          "xsrfCookieName": defaultToConfig2,
          "xsrfHeaderName": defaultToConfig2,
          "onUploadProgress": defaultToConfig2,
          "onDownloadProgress": defaultToConfig2,
          "decompress": defaultToConfig2,
          "maxContentLength": defaultToConfig2,
          "maxBodyLength": defaultToConfig2,
          "transport": defaultToConfig2,
          "httpAgent": defaultToConfig2,
          "httpsAgent": defaultToConfig2,
          "cancelToken": defaultToConfig2,
          "socketPath": defaultToConfig2,
          "responseEncoding": defaultToConfig2,
          "validateStatus": mergeDirectKeys
        };
        utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
          var merge = mergeMap[prop] || mergeDeepProperties;
          var configValue = merge(prop);
          utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config3[prop] = configValue);
        });
        return config3;
      };
    }
  });

  // node_modules/axios/lib/env/data.js
  var require_data = __commonJS({
    "node_modules/axios/lib/env/data.js"(exports, module) {
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      module.exports = {
        "version": "0.25.0"
      };
    }
  });

  // node_modules/axios/lib/helpers/validator.js
  var require_validator = __commonJS({
    "node_modules/axios/lib/helpers/validator.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var VERSION = require_data().version;
      var validators = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
        validators[type] = function validator(thing) {
          return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
        };
      });
      var deprecatedWarnings = {};
      validators.transitional = function transitional(validator, version2, message) {
        function formatMessage(opt, desc) {
          return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
        }
        return function(value, opt, opts) {
          if (validator === false) {
            throw new Error(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")));
          }
          if (version2 && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            console.warn(
              formatMessage(
                opt,
                " has been deprecated since v" + version2 + " and will be removed in the near future"
              )
            );
          }
          return validator ? validator(value, opt, opts) : true;
        };
      };
      function assertOptions(options, schema, allowUnknown) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        var keys = Object.keys(options);
        var i = keys.length;
        while (i-- > 0) {
          var opt = keys[i];
          var validator = schema[opt];
          if (validator) {
            var value = options[opt];
            var result = value === void 0 || validator(value, opt, options);
            if (result !== true) {
              throw new TypeError("option " + opt + " must be " + result);
            }
            continue;
          }
          if (allowUnknown !== true) {
            throw Error("Unknown option " + opt);
          }
        }
      }
      module.exports = {
        assertOptions,
        validators
      };
    }
  });

  // node_modules/axios/lib/core/Axios.js
  var require_Axios = __commonJS({
    "node_modules/axios/lib/core/Axios.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var utils = require_utils2();
      var buildURL = require_buildURL();
      var InterceptorManager = require_InterceptorManager();
      var dispatchRequest = require_dispatchRequest();
      var mergeConfig = require_mergeConfig();
      var validator = require_validator();
      var validators = validator.validators;
      function Axios(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }
      Axios.prototype.request = function request(configOrUrl, config2) {
        if (typeof configOrUrl === "string") {
          config2 = config2 || {};
          config2.url = configOrUrl;
        } else {
          config2 = configOrUrl || {};
        }
        if (!config2.url) {
          throw new Error("Provided config url is not valid");
        }
        config2 = mergeConfig(this.defaults, config2);
        if (config2.method) {
          config2.method = config2.method.toLowerCase();
        } else if (this.defaults.method) {
          config2.method = this.defaults.method.toLowerCase();
        } else {
          config2.method = "get";
        }
        var transitional = config2.transitional;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        var requestInterceptorChain = [];
        var synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        var responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        var promise;
        if (!synchronousRequestInterceptors) {
          var chain = [dispatchRequest, void 0];
          Array.prototype.unshift.apply(chain, requestInterceptorChain);
          chain = chain.concat(responseInterceptorChain);
          promise = Promise.resolve(config2);
          while (chain.length) {
            promise = promise.then(chain.shift(), chain.shift());
          }
          return promise;
        }
        var newConfig = config2;
        while (requestInterceptorChain.length) {
          var onFulfilled = requestInterceptorChain.shift();
          var onRejected = requestInterceptorChain.shift();
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected(error);
            break;
          }
        }
        try {
          promise = dispatchRequest(newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        while (responseInterceptorChain.length) {
          promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
        }
        return promise;
      };
      Axios.prototype.getUri = function getUri(config2) {
        if (!config2.url) {
          throw new Error("Provided config url is not valid");
        }
        config2 = mergeConfig(this.defaults, config2);
        return buildURL(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
      };
      utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
        Axios.prototype[method] = function(url, config2) {
          return this.request(mergeConfig(config2 || {}, {
            method,
            url,
            data: (config2 || {}).data
          }));
        };
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        Axios.prototype[method] = function(url, data, config2) {
          return this.request(mergeConfig(config2 || {}, {
            method,
            url,
            data
          }));
        };
      });
      module.exports = Axios;
    }
  });

  // node_modules/axios/lib/cancel/CancelToken.js
  var require_CancelToken = __commonJS({
    "node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var Cancel = require_Cancel();
      function CancelToken(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        var token = this;
        this.promise.then(function(cancel) {
          if (!token._listeners)
            return;
          var i;
          var l = token._listeners.length;
          for (i = 0; i < l; i++) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = function(onfulfilled) {
          var _resolve;
          var promise = new Promise(function(resolve) {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message) {
          if (token.reason) {
            return;
          }
          token.reason = new Cancel(message);
          resolvePromise(token.reason);
        });
      }
      CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };
      CancelToken.prototype.subscribe = function subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      };
      CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        var index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      };
      CancelToken.source = function source() {
        var cancel;
        var token = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      };
      module.exports = CancelToken;
    }
  });

  // node_modules/axios/lib/helpers/spread.js
  var require_spread = __commonJS({
    "node_modules/axios/lib/helpers/spread.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      module.exports = function spread(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      };
    }
  });

  // node_modules/axios/lib/helpers/isAxiosError.js
  var require_isAxiosError = __commonJS({
    "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var utils = require_utils2();
      module.exports = function isAxiosError(payload) {
        return utils.isObject(payload) && payload.isAxiosError === true;
      };
    }
  });

  // node_modules/axios/lib/axios.js
  var require_axios = __commonJS({
    "node_modules/axios/lib/axios.js"(exports, module) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var utils = require_utils2();
      var bind = require_bind();
      var Axios = require_Axios();
      var mergeConfig = require_mergeConfig();
      var defaults = require_defaults();
      function createInstance(defaultConfig) {
        var context = new Axios(defaultConfig);
        var instance = bind(Axios.prototype.request, context);
        utils.extend(instance, Axios.prototype, context);
        utils.extend(instance, context);
        instance.create = function create(instanceConfig) {
          return createInstance(mergeConfig(defaultConfig, instanceConfig));
        };
        return instance;
      }
      var axios = createInstance(defaults);
      axios.Axios = Axios;
      axios.Cancel = require_Cancel();
      axios.CancelToken = require_CancelToken();
      axios.isCancel = require_isCancel();
      axios.VERSION = require_data().version;
      axios.all = function all(promises) {
        return Promise.all(promises);
      };
      axios.spread = require_spread();
      axios.isAxiosError = require_isAxiosError();
      module.exports = axios;
      module.exports.default = axios;
    }
  });

  // node_modules/axios/index.js
  var require_axios2 = __commonJS({
    "node_modules/axios/index.js"(exports, module) {
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      module.exports = require_axios();
    }
  });

  // node_modules/ton/package.json
  var require_package = __commonJS({
    "node_modules/ton/package.json"(exports, module) {
      module.exports = {
        name: "ton",
        version: "13.3.0",
        repository: "https://github.com/tonwhales/ton.git",
        author: "Steve Korshakov <steve@korshakov.com>",
        license: "MIT",
        main: "dist/index.js",
        files: [
          "dist"
        ],
        scripts: {
          build: "rm -fr dist && tsc --declaration",
          test: "jest --verbose --runInBand",
          release: "yarn build && yarn release-it --npm.yarn1"
        },
        devDependencies: {
          "@release-it/keep-a-changelog": "^3.1.0",
          "@types/jest": "^27.0.1",
          "@types/node": "^16.7.10",
          buffer: "^6.0.3",
          expect: "^27.1.0",
          jest: "^27.1.0",
          "jest-mock": "^27.1.0",
          karma: "^6.3.4",
          "karma-chrome-launcher": "^3.1.0",
          "karma-jasmine": "^4.0.1",
          "karma-typescript": "^5.5.2",
          "karma-webpack": "^5.0.0",
          prando: "^6.0.1",
          "release-it": "^15.5.1",
          "ton-core": "^0.32.0",
          "ton-crypto": "3.2.0",
          "ts-jest": "^27.0.5",
          "ts-loader": "^9.2.5",
          "ts-node": "^10.7.0",
          typescript: "^4.4.2",
          webpack: "^5.51.2"
        },
        dependencies: {
          axios: "^0.25.0",
          dataloader: "^2.0.0",
          "fp-ts": "^2.11.1",
          "io-ts": "^2.2.16",
          "io-ts-reporters": "^2.0.0",
          "symbol.inspect": "1.0.1",
          teslabot: "^1.3.0"
        },
        peerDependencies: {
          "ton-core": ">=0.32.0",
          "ton-crypto": ">=3.2.0"
        },
        publishConfig: {
          access: "public",
          registry: "https://registry.npmjs.org/"
        },
        "release-it": {
          github: {
            release: true
          },
          plugins: {
            "@release-it/keep-a-changelog": {
              filename: "CHANGELOG.md"
            }
          }
        }
      };
    }
  });

  // node_modules/ton/dist/client/api/HttpApi.js
  var require_HttpApi = __commonJS({
    "node_modules/ton/dist/client/api/HttpApi.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault2 = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HttpApi = void 0;
      var t = __importStar2(require_lib());
      var Either_1 = require_Either();
      var io_ts_reporters_1 = __importDefault2(require_src());
      var TonCache_1 = require_TonCache();
      var dataloader_1 = __importDefault2(require_dataloader());
      var axios_1 = __importDefault2(require_axios2());
      var version2 = require_package().version;
      var blockIdExt = t.type({
        "@type": t.literal("ton.blockIdExt"),
        workchain: t.number,
        shard: t.string,
        seqno: t.number,
        root_hash: t.string,
        file_hash: t.string
      });
      var addressInformation = t.type({
        balance: t.union([t.number, t.string]),
        state: t.union([t.literal("active"), t.literal("uninitialized"), t.literal("frozen")]),
        data: t.string,
        code: t.string,
        last_transaction_id: t.type({
          "@type": t.literal("internal.transactionId"),
          lt: t.string,
          hash: t.string
        }),
        block_id: blockIdExt,
        sync_utime: t.number
      });
      var bocResponse = t.type({
        "@type": t.literal("ok")
      });
      var feeResponse = t.type({
        "@type": t.literal("query.fees"),
        source_fees: t.type({
          "@type": t.literal("fees"),
          in_fwd_fee: t.number,
          storage_fee: t.number,
          gas_fee: t.number,
          fwd_fee: t.number
        })
      });
      var callGetMethod = t.type({
        gas_used: t.number,
        exit_code: t.number,
        stack: t.array(t.unknown)
      });
      var messageData = t.union([
        t.type({
          "@type": t.literal("msg.dataRaw"),
          "body": t.string
        }),
        t.type({
          "@type": t.literal("msg.dataText"),
          "text": t.string
        }),
        t.type({
          "@type": t.literal("msg.dataDecryptedText"),
          "text": t.string
        }),
        t.type({
          "@type": t.literal("msg.dataEncryptedText"),
          "text": t.string
        })
      ]);
      var message = t.type({
        source: t.string,
        destination: t.string,
        value: t.string,
        fwd_fee: t.string,
        ihr_fee: t.string,
        created_lt: t.string,
        body_hash: t.string,
        msg_data: messageData
      });
      var transaction = t.type({
        data: t.string,
        utime: t.number,
        transaction_id: t.type({
          lt: t.string,
          hash: t.string
        }),
        fee: t.string,
        storage_fee: t.string,
        other_fee: t.string,
        in_msg: t.union([t.undefined, message]),
        out_msgs: t.array(message)
      });
      var getTransactions = t.array(transaction);
      var getMasterchain = t.type({
        state_root_hash: t.string,
        last: blockIdExt,
        init: blockIdExt
      });
      var getShards = t.type({
        shards: t.array(blockIdExt)
      });
      var blockShortTxt = t.type({
        "@type": t.literal("blocks.shortTxId"),
        mode: t.number,
        account: t.string,
        lt: t.string,
        hash: t.string
      });
      var getBlockTransactions = t.type({
        id: blockIdExt,
        req_count: t.number,
        incomplete: t.boolean,
        transactions: t.array(blockShortTxt)
      });
      var TypedCache = class {
        constructor(namespace, cache, codec, keyEncoder) {
          this.namespace = namespace;
          this.cache = cache;
          this.codec = codec;
          this.keyEncoder = keyEncoder;
        }
        async get(key) {
          let ex = await this.cache.get(this.namespace, this.keyEncoder(key));
          if (ex) {
            let decoded = this.codec.decode(JSON.parse(ex));
            if ((0, Either_1.isRight)(decoded)) {
              return decoded.right;
            }
          }
          return null;
        }
        async set(key, value) {
          if (value !== null) {
            await this.cache.set(this.namespace, this.keyEncoder(key), JSON.stringify(value));
          } else {
            await this.cache.set(this.namespace, this.keyEncoder(key), null);
          }
        }
      };
      var HttpApi = class {
        constructor(endpoint, parameters) {
          this.endpoint = endpoint;
          this.cache = new TonCache_1.InMemoryCache();
          this.parameters = {
            timeout: parameters?.timeout || 3e4,
            apiKey: parameters?.apiKey
          };
          this.shardCache = new TypedCache("ton-shard", this.cache, t.array(blockIdExt), (src) => src + "");
          this.shardLoader = new dataloader_1.default(async (src) => {
            return await Promise.all(src.map(async (v) => {
              const cached = await this.shardCache.get(v);
              if (cached) {
                return cached;
              }
              let loaded = (await this.doCall("shards", { seqno: v }, getShards)).shards;
              await this.shardCache.set(v, loaded);
              return loaded;
            }));
          });
          this.shardTransactionsCache = new TypedCache("ton-shard-tx", this.cache, getBlockTransactions, (src) => src.workchain + ":" + src.shard + ":" + src.seqno);
          this.shardTransactionsLoader = new dataloader_1.default(async (src) => {
            return await Promise.all(src.map(async (v) => {
              const cached = await this.shardTransactionsCache.get(v);
              if (cached) {
                return cached;
              }
              let loaded = await this.doCall("getBlockTransactions", { workchain: v.workchain, seqno: v.seqno, shard: v.shard }, getBlockTransactions);
              await this.shardTransactionsCache.set(v, loaded);
              return loaded;
            }));
          }, { cacheKeyFn: (src) => src.workchain + ":" + src.shard + ":" + src.seqno });
        }
        getAddressInformation(address) {
          return this.doCall("getAddressInformation", { address: address.toString() }, addressInformation);
        }
        async getTransactions(address, opts) {
          const inclusive = opts.inclusive;
          delete opts.inclusive;
          let hash = void 0;
          if (opts.hash) {
            hash = Buffer2.from(opts.hash, "base64").toString("hex");
          }
          let limit = opts.limit;
          if (opts.hash && opts.lt && inclusive !== true) {
            limit++;
          }
          let res = await this.doCall("getTransactions", { address: address.toString(), ...opts, limit, hash }, getTransactions);
          if (res.length > limit) {
            res = res.slice(0, limit);
          }
          if (opts.hash && opts.lt && inclusive !== true) {
            res.shift();
            return res;
          } else {
            return res;
          }
        }
        async getMasterchainInfo() {
          return await this.doCall("getMasterchainInfo", {}, getMasterchain);
        }
        async getShards(seqno) {
          return await this.shardLoader.load(seqno);
        }
        async getBlockTransactions(workchain, seqno, shard) {
          return await this.shardTransactionsLoader.load({ workchain, seqno, shard });
        }
        async getTransaction(address, lt, hash) {
          let convHash = Buffer2.from(hash, "base64").toString("hex");
          let res = await this.doCall("getTransactions", { address: address.toString(), lt, hash: convHash, limit: 1 }, getTransactions);
          let ex = res.find((v) => v.transaction_id.lt === lt && v.transaction_id.hash === hash);
          if (ex) {
            return ex;
          } else {
            return null;
          }
        }
        async callGetMethod(address, method, stack) {
          return await this.doCall("runGetMethod", { address: address.toString(), method, stack: serializeStack(stack) }, callGetMethod);
        }
        async sendBoc(body) {
          await this.doCall("sendBoc", { boc: body.toString("base64") }, bocResponse);
        }
        async estimateFee(address, args) {
          return await this.doCall("estimateFee", {
            address: address.toString(),
            body: args.body.toBoc().toString("base64"),
            "init_data": args.initData ? args.initData.toBoc().toString("base64") : "",
            "init_code": args.initCode ? args.initCode.toBoc().toString("base64") : "",
            ignore_chksig: args.ignoreSignature
          }, feeResponse);
        }
        async doCall(method, body, codec) {
          let headers = {
            "Content-Type": "application/json",
            "X-Ton-Client-Version": version2
          };
          if (this.parameters.apiKey) {
            headers["X-API-Key"] = this.parameters.apiKey;
          }
          let res = await axios_1.default.post(this.endpoint, JSON.stringify({
            id: "1",
            jsonrpc: "2.0",
            method,
            params: body
          }), {
            headers,
            timeout: this.parameters.timeout
          });
          if (res.status !== 200 || !res.data.ok) {
            throw Error("Received error: " + JSON.stringify(res.data));
          }
          let decoded = codec.decode(res.data.result);
          if ((0, Either_1.isRight)(decoded)) {
            return decoded.right;
          } else {
            throw Error("Malformed response: " + io_ts_reporters_1.default.report(decoded).join(", "));
          }
        }
      };
      exports.HttpApi = HttpApi;
      function serializeStack(src) {
        let stack = [];
        for (let s of src) {
          if (s.type === "int") {
            stack.push(["num", s.value.toString()]);
          } else if (s.type === "cell") {
            stack.push(["tvm.Cell", s.cell.toBoc().toString("base64")]);
          } else if (s.type === "slice") {
            stack.push(["tvm.Slice", s.cell.toBoc().toString("base64")]);
          } else if (s.type === "builder") {
            stack.push(["tvm.Builder", s.cell.toBoc().toString("base64")]);
          } else {
            throw Error("Unsupported stack item type: " + s.type);
          }
        }
        return stack;
      }
    }
  });

  // node_modules/ton/dist/client/TonClient.js
  var require_TonClient = __commonJS({
    "node_modules/ton/dist/client/TonClient.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var _TonClient_api;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TonClient = void 0;
      var HttpApi_1 = require_HttpApi();
      var ton_core_1 = require_dist2();
      var TonClient2 = class {
        constructor(parameters) {
          _TonClient_api.set(this, void 0);
          this.parameters = {
            endpoint: parameters.endpoint
          };
          __classPrivateFieldSet2(this, _TonClient_api, new HttpApi_1.HttpApi(this.parameters.endpoint, {
            timeout: parameters.timeout,
            apiKey: parameters.apiKey,
            adapter: parameters.httpAdapter
          }), "f");
        }
        /**
         * Get Address Balance
         * @param address address for balance check
         * @returns balance
         */
        async getBalance(address) {
          return (await this.getContractState(address)).balance;
        }
        /**
         * Invoke get method
         * @param address contract address
         * @param name name of method
         * @param params optional parameters
         * @returns stack and gas_used field
         */
        async callGetMethod(address, name, stack = []) {
          let res = await __classPrivateFieldGet2(this, _TonClient_api, "f").callGetMethod(address, name, stack);
          if (res.exit_code !== 0) {
            throw Error("Unable to execute get method. Got exit_code: " + res.exit_code);
          }
          return { gas_used: res.gas_used, stack: parseStack(res.stack) };
        }
        /**
         * Invoke get method that returns error code instead of throwing error
         * @param address contract address
         * @param name name of method
         * @param params optional parameters
         * @returns stack and gas_used field
        */
        async callGetMethodWithError(address, name, params = []) {
          let res = await __classPrivateFieldGet2(this, _TonClient_api, "f").callGetMethod(address, name, params);
          return { gas_used: res.gas_used, stack: parseStack(res.stack), exit_code: res.exit_code };
        }
        /**
         * Get transactions
         * @param address address
         */
        async getTransactions(address, opts) {
          let tx = await __classPrivateFieldGet2(this, _TonClient_api, "f").getTransactions(address, opts);
          let res = [];
          for (let r of tx) {
            res.push((0, ton_core_1.loadTransaction)(ton_core_1.Cell.fromBoc(Buffer2.from(r.data, "base64"))[0].beginParse()));
          }
          return res;
        }
        /**
         * Get transaction by it's id
         * @param address address
         * @param lt logical time
         * @param hash transaction hash
         * @returns transaction or null if not exist
         */
        async getTransaction(address, lt, hash) {
          let res = await __classPrivateFieldGet2(this, _TonClient_api, "f").getTransaction(address, lt, hash);
          if (res) {
            return (0, ton_core_1.loadTransaction)(ton_core_1.Cell.fromBoc(Buffer2.from(res.data, "base64"))[0].beginParse());
          } else {
            return null;
          }
        }
        /**
         * Fetch latest masterchain info
         * @returns masterchain info
         */
        async getMasterchainInfo() {
          let r = await __classPrivateFieldGet2(this, _TonClient_api, "f").getMasterchainInfo();
          return {
            workchain: r.init.workchain,
            shard: r.last.shard,
            initSeqno: r.init.seqno,
            latestSeqno: r.last.seqno
          };
        }
        /**
         * Fetch latest workchain shards
         * @param seqno masterchain seqno
         */
        async getWorkchainShards(seqno) {
          let r = await __classPrivateFieldGet2(this, _TonClient_api, "f").getShards(seqno);
          return r.map((m) => ({
            workchain: m.workchain,
            shard: m.shard,
            seqno: m.seqno
          }));
        }
        /**
         * Fetch transactions inf shards
         * @param workchain
         * @param seqno
         * @param shard
         */
        async getShardTransactions(workchain, seqno, shard) {
          let tx = await __classPrivateFieldGet2(this, _TonClient_api, "f").getBlockTransactions(workchain, seqno, shard);
          if (tx.incomplete) {
            throw Error("Unsupported");
          }
          return tx.transactions.map((v) => ({
            account: ton_core_1.Address.parseRaw(v.account),
            lt: v.lt,
            hash: v.hash
          }));
        }
        /**
         * Send message to a network
         * @param src source message
         */
        async sendMessage(src) {
          const boc = (0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessage)(src)).endCell().toBoc();
          await __classPrivateFieldGet2(this, _TonClient_api, "f").sendBoc(boc);
        }
        /**
         * Send file to a network
         * @param src source file
         */
        async sendFile(src) {
          await __classPrivateFieldGet2(this, _TonClient_api, "f").sendBoc(src);
        }
        /**
         * Estimate fees for external message
         * @param address target address
         * @returns
         */
        async estimateExternalMessageFee(address, args) {
          return await __classPrivateFieldGet2(this, _TonClient_api, "f").estimateFee(address, { body: args.body, initCode: args.initCode, initData: args.initData, ignoreSignature: args.ignoreSignature });
        }
        /**
         * Send external message to contract
         * @param contract contract to send message
         * @param src message body
         */
        async sendExternalMessage(contract, src) {
          if (await this.isContractDeployed(contract.address) || !contract.init) {
            const message = (0, ton_core_1.external)({
              to: contract.address,
              body: src
            });
            await this.sendMessage(message);
          } else {
            const message = (0, ton_core_1.external)({
              to: contract.address,
              init: { code: contract.init.code, data: contract.init.data },
              body: src
            });
            await this.sendMessage(message);
          }
        }
        /**
         * Check if contract is deployed
         * @param address addres to check
         * @returns true if contract is in active state
         */
        async isContractDeployed(address) {
          return (await this.getContractState(address)).state === "active";
        }
        /**
         * Resolves contract state
         * @param address contract address
         */
        async getContractState(address) {
          let info = await __classPrivateFieldGet2(this, _TonClient_api, "f").getAddressInformation(address);
          let balance = BigInt(info.balance);
          let state = info.state;
          return {
            balance,
            state,
            code: info.code !== "" ? Buffer2.from(info.code, "base64") : null,
            data: info.data !== "" ? Buffer2.from(info.data, "base64") : null,
            lastTransaction: info.last_transaction_id.lt !== "0" ? {
              lt: info.last_transaction_id.lt,
              hash: info.last_transaction_id.hash
            } : null,
            blockId: {
              workchain: info.block_id.workchain,
              shard: info.block_id.shard,
              seqno: info.block_id.seqno
            },
            timestampt: info.sync_utime
          };
        }
        /**
         * Open contract
         * @param src source contract
         * @returns contract
         */
        open(src) {
          return (0, ton_core_1.openContract)(src, (args) => createProvider(this, args.address, args.init));
        }
        /**
         * Create a provider
         * @param address address
         * @param init optional init
         * @returns provider
         */
        provider(address, init2) {
          return createProvider(this, address, init2);
        }
      };
      exports.TonClient = TonClient2;
      _TonClient_api = /* @__PURE__ */ new WeakMap();
      function parseStack(src) {
        let stack = [];
        for (let s of src) {
          if (s[0] === "num") {
            let val = s[1];
            if (val.startsWith("-")) {
              stack.push({ type: "int", value: -BigInt(val.slice(1)) });
            } else {
              stack.push({ type: "int", value: BigInt(val) });
            }
          } else if (s[0] === "null") {
            stack.push({ type: "null" });
          } else if (s[0] === "cell") {
            stack.push({ type: "cell", cell: ton_core_1.Cell.fromBoc(Buffer2.from(s[1].bytes, "base64"))[0] });
          } else if (s[0] === "slice") {
            stack.push({ type: "slice", cell: ton_core_1.Cell.fromBoc(Buffer2.from(s[1].bytes, "base64"))[0] });
          } else if (s[0] === "builder") {
            stack.push({ type: "builder", cell: ton_core_1.Cell.fromBoc(Buffer2.from(s[1].bytes, "base64"))[0] });
          } else {
            throw Error("Unsupported stack item type: " + s[0]);
          }
        }
        return new ton_core_1.TupleReader(stack);
      }
      function createProvider(client, address, init2) {
        return {
          async getState() {
            let state = await client.getContractState(address);
            let balance = state.balance;
            let last = state.lastTransaction ? { lt: BigInt(state.lastTransaction.lt), hash: Buffer2.from(state.lastTransaction.hash, "base64") } : null;
            let storage;
            if (state.state === "active") {
              storage = {
                type: "active",
                code: state.code ? state.code : null,
                data: state.data ? state.data : null
              };
            } else if (state.state === "uninitialized") {
              storage = {
                type: "uninit"
              };
            } else if (state.state === "frozen") {
              storage = {
                type: "frozen",
                stateHash: Buffer2.alloc(0)
              };
            } else {
              throw Error("Unsupported state");
            }
            return {
              balance,
              last,
              state: storage
            };
          },
          async get(name, args) {
            let method = await client.callGetMethod(address, name, args);
            return { stack: method.stack };
          },
          async external(message) {
            let neededInit = null;
            if (init2 && !await client.isContractDeployed(address)) {
              neededInit = init2;
            }
            const ext = (0, ton_core_1.external)({
              to: address,
              init: neededInit ? { code: neededInit.code, data: neededInit.data } : null,
              body: message
            });
            let boc = (0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessage)(ext)).endCell().toBoc();
            await client.sendFile(boc);
          },
          async internal(via, message) {
            let neededInit = null;
            if (init2 && !await client.isContractDeployed(address)) {
              neededInit = init2;
            }
            let bounce = true;
            if (message.bounce !== null && message.bounce !== void 0) {
              bounce = message.bounce;
            }
            let value;
            if (typeof message.value === "string") {
              value = (0, ton_core_1.toNano)(message.value);
            } else {
              value = message.value;
            }
            let body = null;
            if (typeof message.body === "string") {
              body = (0, ton_core_1.comment)(message.body);
            } else if (message.body) {
              body = message.body;
            }
            await via.send({
              to: address,
              value,
              bounce,
              sendMode: message.sendMode,
              init: neededInit,
              body
            });
          }
        };
      }
    }
  });

  // node_modules/ton/dist/utils/toUrlSafe.js
  var require_toUrlSafe = __commonJS({
    "node_modules/ton/dist/utils/toUrlSafe.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toUrlSafe = void 0;
      function toUrlSafe(src) {
        while (src.indexOf("/") >= 0) {
          src = src.replace("/", "_");
        }
        while (src.indexOf("+") >= 0) {
          src = src.replace("+", "-");
        }
        while (src.indexOf("=") >= 0) {
          src = src.replace("=", "");
        }
        return src;
      }
      exports.toUrlSafe = toUrlSafe;
    }
  });

  // node_modules/ton/dist/client/TonClient4.js
  var require_TonClient4 = __commonJS({
    "node_modules/ton/dist/client/TonClient4.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar2 = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      var __importDefault2 = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var _TonClient4_endpoint;
      var _TonClient4_timeout;
      var _TonClient4_adapter;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TonClient4 = void 0;
      var axios_1 = __importDefault2(require_axios2());
      var t = __importStar2(require_lib());
      var ton_core_1 = require_dist2();
      var toUrlSafe_1 = require_toUrlSafe();
      var TonClient4 = class {
        constructor(args) {
          _TonClient4_endpoint.set(this, void 0);
          _TonClient4_timeout.set(this, void 0);
          _TonClient4_adapter.set(this, void 0);
          __classPrivateFieldSet2(this, _TonClient4_endpoint, args.endpoint, "f");
          __classPrivateFieldSet2(this, _TonClient4_timeout, args.timeout || 5e3, "f");
          __classPrivateFieldSet2(this, _TonClient4_adapter, args.httpAdapter, "f");
        }
        /**
         * Get Last Block
         * @returns last block info
         */
        async getLastBlock() {
          let res = await axios_1.default.get(__classPrivateFieldGet2(this, _TonClient4_endpoint, "f") + "/block/latest", { adapter: __classPrivateFieldGet2(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet2(this, _TonClient4_timeout, "f") });
          if (!lastBlockCodec.is(res.data)) {
            throw Error("Mailformed response");
          }
          return res.data;
        }
        /**
         * Get block info
         * @param seqno block sequence number
         * @returns block info
         */
        async getBlock(seqno) {
          let res = await axios_1.default.get(__classPrivateFieldGet2(this, _TonClient4_endpoint, "f") + "/block/" + seqno, { adapter: __classPrivateFieldGet2(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet2(this, _TonClient4_timeout, "f") });
          if (!blockCodec.is(res.data)) {
            throw Error("Mailformed response");
          }
          if (!res.data.exist) {
            throw Error("Block is out of scope");
          }
          return res.data.block;
        }
        /**
         * Get block info by unix timestamp
         * @param ts unix timestamp
         * @returns block info
         */
        async getBlockByUtime(ts) {
          let res = await axios_1.default.get(__classPrivateFieldGet2(this, _TonClient4_endpoint, "f") + "/block/utime/" + ts, { adapter: __classPrivateFieldGet2(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet2(this, _TonClient4_timeout, "f") });
          if (!blockCodec.is(res.data)) {
            throw Error("Mailformed response");
          }
          if (!res.data.exist) {
            throw Error("Block is out of scope");
          }
          return res.data.block;
        }
        /**
         * Get block info by unix timestamp
         * @param seqno block sequence number
         * @param address account address
         * @returns account info
         */
        async getAccount(seqno, address) {
          let res = await axios_1.default.get(__classPrivateFieldGet2(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }), { adapter: __classPrivateFieldGet2(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet2(this, _TonClient4_timeout, "f") });
          if (!accountCodec.is(res.data)) {
            throw Error("Mailformed response");
          }
          return res.data;
        }
        /**
         * Get account lite info (without code and data)
         * @param seqno block sequence number
         * @param address account address
         * @returns account lite info
         */
        async getAccountLite(seqno, address) {
          let res = await axios_1.default.get(__classPrivateFieldGet2(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/lite", { adapter: __classPrivateFieldGet2(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet2(this, _TonClient4_timeout, "f") });
          if (!accountLiteCodec.is(res.data)) {
            throw Error("Mailformed response");
          }
          return res.data;
        }
        /**
         * Check if account was updated since
         * @param seqno block sequence number
         * @param address account address
         * @param lt account last transaction lt
         * @returns account change info
         */
        async isAccountChanged(seqno, address, lt) {
          let res = await axios_1.default.get(__classPrivateFieldGet2(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/changed/" + lt.toString(10), { adapter: __classPrivateFieldGet2(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet2(this, _TonClient4_timeout, "f") });
          if (!changedCodec.is(res.data)) {
            throw Error("Mailformed response");
          }
          return res.data;
        }
        /**
         * Load one unparsed account transaction
         * @param seqno block sequence number
         * @param address account address
         * @param lt account last transaction lt
         * @returns one unparsed transaction
         */
        async getTransaction(seqno, address, lt) {
          const urladdr = address.toString({ urlSafe: true });
          const urlpath = `/block/${seqno}/${urladdr}/tx/${lt.toString(10)}`;
          const res = await axios_1.default.get(new URL(urlpath, __classPrivateFieldGet2(this, _TonClient4_endpoint, "f")).href, { adapter: __classPrivateFieldGet2(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet2(this, _TonClient4_timeout, "f") });
          if (!transactionCodec.is(res.data))
            throw Error("Mailformed response");
          const txcell = ton_core_1.Cell.fromBoc(Buffer2.from(res.data.boc, "base64"))[0];
          return { tx: (0, ton_core_1.loadTransaction)(txcell.beginParse()), ...res.data };
        }
        /**
         * Load unparsed account transactions
         * @param address address
         * @param lt last transaction lt
         * @param hash last transaction hash
         * @returns unparsed transactions
         */
        async getAccountTransactions(address, lt, hash) {
          let res = await axios_1.default.get(__classPrivateFieldGet2(this, _TonClient4_endpoint, "f") + "/account/" + address.toString({ urlSafe: true }) + "/tx/" + lt.toString(10) + "/" + (0, toUrlSafe_1.toUrlSafe)(hash.toString("base64")), { adapter: __classPrivateFieldGet2(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet2(this, _TonClient4_timeout, "f") });
          if (!transactionsCodec.is(res.data)) {
            throw Error("Mailformed response");
          }
          let data = res.data;
          let tx = [];
          let cells = ton_core_1.Cell.fromBoc(Buffer2.from(data.boc, "base64"));
          for (let i = 0; i < data.blocks.length; i++) {
            tx.push({
              block: data.blocks[i],
              tx: (0, ton_core_1.loadTransaction)(cells[i].beginParse())
            });
          }
          return tx;
        }
        /**
         * Get network config
         * @param seqno block sequence number
         * @param ids optional config ids
         * @returns network config
         */
        async getConfig(seqno, ids) {
          let tail = "";
          if (ids && ids.length > 0) {
            tail = "/" + [...ids].sort().join(",");
          }
          let res = await axios_1.default.get(__classPrivateFieldGet2(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/config" + tail, { adapter: __classPrivateFieldGet2(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet2(this, _TonClient4_timeout, "f") });
          if (!configCodec.is(res.data)) {
            throw Error("Mailformed response");
          }
          return res.data;
        }
        /**
         * Execute run method
         * @param seqno block sequence number
         * @param address account address
         * @param name method name
         * @param args method arguments
         * @returns method result
         */
        async runMethod(seqno, address, name, args) {
          let tail = args && args.length > 0 ? "/" + (0, toUrlSafe_1.toUrlSafe)((0, ton_core_1.serializeTuple)(args).toBoc({ idx: false, crc32: false }).toString("base64")) : "";
          let url = __classPrivateFieldGet2(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/run/" + name + tail;
          let res = await axios_1.default.get(url, { adapter: __classPrivateFieldGet2(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet2(this, _TonClient4_timeout, "f") });
          if (!runMethodCodec.is(res.data)) {
            throw Error("Mailformed response");
          }
          return {
            exitCode: res.data.exitCode,
            result: res.data.resultRaw ? (0, ton_core_1.parseTuple)(ton_core_1.Cell.fromBoc(Buffer2.from(res.data.resultRaw, "base64"))[0]) : [],
            resultRaw: res.data.resultRaw,
            block: res.data.block,
            shardBlock: res.data.shardBlock
          };
        }
        /**
         * Send external message
         * @param message message boc
         * @returns message status
         */
        async sendMessage(message) {
          let res = await axios_1.default.post(__classPrivateFieldGet2(this, _TonClient4_endpoint, "f") + "/send", { boc: message.toString("base64") }, { adapter: __classPrivateFieldGet2(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet2(this, _TonClient4_timeout, "f") });
          if (!sendCodec.is(res.data)) {
            throw Error("Mailformed response");
          }
          return { status: res.data.status };
        }
        /**
         * Open smart contract
         * @param contract contract
         * @returns opened contract
         */
        open(contract) {
          return (0, ton_core_1.openContract)(contract, (args) => createProvider(this, null, args.address, args.init));
        }
        /**
         * Open smart contract
         * @param block block number
         * @param contract contract
         * @returns opened contract
         */
        openAt(block, contract) {
          return (0, ton_core_1.openContract)(contract, (args) => createProvider(this, block, args.address, args.init));
        }
        /**
         * Create provider
         * @param address address
         * @param init optional init data
         * @returns provider
         */
        provider(address, init2) {
          return createProvider(this, null, address, init2 ? init2 : null);
        }
        /**
         * Create provider at specified block number
         * @param block block number
         * @param address address
         * @param init optional init data
         * @returns provider
         */
        providerAt(block, address, init2) {
          return createProvider(this, block, address, init2 ? init2 : null);
        }
      };
      exports.TonClient4 = TonClient4;
      _TonClient4_endpoint = /* @__PURE__ */ new WeakMap(), _TonClient4_timeout = /* @__PURE__ */ new WeakMap(), _TonClient4_adapter = /* @__PURE__ */ new WeakMap();
      function createProvider(client, block, address, init2) {
        return {
          async getState() {
            let sq = block;
            if (sq === null) {
              let res = await client.getLastBlock();
              sq = res.last.seqno;
            }
            let state = await client.getAccount(sq, address);
            let last = state.account.last ? { lt: BigInt(state.account.last.lt), hash: Buffer2.from(state.account.last.hash, "base64") } : null;
            let storage;
            if (state.account.state.type === "active") {
              storage = {
                type: "active",
                code: state.account.state.code ? Buffer2.from(state.account.state.code, "base64") : null,
                data: state.account.state.data ? Buffer2.from(state.account.state.data, "base64") : null
              };
            } else if (state.account.state.type === "uninit") {
              storage = {
                type: "uninit"
              };
            } else if (state.account.state.type === "frozen") {
              storage = {
                type: "frozen",
                stateHash: Buffer2.from(state.account.state.stateHash, "base64")
              };
            } else {
              throw Error("Unsupported state");
            }
            return {
              balance: BigInt(state.account.balance.coins),
              last,
              state: storage
            };
          },
          async get(name, args) {
            let sq = block;
            if (sq === null) {
              let res = await client.getLastBlock();
              sq = res.last.seqno;
            }
            let method = await client.runMethod(sq, address, name, args);
            if (method.exitCode !== 0 && method.exitCode !== 1) {
              throw Error("Exit code: " + method.exitCode);
            }
            return {
              stack: new ton_core_1.TupleReader(method.result)
            };
          },
          async external(message) {
            let last = await client.getLastBlock();
            let neededInit = null;
            if (init2 && (await client.getAccountLite(last.last.seqno, address)).account.state.type !== "active") {
              neededInit = init2;
            }
            const ext = (0, ton_core_1.external)({
              to: address,
              init: neededInit ? { code: neededInit.code, data: neededInit.data } : null,
              body: message
            });
            let pkg = (0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessage)(ext)).endCell().toBoc();
            await client.sendMessage(pkg);
          },
          async internal(via, message) {
            let last = await client.getLastBlock();
            let neededInit = null;
            if (init2 && (await client.getAccountLite(last.last.seqno, address)).account.state.type !== "active") {
              neededInit = init2;
            }
            let bounce = true;
            if (message.bounce !== null && message.bounce !== void 0) {
              bounce = message.bounce;
            }
            let value;
            if (typeof message.value === "string") {
              value = (0, ton_core_1.toNano)(message.value);
            } else {
              value = message.value;
            }
            let body = null;
            if (typeof message.body === "string") {
              body = (0, ton_core_1.comment)(message.body);
            } else if (message.body) {
              body = message.body;
            }
            await via.send({
              to: address,
              value,
              bounce,
              sendMode: message.sendMode,
              init: neededInit,
              body
            });
          }
        };
      }
      var lastBlockCodec = t.type({
        last: t.type({
          seqno: t.number,
          shard: t.string,
          workchain: t.number,
          fileHash: t.string,
          rootHash: t.string
        }),
        init: t.type({
          fileHash: t.string,
          rootHash: t.string
        }),
        stateRootHash: t.string,
        now: t.number
      });
      var blockCodec = t.union([t.type({
        exist: t.literal(false)
      }), t.type({
        exist: t.literal(true),
        block: t.type({
          shards: t.array(t.type({
            workchain: t.number,
            seqno: t.number,
            shard: t.string,
            rootHash: t.string,
            fileHash: t.string,
            transactions: t.array(t.type({
              account: t.string,
              hash: t.string,
              lt: t.string
            }))
          }))
        })
      })]);
      var storageStatCodec = t.type({
        lastPaid: t.number,
        duePayment: t.union([t.null, t.string]),
        used: t.type({
          bits: t.number,
          cells: t.number,
          publicCells: t.number
        })
      });
      var accountCodec = t.type({
        account: t.type({
          state: t.union([
            t.type({ type: t.literal("uninit") }),
            t.type({ type: t.literal("active"), code: t.union([t.string, t.null]), data: t.union([t.string, t.null]) }),
            t.type({ type: t.literal("frozen"), stateHash: t.string })
          ]),
          balance: t.type({
            coins: t.string
          }),
          last: t.union([
            t.null,
            t.type({
              lt: t.string,
              hash: t.string
            })
          ]),
          storageStat: t.union([t.null, storageStatCodec])
        }),
        block: t.type({
          workchain: t.number,
          seqno: t.number,
          shard: t.string,
          rootHash: t.string,
          fileHash: t.string
        })
      });
      var accountLiteCodec = t.type({
        account: t.type({
          state: t.union([
            t.type({ type: t.literal("uninit") }),
            t.type({ type: t.literal("active"), codeHash: t.string, dataHash: t.string }),
            t.type({ type: t.literal("frozen"), stateHash: t.string })
          ]),
          balance: t.type({
            coins: t.string
          }),
          last: t.union([
            t.null,
            t.type({
              lt: t.string,
              hash: t.string
            })
          ]),
          storageStat: t.union([t.null, storageStatCodec])
        })
      });
      var changedCodec = t.type({
        changed: t.boolean,
        block: t.type({
          workchain: t.number,
          seqno: t.number,
          shard: t.string,
          rootHash: t.string,
          fileHash: t.string
        })
      });
      var runMethodCodec = t.type({
        exitCode: t.number,
        resultRaw: t.union([t.string, t.null]),
        block: t.type({
          workchain: t.number,
          seqno: t.number,
          shard: t.string,
          rootHash: t.string,
          fileHash: t.string
        }),
        shardBlock: t.type({
          workchain: t.number,
          seqno: t.number,
          shard: t.string,
          rootHash: t.string,
          fileHash: t.string
        })
      });
      var configCodec = t.type({
        config: t.type({
          cell: t.string,
          address: t.string,
          globalBalance: t.type({
            coins: t.string
          })
        })
      });
      var sendCodec = t.type({
        status: t.number
      });
      var transactionsCodec = t.type({
        blocks: t.array(t.type({
          workchain: t.number,
          seqno: t.number,
          shard: t.string,
          rootHash: t.string,
          fileHash: t.string
        })),
        boc: t.string
      });
      var transactionCodec = t.type({
        block: t.type({
          workchain: t.number,
          seqno: t.number,
          shard: t.string,
          rootHash: t.string
        }),
        boc: t.string,
        proof: t.string
      });
    }
  });

  // node_modules/ton/dist/wallets/signing/createWalletTransfer.js
  var require_createWalletTransfer = __commonJS({
    "node_modules/ton/dist/wallets/signing/createWalletTransfer.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createWalletTransferV4 = exports.createWalletTransferV3 = exports.createWalletTransferV2 = exports.createWalletTransferV1 = void 0;
      var ton_core_1 = require_dist2();
      var ton_crypto_1 = require_dist();
      function createWalletTransferV1(args) {
        let signingMessage = (0, ton_core_1.beginCell)().storeUint(args.seqno, 32);
        if (args.message) {
          signingMessage.storeUint(args.sendMode, 8);
          signingMessage.storeRef((0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessageRelaxed)(args.message)));
        }
        let signature = (0, ton_crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
        const body = (0, ton_core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
        return body;
      }
      exports.createWalletTransferV1 = createWalletTransferV1;
      function createWalletTransferV2(args) {
        if (args.messages.length > 4) {
          throw new Error("Maximum number of messages in a single transfer is 4");
        }
        let signingMessage = (0, ton_core_1.beginCell)().storeUint(args.seqno, 32);
        if (args.seqno === 0) {
          for (let i = 0; i < 32; i++) {
            signingMessage.storeBit(1);
          }
        } else {
          signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
        }
        for (let m of args.messages) {
          signingMessage.storeUint(args.sendMode, 8);
          signingMessage.storeRef((0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessageRelaxed)(m)));
        }
        let signature = (0, ton_crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
        const body = (0, ton_core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
        return body;
      }
      exports.createWalletTransferV2 = createWalletTransferV2;
      function createWalletTransferV3(args) {
        if (args.messages.length > 4) {
          throw new Error("Maximum number of messages in a single transfer is 4");
        }
        let signingMessage = (0, ton_core_1.beginCell)().storeUint(args.walletId, 32);
        if (args.seqno === 0) {
          for (let i = 0; i < 32; i++) {
            signingMessage.storeBit(1);
          }
        } else {
          signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
        }
        signingMessage.storeUint(args.seqno, 32);
        for (let m of args.messages) {
          signingMessage.storeUint(args.sendMode, 8);
          signingMessage.storeRef((0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessageRelaxed)(m)));
        }
        let signature = (0, ton_crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
        const body = (0, ton_core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
        return body;
      }
      exports.createWalletTransferV3 = createWalletTransferV3;
      function createWalletTransferV4(args) {
        if (args.messages.length > 4) {
          throw new Error("Maximum number of messages in a single transfer is 4");
        }
        let signingMessage = (0, ton_core_1.beginCell)().storeUint(args.walletId, 32);
        if (args.seqno === 0) {
          for (let i = 0; i < 32; i++) {
            signingMessage.storeBit(1);
          }
        } else {
          signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
        }
        signingMessage.storeUint(args.seqno, 32);
        signingMessage.storeUint(0, 8);
        for (let m of args.messages) {
          signingMessage.storeUint(args.sendMode, 8);
          signingMessage.storeRef((0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessageRelaxed)(m)));
        }
        let signature = (0, ton_crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
        const body = (0, ton_core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
        return body;
      }
      exports.createWalletTransferV4 = createWalletTransferV4;
    }
  });

  // node_modules/ton/dist/wallets/WalletContractV1R1.js
  var require_WalletContractV1R1 = __commonJS({
    "node_modules/ton/dist/wallets/WalletContractV1R1.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletContractV1R1 = void 0;
      var ton_core_1 = require_dist2();
      var createWalletTransfer_1 = require_createWalletTransfer();
      var WalletContractV1R1 = class {
        constructor(workchain, publicKey) {
          this.workchain = workchain;
          this.publicKey = publicKey;
          let code = ton_core_1.Cell.fromBoc(Buffer2.from("te6cckEBAQEARAAAhP8AIN2k8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVEH98Ik=", "base64"))[0];
          let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
          this.init = { code, data };
          this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
        }
        static create(args) {
          return new WalletContractV1R1(args.workchain, args.publicKey);
        }
        /**
         * Get Wallet Balance
         */
        async getBalance(provider) {
          let state = await provider.getState();
          return state.balance;
        }
        /**
         * Get Wallet Seqno
         */
        async getSeqno(provider) {
          let state = await provider.getState();
          if (state.state.type === "active") {
            return ton_core_1.Cell.fromBoc(state.state.data)[0].beginParse().loadUint(32);
          } else {
            return 0;
          }
        }
        /**
         * Send signed transfer
         */
        async send(provider, message) {
          await provider.external(message);
        }
        /**
         * Sign and send transfer
         */
        async sendTransfer(provider, args) {
          let transfer = this.createTransfer(args);
          await this.send(provider, transfer);
        }
        /**
         * Create signed transfer
         */
        createTransfer(args) {
          let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATLY;
          if (args.sendMode !== null && args.sendMode !== void 0) {
            sendMode = args.sendMode;
          }
          return (0, createWalletTransfer_1.createWalletTransferV1)({
            seqno: args.seqno,
            sendMode,
            secretKey: args.secretKey,
            message: args.message
          });
        }
        /**
         * Create sender
         */
        sender(provider, secretKey) {
          return {
            send: async (args) => {
              let seqno = await this.getSeqno(provider);
              let transfer = this.createTransfer({
                seqno,
                secretKey,
                sendMode: args.sendMode,
                message: (0, ton_core_1.internal)({
                  to: args.to,
                  value: args.value,
                  init: args.init,
                  body: args.body,
                  bounce: args.bounce
                })
              });
              await this.send(provider, transfer);
            }
          };
        }
      };
      exports.WalletContractV1R1 = WalletContractV1R1;
    }
  });

  // node_modules/ton/dist/wallets/WalletContractV1R2.js
  var require_WalletContractV1R2 = __commonJS({
    "node_modules/ton/dist/wallets/WalletContractV1R2.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletContractV1R2 = void 0;
      var ton_core_1 = require_dist2();
      var createWalletTransfer_1 = require_createWalletTransfer();
      var WalletContractV1R2 = class {
        constructor(workchain, publicKey) {
          this.workchain = workchain;
          this.publicKey = publicKey;
          let code = ton_core_1.Cell.fromBoc(Buffer2.from("te6cckEBAQEAUwAAov8AIN0gggFMl7qXMO1E0NcLH+Ck8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVNDieG8=", "base64"))[0];
          let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
          this.init = { code, data };
          this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
        }
        static create(args) {
          return new WalletContractV1R2(args.workchain, args.publicKey);
        }
        /**
         * Get Wallet Balance
         */
        async getBalance(provider) {
          let state = await provider.getState();
          return state.balance;
        }
        /**
         * Get Wallet Seqno
         */
        async getSeqno(provider) {
          let state = await provider.getState();
          if (state.state.type === "active") {
            let res = await provider.get("seqno", []);
            return res.stack.readNumber();
          } else {
            return 0;
          }
        }
        /**
         * Send signed transfer
         */
        async send(provider, message) {
          await provider.external(message);
        }
        /**
         * Sign and send transfer
         */
        async sendTransfer(provider, args) {
          let transfer = this.createTransfer(args);
          await this.send(provider, transfer);
        }
        /**
         * Create signed transfer
         */
        createTransfer(args) {
          let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATLY;
          if (args.sendMode !== null && args.sendMode !== void 0) {
            sendMode = args.sendMode;
          }
          return (0, createWalletTransfer_1.createWalletTransferV1)({
            seqno: args.seqno,
            sendMode,
            secretKey: args.secretKey,
            message: args.message
          });
        }
        /**
         * Create sender
         */
        sender(provider, secretKey) {
          return {
            send: async (args) => {
              let seqno = await this.getSeqno(provider);
              let transfer = this.createTransfer({
                seqno,
                secretKey,
                sendMode: args.sendMode,
                message: (0, ton_core_1.internal)({
                  to: args.to,
                  value: args.value,
                  init: args.init,
                  body: args.body,
                  bounce: args.bounce
                })
              });
              await this.send(provider, transfer);
            }
          };
        }
      };
      exports.WalletContractV1R2 = WalletContractV1R2;
    }
  });

  // node_modules/ton/dist/wallets/WalletContractV1R3.js
  var require_WalletContractV1R3 = __commonJS({
    "node_modules/ton/dist/wallets/WalletContractV1R3.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletContractV1R3 = void 0;
      var ton_core_1 = require_dist2();
      var createWalletTransfer_1 = require_createWalletTransfer();
      var WalletContractV1R3 = class {
        constructor(workchain, publicKey) {
          this.workchain = workchain;
          this.publicKey = publicKey;
          let code = ton_core_1.Cell.fromBoc(Buffer2.from("te6cckEBAQEAXwAAuv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVLW4bkI=", "base64"))[0];
          let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
          this.init = { code, data };
          this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
        }
        static create(args) {
          return new WalletContractV1R3(args.workchain, args.publicKey);
        }
        /**
         * Get Wallet Balance
         */
        async getBalance(provider) {
          let state = await provider.getState();
          return state.balance;
        }
        /**
         * Get Wallet Seqno
         */
        async getSeqno(provider) {
          let state = await provider.getState();
          if (state.state.type === "active") {
            let res = await provider.get("seqno", []);
            return res.stack.readNumber();
          } else {
            return 0;
          }
        }
        /**
         * Send signed transfer
         */
        async send(executor, message) {
          await executor.external(message);
        }
        /**
         * Sign and send transfer
         */
        async sendTransfer(provider, args) {
          let transfer = this.createTransfer(args);
          await this.send(provider, transfer);
        }
        /**
         * Create signed transfer
         */
        createTransfer(args) {
          let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATLY;
          if (args.sendMode !== null && args.sendMode !== void 0) {
            sendMode = args.sendMode;
          }
          return (0, createWalletTransfer_1.createWalletTransferV1)({
            seqno: args.seqno,
            sendMode,
            secretKey: args.secretKey,
            message: args.message
          });
        }
        /**
         * Create sender
         */
        sender(provider, secretKey) {
          return {
            send: async (args) => {
              let seqno = await this.getSeqno(provider);
              let transfer = this.createTransfer({
                seqno,
                secretKey,
                sendMode: args.sendMode,
                message: (0, ton_core_1.internal)({
                  to: args.to,
                  value: args.value,
                  init: args.init,
                  body: args.body,
                  bounce: args.bounce
                })
              });
              await this.send(provider, transfer);
            }
          };
        }
      };
      exports.WalletContractV1R3 = WalletContractV1R3;
    }
  });

  // node_modules/ton/dist/wallets/WalletContractV2R1.js
  var require_WalletContractV2R1 = __commonJS({
    "node_modules/ton/dist/wallets/WalletContractV2R1.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletContractV2R1 = void 0;
      var ton_core_1 = require_dist2();
      var createWalletTransfer_1 = require_createWalletTransfer();
      var WalletContractV2R1 = class {
        constructor(workchain, publicKey) {
          this.workchain = workchain;
          this.publicKey = publicKey;
          let code = ton_core_1.Cell.fromBoc(Buffer2.from("te6cckEBAQEAVwAAqv8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VShNwu2", "base64"))[0];
          let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
          this.init = { code, data };
          this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
        }
        static create(args) {
          return new WalletContractV2R1(args.workchain, args.publicKey);
        }
        /**
         * Get Wallet Balance
         */
        async getBalance(provider) {
          let state = await provider.getState();
          return state.balance;
        }
        /**
         * Get Wallet Seqno
         */
        async getSeqno(provider) {
          let state = await provider.getState();
          if (state.state.type === "active") {
            let res = await provider.get("seqno", []);
            return res.stack.readNumber();
          } else {
            return 0;
          }
        }
        /**
         * Send signed transfer
         */
        async send(provider, message) {
          await provider.external(message);
        }
        /**
         * Sign and send transfer
         */
        async sendTransfer(provider, args) {
          let transfer = this.createTransfer(args);
          await this.send(provider, transfer);
        }
        /**
         * Create signed transfer
         */
        createTransfer(args) {
          let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATLY;
          if (args.sendMode !== null && args.sendMode !== void 0) {
            sendMode = args.sendMode;
          }
          return (0, createWalletTransfer_1.createWalletTransferV2)({
            seqno: args.seqno,
            sendMode,
            secretKey: args.secretKey,
            messages: args.messages,
            timeout: args.timeout
          });
        }
        /**
         * Create sender
         */
        sender(provider, secretKey) {
          return {
            send: async (args) => {
              let seqno = await this.getSeqno(provider);
              let transfer = this.createTransfer({
                seqno,
                secretKey,
                sendMode: args.sendMode,
                messages: [(0, ton_core_1.internal)({
                  to: args.to,
                  value: args.value,
                  init: args.init,
                  body: args.body,
                  bounce: args.bounce
                })]
              });
              await this.send(provider, transfer);
            }
          };
        }
      };
      exports.WalletContractV2R1 = WalletContractV2R1;
    }
  });

  // node_modules/ton/dist/wallets/WalletContractV2R2.js
  var require_WalletContractV2R2 = __commonJS({
    "node_modules/ton/dist/wallets/WalletContractV2R2.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletContractV2R2 = void 0;
      var ton_core_1 = require_dist2();
      var createWalletTransfer_1 = require_createWalletTransfer();
      var WalletContractV2R2 = class {
        constructor(workchain, publicKey) {
          this.workchain = workchain;
          this.publicKey = publicKey;
          let code = ton_core_1.Cell.fromBoc(Buffer2.from("te6cckEBAQEAYwAAwv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VQETNeh", "base64"))[0];
          let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
          this.init = { code, data };
          this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
        }
        static create(args) {
          return new WalletContractV2R2(args.workchain, args.publicKey);
        }
        /**
         * Get Wallet Balance
         */
        async getBalance(provider) {
          let state = await provider.getState();
          return state.balance;
        }
        /**
         * Get Wallet Seqno
         */
        async getSeqno(provider) {
          let state = await provider.getState();
          if (state.state.type === "active") {
            let res = await provider.get("seqno", []);
            return res.stack.readNumber();
          } else {
            return 0;
          }
        }
        /**
         * Send signed transfer
         */
        async send(provider, message) {
          await provider.external(message);
        }
        /**
         * Sign and send transfer
         */
        async sendTransfer(provider, args) {
          let transfer = this.createTransfer(args);
          await this.send(provider, transfer);
        }
        /**
         * Create signed transfer
         */
        createTransfer(args) {
          let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATLY;
          if (args.sendMode !== null && args.sendMode !== void 0) {
            sendMode = args.sendMode;
          }
          return (0, createWalletTransfer_1.createWalletTransferV2)({
            seqno: args.seqno,
            sendMode,
            secretKey: args.secretKey,
            messages: args.messages,
            timeout: args.timeout
          });
        }
        /**
         * Create sender
         */
        sender(provider, secretKey) {
          return {
            send: async (args) => {
              let seqno = await this.getSeqno(provider);
              let transfer = this.createTransfer({
                seqno,
                secretKey,
                sendMode: args.sendMode,
                messages: [(0, ton_core_1.internal)({
                  to: args.to,
                  value: args.value,
                  init: args.init,
                  body: args.body,
                  bounce: args.bounce
                })]
              });
              await this.send(provider, transfer);
            }
          };
        }
      };
      exports.WalletContractV2R2 = WalletContractV2R2;
    }
  });

  // node_modules/ton/dist/wallets/WalletContractV3R1.js
  var require_WalletContractV3R1 = __commonJS({
    "node_modules/ton/dist/wallets/WalletContractV3R1.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletContractV3R1 = void 0;
      var ton_core_1 = require_dist2();
      var createWalletTransfer_1 = require_createWalletTransfer();
      var WalletContractV3R1 = class {
        constructor(workchain, publicKey, walletId) {
          this.workchain = workchain;
          this.publicKey = publicKey;
          if (walletId !== null && walletId !== void 0) {
            this.walletId = walletId;
          } else {
            this.walletId = 698983191 + workchain;
          }
          let code = ton_core_1.Cell.fromBoc(Buffer2.from("te6cckEBAQEAYgAAwP8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVD++buA=", "base64"))[0];
          let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(publicKey).endCell();
          this.init = { code, data };
          this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
        }
        static create(args) {
          return new WalletContractV3R1(args.workchain, args.publicKey, args.walletId);
        }
        /**
         * Get wallet balance
         */
        async getBalance(provider) {
          let state = await provider.getState();
          return state.balance;
        }
        /**
         * Get Wallet Seqno
         */
        async getSeqno(provider) {
          let state = await provider.getState();
          if (state.state.type === "active") {
            let res = await provider.get("seqno", []);
            return res.stack.readNumber();
          } else {
            return 0;
          }
        }
        /**
         * Send signed transfer
         */
        async send(provider, message) {
          await provider.external(message);
        }
        /**
         * Sign and send transfer
         */
        async sendTransfer(provider, args) {
          let transfer = this.createTransfer(args);
          await this.send(provider, transfer);
        }
        /**
         * Create transfer
         */
        createTransfer(args) {
          let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATLY;
          if (args.sendMode !== null && args.sendMode !== void 0) {
            sendMode = args.sendMode;
          }
          return (0, createWalletTransfer_1.createWalletTransferV3)({
            seqno: args.seqno,
            sendMode,
            secretKey: args.secretKey,
            messages: args.messages,
            timeout: args.timeout,
            walletId: this.walletId
          });
        }
        /**
         * Create sender
         */
        sender(provider, secretKey) {
          return {
            send: async (args) => {
              let seqno = await this.getSeqno(provider);
              let transfer = this.createTransfer({
                seqno,
                secretKey,
                sendMode: args.sendMode,
                messages: [(0, ton_core_1.internal)({
                  to: args.to,
                  value: args.value,
                  init: args.init,
                  body: args.body,
                  bounce: args.bounce
                })]
              });
              await this.send(provider, transfer);
            }
          };
        }
      };
      exports.WalletContractV3R1 = WalletContractV3R1;
    }
  });

  // node_modules/ton/dist/wallets/WalletContractV3R2.js
  var require_WalletContractV3R2 = __commonJS({
    "node_modules/ton/dist/wallets/WalletContractV3R2.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletContractV3R2 = void 0;
      var ton_core_1 = require_dist2();
      var createWalletTransfer_1 = require_createWalletTransfer();
      var WalletContractV3R2 = class {
        constructor(workchain, publicKey, walletId) {
          this.workchain = workchain;
          this.publicKey = publicKey;
          if (walletId !== null && walletId !== void 0) {
            this.walletId = walletId;
          } else {
            this.walletId = 698983191 + workchain;
          }
          let code = ton_core_1.Cell.fromBoc(Buffer2.from("te6cckEBAQEAcQAA3v8AIN0gggFMl7ohggEznLqxn3Gw7UTQ0x/THzHXC//jBOCk8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVBC9ba0=", "base64"))[0];
          let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(publicKey).endCell();
          this.init = { code, data };
          this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
        }
        static create(args) {
          return new WalletContractV3R2(args.workchain, args.publicKey, args.walletId);
        }
        /**
         * Get wallet balance
         */
        async getBalance(provider) {
          let state = await provider.getState();
          return state.balance;
        }
        /**
         * Get Wallet Seqno
         */
        async getSeqno(provider) {
          let state = await provider.getState();
          if (state.state.type === "active") {
            let res = await provider.get("seqno", []);
            return res.stack.readNumber();
          } else {
            return 0;
          }
        }
        /**
         * Send signed transfer
         */
        async send(provider, message) {
          await provider.external(message);
        }
        /**
         * Sign and send transfer
         */
        async sendTransfer(provider, args) {
          let transfer = this.createTransfer(args);
          await this.send(provider, transfer);
        }
        /**
         * Create transfer
         */
        createTransfer(args) {
          let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATLY;
          if (args.sendMode !== null && args.sendMode !== void 0) {
            sendMode = args.sendMode;
          }
          return (0, createWalletTransfer_1.createWalletTransferV3)({
            seqno: args.seqno,
            sendMode,
            secretKey: args.secretKey,
            messages: args.messages,
            timeout: args.timeout,
            walletId: this.walletId
          });
        }
        /**
         * Create sender
         */
        sender(provider, secretKey) {
          return {
            send: async (args) => {
              let seqno = await this.getSeqno(provider);
              let transfer = this.createTransfer({
                seqno,
                secretKey,
                sendMode: args.sendMode,
                messages: [(0, ton_core_1.internal)({
                  to: args.to,
                  value: args.value,
                  init: args.init,
                  body: args.body,
                  bounce: args.bounce
                })]
              });
              await this.send(provider, transfer);
            }
          };
        }
      };
      exports.WalletContractV3R2 = WalletContractV3R2;
    }
  });

  // node_modules/ton/dist/wallets/WalletContractV4.js
  var require_WalletContractV4 = __commonJS({
    "node_modules/ton/dist/wallets/WalletContractV4.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WalletContractV4 = void 0;
      var ton_core_1 = require_dist2();
      var createWalletTransfer_1 = require_createWalletTransfer();
      var WalletContractV4 = class {
        constructor(workchain, publicKey, walletId) {
          this.workchain = workchain;
          this.publicKey = publicKey;
          if (walletId !== null && walletId !== void 0) {
            this.walletId = walletId;
          } else {
            this.walletId = 698983191 + workchain;
          }
          let code = ton_core_1.Cell.fromBoc(Buffer2.from("te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA==", "base64"))[0];
          let data = (0, ton_core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(this.publicKey).storeBit(0).endCell();
          this.init = { code, data };
          this.address = (0, ton_core_1.contractAddress)(workchain, { code, data });
        }
        static create(args) {
          return new WalletContractV4(args.workchain, args.publicKey, args.walletId);
        }
        /**
         * Get Wallet Balance
         */
        async getBalance(provider) {
          let state = await provider.getState();
          return state.balance;
        }
        /**
         * Get Wallet Seqno
         */
        async getSeqno(provider) {
          let state = await provider.getState();
          if (state.state.type === "active") {
            let res = await provider.get("seqno", []);
            return res.stack.readNumber();
          } else {
            return 0;
          }
        }
        /**
         * Send signed transfer
         */
        async send(provider, message) {
          await provider.external(message);
        }
        /**
         * Sign and send transfer
         */
        async sendTransfer(provider, args) {
          let transfer = this.createTransfer(args);
          await this.send(provider, transfer);
        }
        /**
         * Create signed transfer
         */
        createTransfer(args) {
          let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATLY;
          if (args.sendMode !== null && args.sendMode !== void 0) {
            sendMode = args.sendMode;
          }
          return (0, createWalletTransfer_1.createWalletTransferV4)({
            seqno: args.seqno,
            sendMode,
            secretKey: args.secretKey,
            messages: args.messages,
            timeout: args.timeout,
            walletId: this.walletId
          });
        }
        /**
         * Create sender
         */
        sender(provider, secretKey) {
          return {
            send: async (args) => {
              let seqno = await this.getSeqno(provider);
              let transfer = this.createTransfer({
                seqno,
                secretKey,
                sendMode: args.sendMode,
                messages: [(0, ton_core_1.internal)({
                  to: args.to,
                  value: args.value,
                  init: args.init,
                  body: args.body,
                  bounce: args.bounce
                })]
              });
              await this.send(provider, transfer);
            }
          };
        }
      };
      exports.WalletContractV4 = WalletContractV4;
    }
  });

  // node_modules/ton/dist/jetton/JettonMaster.js
  var require_JettonMaster = __commonJS({
    "node_modules/ton/dist/jetton/JettonMaster.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JettonMaster = void 0;
      var ton_core_1 = require_dist2();
      var JettonMaster = class {
        constructor(address) {
          this.address = address;
        }
        static create(address) {
          return new JettonMaster(address);
        }
        async getWalletAddress(provider, owner) {
          let res = await provider.get("get_wallet_address", [{ type: "slice", cell: (0, ton_core_1.beginCell)().storeAddress(owner).endCell() }]);
          return res.stack.readAddress();
        }
        async getJettonData(provider) {
          let res = await provider.get("get_jetton_data", []);
          let totalSupply = res.stack.readBigNumber();
          let mintable = res.stack.readBoolean();
          let adminAddress = res.stack.readAddress();
          let content = res.stack.readCell();
          let walletCode = res.stack.readCell();
          return {
            totalSupply,
            mintable,
            adminAddress,
            content,
            walletCode
          };
        }
      };
      exports.JettonMaster = JettonMaster;
    }
  });

  // node_modules/ton/dist/jetton/JettonWallet.js
  var require_JettonWallet = __commonJS({
    "node_modules/ton/dist/jetton/JettonWallet.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JettonWallet = void 0;
      var JettonWallet = class {
        constructor(address) {
          this.address = address;
        }
        static create(address) {
          return new JettonWallet(address);
        }
        async getBalance(provider) {
          let state = await provider.getState();
          if (state.state.type !== "active") {
            return 0n;
          }
          let res = await provider.get("get_wallet_data", []);
          return res.stack.readBigNumber();
        }
      };
      exports.JettonWallet = JettonWallet;
    }
  });

  // node_modules/ton/dist/index.js
  var require_dist3 = __commonJS({
    "node_modules/ton/dist/index.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding2(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JettonWallet = exports.JettonMaster = exports.WalletContractV4 = exports.WalletContractV3R2 = exports.WalletContractV3R1 = exports.WalletContractV2R2 = exports.WalletContractV2R1 = exports.WalletContractV1R3 = exports.WalletContractV1R2 = exports.WalletContractV1R1 = exports.TonClient4 = exports.TonClient = exports.HttpApi = void 0;
      __exportStar2(require_dist2(), exports);
      var HttpApi_1 = require_HttpApi();
      Object.defineProperty(exports, "HttpApi", { enumerable: true, get: function() {
        return HttpApi_1.HttpApi;
      } });
      var TonClient_1 = require_TonClient();
      Object.defineProperty(exports, "TonClient", { enumerable: true, get: function() {
        return TonClient_1.TonClient;
      } });
      var TonClient4_1 = require_TonClient4();
      Object.defineProperty(exports, "TonClient4", { enumerable: true, get: function() {
        return TonClient4_1.TonClient4;
      } });
      var WalletContractV1R1_1 = require_WalletContractV1R1();
      Object.defineProperty(exports, "WalletContractV1R1", { enumerable: true, get: function() {
        return WalletContractV1R1_1.WalletContractV1R1;
      } });
      var WalletContractV1R2_1 = require_WalletContractV1R2();
      Object.defineProperty(exports, "WalletContractV1R2", { enumerable: true, get: function() {
        return WalletContractV1R2_1.WalletContractV1R2;
      } });
      var WalletContractV1R3_1 = require_WalletContractV1R3();
      Object.defineProperty(exports, "WalletContractV1R3", { enumerable: true, get: function() {
        return WalletContractV1R3_1.WalletContractV1R3;
      } });
      var WalletContractV2R1_1 = require_WalletContractV2R1();
      Object.defineProperty(exports, "WalletContractV2R1", { enumerable: true, get: function() {
        return WalletContractV2R1_1.WalletContractV2R1;
      } });
      var WalletContractV2R2_1 = require_WalletContractV2R2();
      Object.defineProperty(exports, "WalletContractV2R2", { enumerable: true, get: function() {
        return WalletContractV2R2_1.WalletContractV2R2;
      } });
      var WalletContractV3R1_1 = require_WalletContractV3R1();
      Object.defineProperty(exports, "WalletContractV3R1", { enumerable: true, get: function() {
        return WalletContractV3R1_1.WalletContractV3R1;
      } });
      var WalletContractV3R2_1 = require_WalletContractV3R2();
      Object.defineProperty(exports, "WalletContractV3R2", { enumerable: true, get: function() {
        return WalletContractV3R2_1.WalletContractV3R2;
      } });
      var WalletContractV4_1 = require_WalletContractV4();
      Object.defineProperty(exports, "WalletContractV4", { enumerable: true, get: function() {
        return WalletContractV4_1.WalletContractV4;
      } });
      var JettonMaster_1 = require_JettonMaster();
      Object.defineProperty(exports, "JettonMaster", { enumerable: true, get: function() {
        return JettonMaster_1.JettonMaster;
      } });
      var JettonWallet_1 = require_JettonWallet();
      Object.defineProperty(exports, "JettonWallet", { enumerable: true, get: function() {
        return JettonWallet_1.JettonWallet;
      } });
    }
  });

  // node_modules/whatwg-fetch/dist/fetch.umd.js
  var require_fetch_umd = __commonJS({
    "node_modules/whatwg-fetch/dist/fetch.umd.js"(exports, module) {
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.WHATWGFetch = {});
      })(exports, function(exports2) {
        "use strict";
        var global2 = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global2 !== "undefined" && global2;
        var support = {
          searchParams: "URLSearchParams" in global2,
          iterable: "Symbol" in global2 && "iterator" in Symbol,
          blob: "FileReader" in global2 && "Blob" in global2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in global2,
          arrayBuffer: "ArrayBuffer" in global2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                var isConsumed = consumed(this);
                if (isConsumed) {
                  return isConsumed;
                }
                if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                  return Promise.resolve(
                    this._bodyArrayBuffer.buffer.slice(
                      this._bodyArrayBuffer.byteOffset,
                      this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                    )
                  );
                } else {
                  return Promise.resolve(this._bodyArrayBuffer);
                }
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = global2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init2) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init2);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && global2.location.href ? global2.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers)) {
              Object.getOwnPropertyNames(init2.headers).forEach(function(name) {
                xhr.setRequestHeader(name, normalizeValue(init2.headers[name]));
              });
            } else {
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!global2.fetch) {
          global2.fetch = fetch2;
          global2.Headers = Headers;
          global2.Request = Request;
          global2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/isomorphic-fetch/fetch-npm-browserify.js
  var require_fetch_npm_browserify = __commonJS({
    "node_modules/isomorphic-fetch/fetch-npm-browserify.js"(exports, module) {
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      require_fetch_umd();
      module.exports = self.fetch.bind(self);
    }
  });

  // node_modules/@orbs-network/ton-access/lib/nodes.js
  var require_nodes = __commonJS({
    "node_modules/@orbs-network/ton-access/lib/nodes.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Nodes = void 0;
      require_fetch_npm_browserify();
      var Nodes = class {
        ///////////////////////////////////
        constructor() {
          this.nodeIndex = -1;
          this.committee = /* @__PURE__ */ new Set();
          this.topology = [];
        }
        ///////////////////////////////////
        init(nodesUrl) {
          return __awaiter2(this, void 0, void 0, function* () {
            this.nodeIndex = -1;
            this.committee.clear();
            this.topology = [];
            let topology = [];
            try {
              const response = yield fetch(nodesUrl);
              const data = yield response.json();
              topology = data;
            } catch (e) {
              throw new Error(`exception in fetch(${nodesUrl}): ${e}`);
            }
            for (const node of topology) {
              if (node.Healthy === "1") {
                this.topology.push(node);
              }
            }
            if (this.topology.length === 0)
              throw new Error(`no healthy nodes retrieved`);
          });
        }
        ///////////////////////////////////
        getNextNode(committeeOnly = true) {
          while (true) {
            this.nodeIndex++;
            if (this.nodeIndex >= this.topology.length)
              this.nodeIndex = 0;
            return this.topology[this.nodeIndex];
          }
        }
        ///////////////////////////////////
        getRandomNode(committeeOnly = true) {
          const index = Math.floor(Math.random() * this.topology.length);
          return this.topology[index];
        }
      };
      exports.Nodes = Nodes;
    }
  });

  // node_modules/@orbs-network/ton-access/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/@orbs-network/ton-access/lib/index.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getHttpV4Endpoint = exports.getHttpV4Endpoints = exports.getHttpEndpoint = exports.getHttpEndpoints = exports.Access = void 0;
      var nodes_1 = require_nodes();
      var Access = class {
        //////////////////////////////////
        constructor() {
          this.host = "ton.access.orbs.network";
          this.urlVersion = 1;
          this.nodes = new nodes_1.Nodes();
        }
        //////////////////////////////////
        init() {
          return __awaiter2(this, void 0, void 0, function* () {
            yield this.nodes.init(`https://${this.host}/nodes`);
          });
        }
        //////////////////////////////////
        buildUrls(network, edgeProtocol, suffix) {
          if (!suffix)
            suffix = "";
          if (suffix.length)
            suffix = suffix.replace(/^\/+/, "");
          const res = [];
          const len = this.nodes.topology.length;
          for (let i = 0; i < len; ++i) {
            const node = this.nodes.getNextNode();
            const url = `https://${this.host}/${node.Name}/${this.urlVersion}/${network}/${edgeProtocol}/${suffix}`;
            res.push(url);
          }
          return res;
        }
      };
      exports.Access = Access;
      function getEndpoints(network, edgeProtocol, suffix) {
        return __awaiter2(this, void 0, void 0, function* () {
          const access = new Access();
          yield access.init();
          const res = access.buildUrls(network, edgeProtocol, suffix);
          return res;
        });
      }
      function getHttpEndpoints(config2) {
        return __awaiter2(this, void 0, void 0, function* () {
          const network = (config2 === null || config2 === void 0 ? void 0 : config2.network) ? config2.network : "mainnet";
          let suffix = "jsonRPC";
          if ((config2 === null || config2 === void 0 ? void 0 : config2.protocol) === "rest") {
            suffix = "";
          }
          return yield getEndpoints(network, "toncenter-api-v2", suffix);
        });
      }
      exports.getHttpEndpoints = getHttpEndpoints;
      function getHttpEndpoint2(config2) {
        return __awaiter2(this, void 0, void 0, function* () {
          const endpoints = yield getHttpEndpoints(config2);
          const index = Math.floor(Math.random() * endpoints.length);
          return endpoints[index];
        });
      }
      exports.getHttpEndpoint = getHttpEndpoint2;
      function getHttpV4Endpoints(config2) {
        return __awaiter2(this, void 0, void 0, function* () {
          const network = (config2 === null || config2 === void 0 ? void 0 : config2.network) ? config2.network : "mainnet";
          if ((config2 === null || config2 === void 0 ? void 0 : config2.protocol) === "json-rpc") {
            throw Error("config.protocol json-rpc is not supported for getTonApiV4Endpoints");
          }
          const suffix = "";
          return yield getEndpoints(network, "ton-api-v4", suffix);
        });
      }
      exports.getHttpV4Endpoints = getHttpV4Endpoints;
      function getHttpV4Endpoint(config2) {
        return __awaiter2(this, void 0, void 0, function* () {
          const endpoints = yield getHttpV4Endpoints(config2);
          const index = Math.floor(Math.random() * endpoints.length);
          return endpoints[index];
        });
      }
      exports.getHttpV4Endpoint = getHttpV4Endpoint;
    }
  });

  // node_modules/@aws-crypto/sha256-js/node_modules/tslib/tslib.es6.js
  var tslib_es6_exports = {};
  __export(tslib_es6_exports, {
    __assign: () => __assign,
    __asyncDelegator: () => __asyncDelegator,
    __asyncGenerator: () => __asyncGenerator,
    __asyncValues: () => __asyncValues,
    __await: () => __await,
    __awaiter: () => __awaiter,
    __classPrivateFieldGet: () => __classPrivateFieldGet,
    __classPrivateFieldSet: () => __classPrivateFieldSet,
    __createBinding: () => __createBinding,
    __decorate: () => __decorate,
    __exportStar: () => __exportStar,
    __extends: () => __extends,
    __generator: () => __generator,
    __importDefault: () => __importDefault,
    __importStar: () => __importStar,
    __makeTemplateObject: () => __makeTemplateObject,
    __metadata: () => __metadata,
    __param: () => __param,
    __read: () => __read,
    __rest: () => __rest,
    __spread: () => __spread,
    __spreadArrays: () => __spreadArrays,
    __values: () => __values
  });
  function __extends(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __rest(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __createBinding(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }
  function __exportStar(m, exports) {
    for (var p in m)
      if (p !== "default" && !exports.hasOwnProperty(p))
        exports[p] = m[p];
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  }
  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++)
      s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
        r[k] = a[j];
    return r;
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
      throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
      return this;
    }, i;
    function verb(n, f) {
      i[n] = o[n] ? function(v) {
        return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", { value: raw });
    } else {
      cooked.raw = raw;
    }
    return cooked;
  }
  function __importStar(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result.default = mod;
    return result;
  }
  function __importDefault(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }
  function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
  }
  function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
  }
  var extendStatics, __assign;
  var init_tslib_es6 = __esm({
    "node_modules/@aws-crypto/sha256-js/node_modules/tslib/tslib.es6.js"() {
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      __assign = function() {
        __assign = Object.assign || function __assign2(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
    }
  });

  // node_modules/@aws-crypto/sha256-js/build/constants.js
  var require_constants = __commonJS({
    "node_modules/@aws-crypto/sha256-js/build/constants.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MAX_HASHABLE_LENGTH = exports.INIT = exports.KEY = exports.DIGEST_LENGTH = exports.BLOCK_SIZE = void 0;
      exports.BLOCK_SIZE = 64;
      exports.DIGEST_LENGTH = 32;
      exports.KEY = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      exports.INIT = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      exports.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
    }
  });

  // node_modules/@aws-crypto/sha256-js/build/RawSha256.js
  var require_RawSha256 = __commonJS({
    "node_modules/@aws-crypto/sha256-js/build/RawSha256.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RawSha256 = void 0;
      var constants_1 = require_constants();
      var RawSha256 = function() {
        function RawSha2562() {
          this.state = Int32Array.from(constants_1.INIT);
          this.temp = new Int32Array(64);
          this.buffer = new Uint8Array(64);
          this.bufferLength = 0;
          this.bytesHashed = 0;
          this.finished = false;
        }
        RawSha2562.prototype.update = function(data) {
          if (this.finished) {
            throw new Error("Attempted to update an already finished hash.");
          }
          var position = 0;
          var byteLength2 = data.byteLength;
          this.bytesHashed += byteLength2;
          if (this.bytesHashed * 8 > constants_1.MAX_HASHABLE_LENGTH) {
            throw new Error("Cannot hash more than 2^53 - 1 bits");
          }
          while (byteLength2 > 0) {
            this.buffer[this.bufferLength++] = data[position++];
            byteLength2--;
            if (this.bufferLength === constants_1.BLOCK_SIZE) {
              this.hashBuffer();
              this.bufferLength = 0;
            }
          }
        };
        RawSha2562.prototype.digest = function() {
          if (!this.finished) {
            var bitsHashed = this.bytesHashed * 8;
            var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
            var undecoratedLength = this.bufferLength;
            bufferView.setUint8(this.bufferLength++, 128);
            if (undecoratedLength % constants_1.BLOCK_SIZE >= constants_1.BLOCK_SIZE - 8) {
              for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE; i++) {
                bufferView.setUint8(i, 0);
              }
              this.hashBuffer();
              this.bufferLength = 0;
            }
            for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE - 8; i++) {
              bufferView.setUint8(i, 0);
            }
            bufferView.setUint32(constants_1.BLOCK_SIZE - 8, Math.floor(bitsHashed / 4294967296), true);
            bufferView.setUint32(constants_1.BLOCK_SIZE - 4, bitsHashed);
            this.hashBuffer();
            this.finished = true;
          }
          var out = new Uint8Array(constants_1.DIGEST_LENGTH);
          for (var i = 0; i < 8; i++) {
            out[i * 4] = this.state[i] >>> 24 & 255;
            out[i * 4 + 1] = this.state[i] >>> 16 & 255;
            out[i * 4 + 2] = this.state[i] >>> 8 & 255;
            out[i * 4 + 3] = this.state[i] >>> 0 & 255;
          }
          return out;
        };
        RawSha2562.prototype.hashBuffer = function() {
          var _a = this, buffer = _a.buffer, state = _a.state;
          var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
          for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {
            if (i < 16) {
              this.temp[i] = (buffer[i * 4] & 255) << 24 | (buffer[i * 4 + 1] & 255) << 16 | (buffer[i * 4 + 2] & 255) << 8 | buffer[i * 4 + 3] & 255;
            } else {
              var u = this.temp[i - 2];
              var t1_1 = (u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10;
              u = this.temp[i - 15];
              var t2_1 = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3;
              this.temp[i] = (t1_1 + this.temp[i - 7] | 0) + (t2_1 + this.temp[i - 16] | 0);
            }
            var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (constants_1.KEY[i] + this.temp[i] | 0) | 0) | 0;
            var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;
            state7 = state6;
            state6 = state5;
            state5 = state4;
            state4 = state3 + t1 | 0;
            state3 = state2;
            state2 = state1;
            state1 = state0;
            state0 = t1 + t2 | 0;
          }
          state[0] += state0;
          state[1] += state1;
          state[2] += state2;
          state[3] += state3;
          state[4] += state4;
          state[5] += state5;
          state[6] += state6;
          state[7] += state7;
        };
        return RawSha2562;
      }();
      exports.RawSha256 = RawSha256;
    }
  });

  // node_modules/@aws-sdk/util-utf8-browser/dist-cjs/pureJs.js
  var require_pureJs = __commonJS({
    "node_modules/@aws-sdk/util-utf8-browser/dist-cjs/pureJs.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toUtf8 = exports.fromUtf8 = void 0;
      var fromUtf8 = (input) => {
        const bytes = [];
        for (let i = 0, len = input.length; i < len; i++) {
          const value = input.charCodeAt(i);
          if (value < 128) {
            bytes.push(value);
          } else if (value < 2048) {
            bytes.push(value >> 6 | 192, value & 63 | 128);
          } else if (i + 1 < input.length && (value & 64512) === 55296 && (input.charCodeAt(i + 1) & 64512) === 56320) {
            const surrogatePair = 65536 + ((value & 1023) << 10) + (input.charCodeAt(++i) & 1023);
            bytes.push(surrogatePair >> 18 | 240, surrogatePair >> 12 & 63 | 128, surrogatePair >> 6 & 63 | 128, surrogatePair & 63 | 128);
          } else {
            bytes.push(value >> 12 | 224, value >> 6 & 63 | 128, value & 63 | 128);
          }
        }
        return Uint8Array.from(bytes);
      };
      exports.fromUtf8 = fromUtf8;
      var toUtf8 = (input) => {
        let decoded = "";
        for (let i = 0, len = input.length; i < len; i++) {
          const byte = input[i];
          if (byte < 128) {
            decoded += String.fromCharCode(byte);
          } else if (192 <= byte && byte < 224) {
            const nextByte = input[++i];
            decoded += String.fromCharCode((byte & 31) << 6 | nextByte & 63);
          } else if (240 <= byte && byte < 365) {
            const surrogatePair = [byte, input[++i], input[++i], input[++i]];
            const encoded = "%" + surrogatePair.map((byteValue) => byteValue.toString(16)).join("%");
            decoded += decodeURIComponent(encoded);
          } else {
            decoded += String.fromCharCode((byte & 15) << 12 | (input[++i] & 63) << 6 | input[++i] & 63);
          }
        }
        return decoded;
      };
      exports.toUtf8 = toUtf8;
    }
  });

  // node_modules/@aws-sdk/util-utf8-browser/dist-cjs/whatwgEncodingApi.js
  var require_whatwgEncodingApi = __commonJS({
    "node_modules/@aws-sdk/util-utf8-browser/dist-cjs/whatwgEncodingApi.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toUtf8 = exports.fromUtf8 = void 0;
      function fromUtf8(input) {
        return new TextEncoder().encode(input);
      }
      exports.fromUtf8 = fromUtf8;
      function toUtf8(input) {
        return new TextDecoder("utf-8").decode(input);
      }
      exports.toUtf8 = toUtf8;
    }
  });

  // node_modules/@aws-sdk/util-utf8-browser/dist-cjs/index.js
  var require_dist_cjs = __commonJS({
    "node_modules/@aws-sdk/util-utf8-browser/dist-cjs/index.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toUtf8 = exports.fromUtf8 = void 0;
      var pureJs_1 = require_pureJs();
      var whatwgEncodingApi_1 = require_whatwgEncodingApi();
      var fromUtf8 = (input) => typeof TextEncoder === "function" ? (0, whatwgEncodingApi_1.fromUtf8)(input) : (0, pureJs_1.fromUtf8)(input);
      exports.fromUtf8 = fromUtf8;
      var toUtf8 = (input) => typeof TextDecoder === "function" ? (0, whatwgEncodingApi_1.toUtf8)(input) : (0, pureJs_1.toUtf8)(input);
      exports.toUtf8 = toUtf8;
    }
  });

  // node_modules/@aws-crypto/util/build/convertToBuffer.js
  var require_convertToBuffer = __commonJS({
    "node_modules/@aws-crypto/util/build/convertToBuffer.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.convertToBuffer = void 0;
      var util_utf8_browser_1 = require_dist_cjs();
      var fromUtf8 = typeof Buffer2 !== "undefined" && Buffer2.from ? function(input) {
        return Buffer2.from(input, "utf8");
      } : util_utf8_browser_1.fromUtf8;
      function convertToBuffer(data) {
        if (data instanceof Uint8Array)
          return data;
        if (typeof data === "string") {
          return fromUtf8(data);
        }
        if (ArrayBuffer.isView(data)) {
          return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
        }
        return new Uint8Array(data);
      }
      exports.convertToBuffer = convertToBuffer;
    }
  });

  // node_modules/@aws-crypto/util/build/isEmptyData.js
  var require_isEmptyData = __commonJS({
    "node_modules/@aws-crypto/util/build/isEmptyData.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isEmptyData = void 0;
      function isEmptyData(data) {
        if (typeof data === "string") {
          return data.length === 0;
        }
        return data.byteLength === 0;
      }
      exports.isEmptyData = isEmptyData;
    }
  });

  // node_modules/@aws-crypto/util/build/numToUint8.js
  var require_numToUint8 = __commonJS({
    "node_modules/@aws-crypto/util/build/numToUint8.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.numToUint8 = void 0;
      function numToUint8(num) {
        return new Uint8Array([
          (num & 4278190080) >> 24,
          (num & 16711680) >> 16,
          (num & 65280) >> 8,
          num & 255
        ]);
      }
      exports.numToUint8 = numToUint8;
    }
  });

  // node_modules/@aws-crypto/util/build/uint32ArrayFrom.js
  var require_uint32ArrayFrom = __commonJS({
    "node_modules/@aws-crypto/util/build/uint32ArrayFrom.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.uint32ArrayFrom = void 0;
      function uint32ArrayFrom(a_lookUpTable) {
        if (!Uint32Array.from) {
          var return_array = new Uint32Array(a_lookUpTable.length);
          var a_index = 0;
          while (a_index < a_lookUpTable.length) {
            return_array[a_index] = a_lookUpTable[a_index];
            a_index += 1;
          }
          return return_array;
        }
        return Uint32Array.from(a_lookUpTable);
      }
      exports.uint32ArrayFrom = uint32ArrayFrom;
    }
  });

  // node_modules/@aws-crypto/util/build/index.js
  var require_build = __commonJS({
    "node_modules/@aws-crypto/util/build/index.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
      var convertToBuffer_1 = require_convertToBuffer();
      Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function() {
        return convertToBuffer_1.convertToBuffer;
      } });
      var isEmptyData_1 = require_isEmptyData();
      Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function() {
        return isEmptyData_1.isEmptyData;
      } });
      var numToUint8_1 = require_numToUint8();
      Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function() {
        return numToUint8_1.numToUint8;
      } });
      var uint32ArrayFrom_1 = require_uint32ArrayFrom();
      Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function() {
        return uint32ArrayFrom_1.uint32ArrayFrom;
      } });
    }
  });

  // node_modules/@aws-crypto/sha256-js/build/jsSha256.js
  var require_jsSha256 = __commonJS({
    "node_modules/@aws-crypto/sha256-js/build/jsSha256.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Sha256 = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var constants_1 = require_constants();
      var RawSha256_1 = require_RawSha256();
      var util_1 = require_build();
      var Sha2562 = function() {
        function Sha2563(secret) {
          this.hash = new RawSha256_1.RawSha256();
          if (secret) {
            this.outer = new RawSha256_1.RawSha256();
            var inner = bufferFromSecret(secret);
            var outer = new Uint8Array(constants_1.BLOCK_SIZE);
            outer.set(inner);
            for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {
              inner[i] ^= 54;
              outer[i] ^= 92;
            }
            this.hash.update(inner);
            this.outer.update(outer);
            for (var i = 0; i < inner.byteLength; i++) {
              inner[i] = 0;
            }
          }
        }
        Sha2563.prototype.update = function(toHash) {
          if ((0, util_1.isEmptyData)(toHash) || this.error) {
            return;
          }
          try {
            this.hash.update((0, util_1.convertToBuffer)(toHash));
          } catch (e) {
            this.error = e;
          }
        };
        Sha2563.prototype.digestSync = function() {
          if (this.error) {
            throw this.error;
          }
          if (this.outer) {
            if (!this.outer.finished) {
              this.outer.update(this.hash.digest());
            }
            return this.outer.digest();
          }
          return this.hash.digest();
        };
        Sha2563.prototype.digest = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a) {
              return [2, this.digestSync()];
            });
          });
        };
        return Sha2563;
      }();
      exports.Sha256 = Sha2562;
      function bufferFromSecret(secret) {
        var input = (0, util_1.convertToBuffer)(secret);
        if (input.byteLength > constants_1.BLOCK_SIZE) {
          var bufferHash = new RawSha256_1.RawSha256();
          bufferHash.update(input);
          input = bufferHash.digest();
        }
        var buffer = new Uint8Array(constants_1.BLOCK_SIZE);
        buffer.set(input);
        return buffer;
      }
    }
  });

  // node_modules/@aws-crypto/sha256-js/build/index.js
  var require_build2 = __commonJS({
    "node_modules/@aws-crypto/sha256-js/build/index.js"(exports) {
      "use strict";
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      tslib_1.__exportStar(require_jsSha256(), exports);
    }
  });

  // node_modules/highlight.js/lib/core.js
  var require_core = __commonJS({
    "node_modules/highlight.js/lib/core.js"(exports, module) {
      init_global();
      init_dirname();
      init_filename();
      init_buffer();
      init_process();
      var deepFreezeEs6 = { exports: {} };
      function deepFreeze(obj) {
        if (obj instanceof Map) {
          obj.clear = obj.delete = obj.set = function() {
            throw new Error("map is read-only");
          };
        } else if (obj instanceof Set) {
          obj.add = obj.clear = obj.delete = function() {
            throw new Error("set is read-only");
          };
        }
        Object.freeze(obj);
        Object.getOwnPropertyNames(obj).forEach(function(name) {
          var prop = obj[name];
          if (typeof prop == "object" && !Object.isFrozen(prop)) {
            deepFreeze(prop);
          }
        });
        return obj;
      }
      deepFreezeEs6.exports = deepFreeze;
      deepFreezeEs6.exports.default = deepFreeze;
      var Response = class {
        /**
         * @param {CompiledMode} mode
         */
        constructor(mode) {
          if (mode.data === void 0)
            mode.data = {};
          this.data = mode.data;
          this.isMatchIgnored = false;
        }
        ignoreMatch() {
          this.isMatchIgnored = true;
        }
      };
      function escapeHTML(value) {
        return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
      }
      function inherit$1(original, ...objects) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const key in original) {
          result[key] = original[key];
        }
        objects.forEach(function(obj) {
          for (const key in obj) {
            result[key] = obj[key];
          }
        });
        return result;
      }
      var SPAN_CLOSE = "</span>";
      var emitsWrappingTags = (node) => {
        return !!node.scope || node.sublanguage && node.language;
      };
      var scopeToCSSClass = (name, { prefix }) => {
        if (name.includes(".")) {
          const pieces = name.split(".");
          return [
            `${prefix}${pieces.shift()}`,
            ...pieces.map((x, i) => `${x}${"_".repeat(i + 1)}`)
          ].join(" ");
        }
        return `${prefix}${name}`;
      };
      var HTMLRenderer = class {
        /**
         * Creates a new HTMLRenderer
         *
         * @param {Tree} parseTree - the parse tree (must support `walk` API)
         * @param {{classPrefix: string}} options
         */
        constructor(parseTree, options) {
          this.buffer = "";
          this.classPrefix = options.classPrefix;
          parseTree.walk(this);
        }
        /**
         * Adds texts to the output stream
         *
         * @param {string} text */
        addText(text) {
          this.buffer += escapeHTML(text);
        }
        /**
         * Adds a node open to the output stream (if needed)
         *
         * @param {Node} node */
        openNode(node) {
          if (!emitsWrappingTags(node))
            return;
          let className = "";
          if (node.sublanguage) {
            className = `language-${node.language}`;
          } else {
            className = scopeToCSSClass(node.scope, { prefix: this.classPrefix });
          }
          this.span(className);
        }
        /**
         * Adds a node close to the output stream (if needed)
         *
         * @param {Node} node */
        closeNode(node) {
          if (!emitsWrappingTags(node))
            return;
          this.buffer += SPAN_CLOSE;
        }
        /**
         * returns the accumulated buffer
        */
        value() {
          return this.buffer;
        }
        // helpers
        /**
         * Builds a span element
         *
         * @param {string} className */
        span(className) {
          this.buffer += `<span class="${className}">`;
        }
      };
      var newNode = (opts = {}) => {
        const result = { children: [] };
        Object.assign(result, opts);
        return result;
      };
      var TokenTree = class {
        constructor() {
          this.rootNode = newNode();
          this.stack = [this.rootNode];
        }
        get top() {
          return this.stack[this.stack.length - 1];
        }
        get root() {
          return this.rootNode;
        }
        /** @param {Node} node */
        add(node) {
          this.top.children.push(node);
        }
        /** @param {string} scope */
        openNode(scope) {
          const node = newNode({ scope });
          this.add(node);
          this.stack.push(node);
        }
        closeNode() {
          if (this.stack.length > 1) {
            return this.stack.pop();
          }
          return void 0;
        }
        closeAllNodes() {
          while (this.closeNode())
            ;
        }
        toJSON() {
          return JSON.stringify(this.rootNode, null, 4);
        }
        /**
         * @typedef { import("./html_renderer").Renderer } Renderer
         * @param {Renderer} builder
         */
        walk(builder) {
          return this.constructor._walk(builder, this.rootNode);
        }
        /**
         * @param {Renderer} builder
         * @param {Node} node
         */
        static _walk(builder, node) {
          if (typeof node === "string") {
            builder.addText(node);
          } else if (node.children) {
            builder.openNode(node);
            node.children.forEach((child) => this._walk(builder, child));
            builder.closeNode(node);
          }
          return builder;
        }
        /**
         * @param {Node} node
         */
        static _collapse(node) {
          if (typeof node === "string")
            return;
          if (!node.children)
            return;
          if (node.children.every((el) => typeof el === "string")) {
            node.children = [node.children.join("")];
          } else {
            node.children.forEach((child) => {
              TokenTree._collapse(child);
            });
          }
        }
      };
      var TokenTreeEmitter = class extends TokenTree {
        /**
         * @param {*} options
         */
        constructor(options) {
          super();
          this.options = options;
        }
        /**
         * @param {string} text
         * @param {string} scope
         */
        addKeyword(text, scope) {
          if (text === "") {
            return;
          }
          this.openNode(scope);
          this.addText(text);
          this.closeNode();
        }
        /**
         * @param {string} text
         */
        addText(text) {
          if (text === "") {
            return;
          }
          this.add(text);
        }
        /**
         * @param {Emitter & {root: DataNode}} emitter
         * @param {string} name
         */
        addSublanguage(emitter, name) {
          const node = emitter.root;
          node.sublanguage = true;
          node.language = name;
          this.add(node);
        }
        toHTML() {
          const renderer = new HTMLRenderer(this, this.options);
          return renderer.value();
        }
        finalize() {
          return true;
        }
      };
      function source(re) {
        if (!re)
          return null;
        if (typeof re === "string")
          return re;
        return re.source;
      }
      function lookahead(re) {
        return concat2("(?=", re, ")");
      }
      function anyNumberOfTimes(re) {
        return concat2("(?:", re, ")*");
      }
      function optional(re) {
        return concat2("(?:", re, ")?");
      }
      function concat2(...args) {
        const joined = args.map((x) => source(x)).join("");
        return joined;
      }
      function stripOptionsFromArgs(args) {
        const opts = args[args.length - 1];
        if (typeof opts === "object" && opts.constructor === Object) {
          args.splice(args.length - 1, 1);
          return opts;
        } else {
          return {};
        }
      }
      function either(...args) {
        const opts = stripOptionsFromArgs(args);
        const joined = "(" + (opts.capture ? "" : "?:") + args.map((x) => source(x)).join("|") + ")";
        return joined;
      }
      function countMatchGroups(re) {
        return new RegExp(re.toString() + "|").exec("").length - 1;
      }
      function startsWith(re, lexeme) {
        const match = re && re.exec(lexeme);
        return match && match.index === 0;
      }
      var BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
      function _rewriteBackreferences(regexps, { joinWith }) {
        let numCaptures = 0;
        return regexps.map((regex) => {
          numCaptures += 1;
          const offset = numCaptures;
          let re = source(regex);
          let out = "";
          while (re.length > 0) {
            const match = BACKREF_RE.exec(re);
            if (!match) {
              out += re;
              break;
            }
            out += re.substring(0, match.index);
            re = re.substring(match.index + match[0].length);
            if (match[0][0] === "\\" && match[1]) {
              out += "\\" + String(Number(match[1]) + offset);
            } else {
              out += match[0];
              if (match[0] === "(") {
                numCaptures++;
              }
            }
          }
          return out;
        }).map((re) => `(${re})`).join(joinWith);
      }
      var MATCH_NOTHING_RE = /\b\B/;
      var IDENT_RE = "[a-zA-Z]\\w*";
      var UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
      var NUMBER_RE = "\\b\\d+(\\.\\d+)?";
      var C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
      var BINARY_NUMBER_RE = "\\b(0b[01]+)";
      var RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
      var SHEBANG = (opts = {}) => {
        const beginShebang = /^#![ ]*\//;
        if (opts.binary) {
          opts.begin = concat2(
            beginShebang,
            /.*\b/,
            opts.binary,
            /\b.*/
          );
        }
        return inherit$1({
          scope: "meta",
          begin: beginShebang,
          end: /$/,
          relevance: 0,
          /** @type {ModeCallback} */
          "on:begin": (m, resp) => {
            if (m.index !== 0)
              resp.ignoreMatch();
          }
        }, opts);
      };
      var BACKSLASH_ESCAPE = {
        begin: "\\\\[\\s\\S]",
        relevance: 0
      };
      var APOS_STRING_MODE = {
        scope: "string",
        begin: "'",
        end: "'",
        illegal: "\\n",
        contains: [BACKSLASH_ESCAPE]
      };
      var QUOTE_STRING_MODE = {
        scope: "string",
        begin: '"',
        end: '"',
        illegal: "\\n",
        contains: [BACKSLASH_ESCAPE]
      };
      var PHRASAL_WORDS_MODE = {
        begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
      };
      var COMMENT = function(begin, end, modeOptions = {}) {
        const mode = inherit$1(
          {
            scope: "comment",
            begin,
            end,
            contains: []
          },
          modeOptions
        );
        mode.contains.push({
          scope: "doctag",
          // hack to avoid the space from being included. the space is necessary to
          // match here to prevent the plain text rule below from gobbling up doctags
          begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
          end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
          excludeBegin: true,
          relevance: 0
        });
        const ENGLISH_WORD = either(
          // list of common 1 and 2 letter words in English
          "I",
          "a",
          "is",
          "so",
          "us",
          "to",
          "at",
          "if",
          "in",
          "it",
          "on",
          // note: this is not an exhaustive list of contractions, just popular ones
          /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
          // contractions - can't we'd they're let's, etc
          /[A-Za-z]+[-][a-z]+/,
          // `no-way`, etc.
          /[A-Za-z][a-z]{2,}/
          // allow capitalized words at beginning of sentences
        );
        mode.contains.push(
          {
            // TODO: how to include ", (, ) without breaking grammars that use these for
            // comment delimiters?
            // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
            // ---
            // this tries to find sequences of 3 english words in a row (without any
            // "programming" type syntax) this gives us a strong signal that we've
            // TRULY found a comment - vs perhaps scanning with the wrong language.
            // It's possible to find something that LOOKS like the start of the
            // comment - but then if there is no readable text - good chance it is a
            // false match and not a comment.
            //
            // for a visual example please see:
            // https://github.com/highlightjs/highlight.js/issues/2827
            begin: concat2(
              /[ ]+/,
              // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
              "(",
              ENGLISH_WORD,
              /[.]?[:]?([.][ ]|[ ])/,
              "){3}"
            )
            // look for 3 words in a row
          }
        );
        return mode;
      };
      var C_LINE_COMMENT_MODE = COMMENT("//", "$");
      var C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
      var HASH_COMMENT_MODE = COMMENT("#", "$");
      var NUMBER_MODE = {
        scope: "number",
        begin: NUMBER_RE,
        relevance: 0
      };
      var C_NUMBER_MODE = {
        scope: "number",
        begin: C_NUMBER_RE,
        relevance: 0
      };
      var BINARY_NUMBER_MODE = {
        scope: "number",
        begin: BINARY_NUMBER_RE,
        relevance: 0
      };
      var REGEXP_MODE = {
        // this outer rule makes sure we actually have a WHOLE regex and not simply
        // an expression such as:
        //
        //     3 / something
        //
        // (which will then blow up when regex's `illegal` sees the newline)
        begin: /(?=\/[^/\n]*\/)/,
        contains: [{
          scope: "regexp",
          begin: /\//,
          end: /\/[gimuy]*/,
          illegal: /\n/,
          contains: [
            BACKSLASH_ESCAPE,
            {
              begin: /\[/,
              end: /\]/,
              relevance: 0,
              contains: [BACKSLASH_ESCAPE]
            }
          ]
        }]
      };
      var TITLE_MODE = {
        scope: "title",
        begin: IDENT_RE,
        relevance: 0
      };
      var UNDERSCORE_TITLE_MODE = {
        scope: "title",
        begin: UNDERSCORE_IDENT_RE,
        relevance: 0
      };
      var METHOD_GUARD = {
        // excludes method names from keyword processing
        begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
        relevance: 0
      };
      var END_SAME_AS_BEGIN = function(mode) {
        return Object.assign(
          mode,
          {
            /** @type {ModeCallback} */
            "on:begin": (m, resp) => {
              resp.data._beginMatch = m[1];
            },
            /** @type {ModeCallback} */
            "on:end": (m, resp) => {
              if (resp.data._beginMatch !== m[1])
                resp.ignoreMatch();
            }
          }
        );
      };
      var MODES = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        MATCH_NOTHING_RE,
        IDENT_RE,
        UNDERSCORE_IDENT_RE,
        NUMBER_RE,
        C_NUMBER_RE,
        BINARY_NUMBER_RE,
        RE_STARTERS_RE,
        SHEBANG,
        BACKSLASH_ESCAPE,
        APOS_STRING_MODE,
        QUOTE_STRING_MODE,
        PHRASAL_WORDS_MODE,
        COMMENT,
        C_LINE_COMMENT_MODE,
        C_BLOCK_COMMENT_MODE,
        HASH_COMMENT_MODE,
        NUMBER_MODE,
        C_NUMBER_MODE,
        BINARY_NUMBER_MODE,
        REGEXP_MODE,
        TITLE_MODE,
        UNDERSCORE_TITLE_MODE,
        METHOD_GUARD,
        END_SAME_AS_BEGIN
      });
      function skipIfHasPrecedingDot(match, response) {
        const before = match.input[match.index - 1];
        if (before === ".") {
          response.ignoreMatch();
        }
      }
      function scopeClassName(mode, _parent) {
        if (mode.className !== void 0) {
          mode.scope = mode.className;
          delete mode.className;
        }
      }
      function beginKeywords(mode, parent) {
        if (!parent)
          return;
        if (!mode.beginKeywords)
          return;
        mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
        mode.__beforeBegin = skipIfHasPrecedingDot;
        mode.keywords = mode.keywords || mode.beginKeywords;
        delete mode.beginKeywords;
        if (mode.relevance === void 0)
          mode.relevance = 0;
      }
      function compileIllegal(mode, _parent) {
        if (!Array.isArray(mode.illegal))
          return;
        mode.illegal = either(...mode.illegal);
      }
      function compileMatch(mode, _parent) {
        if (!mode.match)
          return;
        if (mode.begin || mode.end)
          throw new Error("begin & end are not supported with match");
        mode.begin = mode.match;
        delete mode.match;
      }
      function compileRelevance(mode, _parent) {
        if (mode.relevance === void 0)
          mode.relevance = 1;
      }
      var beforeMatchExt = (mode, parent) => {
        if (!mode.beforeMatch)
          return;
        if (mode.starts)
          throw new Error("beforeMatch cannot be used with starts");
        const originalMode = Object.assign({}, mode);
        Object.keys(mode).forEach((key) => {
          delete mode[key];
        });
        mode.keywords = originalMode.keywords;
        mode.begin = concat2(originalMode.beforeMatch, lookahead(originalMode.begin));
        mode.starts = {
          relevance: 0,
          contains: [
            Object.assign(originalMode, { endsParent: true })
          ]
        };
        mode.relevance = 0;
        delete originalMode.beforeMatch;
      };
      var COMMON_KEYWORDS = [
        "of",
        "and",
        "for",
        "in",
        "not",
        "or",
        "if",
        "then",
        "parent",
        // common variable name
        "list",
        // common variable name
        "value"
        // common variable name
      ];
      var DEFAULT_KEYWORD_SCOPE = "keyword";
      function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {
        const compiledKeywords = /* @__PURE__ */ Object.create(null);
        if (typeof rawKeywords === "string") {
          compileList(scopeName, rawKeywords.split(" "));
        } else if (Array.isArray(rawKeywords)) {
          compileList(scopeName, rawKeywords);
        } else {
          Object.keys(rawKeywords).forEach(function(scopeName2) {
            Object.assign(
              compiledKeywords,
              compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2)
            );
          });
        }
        return compiledKeywords;
        function compileList(scopeName2, keywordList) {
          if (caseInsensitive) {
            keywordList = keywordList.map((x) => x.toLowerCase());
          }
          keywordList.forEach(function(keyword) {
            const pair = keyword.split("|");
            compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];
          });
        }
      }
      function scoreForKeyword(keyword, providedScore) {
        if (providedScore) {
          return Number(providedScore);
        }
        return commonKeyword(keyword) ? 0 : 1;
      }
      function commonKeyword(keyword) {
        return COMMON_KEYWORDS.includes(keyword.toLowerCase());
      }
      var seenDeprecations = {};
      var error = (message) => {
        console.error(message);
      };
      var warn = (message, ...args) => {
        console.log(`WARN: ${message}`, ...args);
      };
      var deprecated = (version3, message) => {
        if (seenDeprecations[`${version3}/${message}`])
          return;
        console.log(`Deprecated as of ${version3}. ${message}`);
        seenDeprecations[`${version3}/${message}`] = true;
      };
      var MultiClassError = new Error();
      function remapScopeNames(mode, regexes, { key }) {
        let offset = 0;
        const scopeNames = mode[key];
        const emit2 = {};
        const positions = {};
        for (let i = 1; i <= regexes.length; i++) {
          positions[i + offset] = scopeNames[i];
          emit2[i + offset] = true;
          offset += countMatchGroups(regexes[i - 1]);
        }
        mode[key] = positions;
        mode[key]._emit = emit2;
        mode[key]._multi = true;
      }
      function beginMultiClass(mode) {
        if (!Array.isArray(mode.begin))
          return;
        if (mode.skip || mode.excludeBegin || mode.returnBegin) {
          error("skip, excludeBegin, returnBegin not compatible with beginScope: {}");
          throw MultiClassError;
        }
        if (typeof mode.beginScope !== "object" || mode.beginScope === null) {
          error("beginScope must be object");
          throw MultiClassError;
        }
        remapScopeNames(mode, mode.begin, { key: "beginScope" });
        mode.begin = _rewriteBackreferences(mode.begin, { joinWith: "" });
      }
      function endMultiClass(mode) {
        if (!Array.isArray(mode.end))
          return;
        if (mode.skip || mode.excludeEnd || mode.returnEnd) {
          error("skip, excludeEnd, returnEnd not compatible with endScope: {}");
          throw MultiClassError;
        }
        if (typeof mode.endScope !== "object" || mode.endScope === null) {
          error("endScope must be object");
          throw MultiClassError;
        }
        remapScopeNames(mode, mode.end, { key: "endScope" });
        mode.end = _rewriteBackreferences(mode.end, { joinWith: "" });
      }
      function scopeSugar(mode) {
        if (mode.scope && typeof mode.scope === "object" && mode.scope !== null) {
          mode.beginScope = mode.scope;
          delete mode.scope;
        }
      }
      function MultiClass(mode) {
        scopeSugar(mode);
        if (typeof mode.beginScope === "string") {
          mode.beginScope = { _wrap: mode.beginScope };
        }
        if (typeof mode.endScope === "string") {
          mode.endScope = { _wrap: mode.endScope };
        }
        beginMultiClass(mode);
        endMultiClass(mode);
      }
      function compileLanguage(language) {
        function langRe(value, global2) {
          return new RegExp(
            source(value),
            "m" + (language.case_insensitive ? "i" : "") + (language.unicodeRegex ? "u" : "") + (global2 ? "g" : "")
          );
        }
        class MultiRegex {
          constructor() {
            this.matchIndexes = {};
            this.regexes = [];
            this.matchAt = 1;
            this.position = 0;
          }
          // @ts-ignore
          addRule(re, opts) {
            opts.position = this.position++;
            this.matchIndexes[this.matchAt] = opts;
            this.regexes.push([opts, re]);
            this.matchAt += countMatchGroups(re) + 1;
          }
          compile() {
            if (this.regexes.length === 0) {
              this.exec = () => null;
            }
            const terminators = this.regexes.map((el) => el[1]);
            this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: "|" }), true);
            this.lastIndex = 0;
          }
          /** @param {string} s */
          exec(s) {
            this.matcherRe.lastIndex = this.lastIndex;
            const match = this.matcherRe.exec(s);
            if (!match) {
              return null;
            }
            const i = match.findIndex((el, i2) => i2 > 0 && el !== void 0);
            const matchData = this.matchIndexes[i];
            match.splice(0, i);
            return Object.assign(match, matchData);
          }
        }
        class ResumableMultiRegex {
          constructor() {
            this.rules = [];
            this.multiRegexes = [];
            this.count = 0;
            this.lastIndex = 0;
            this.regexIndex = 0;
          }
          // @ts-ignore
          getMatcher(index) {
            if (this.multiRegexes[index])
              return this.multiRegexes[index];
            const matcher = new MultiRegex();
            this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
            matcher.compile();
            this.multiRegexes[index] = matcher;
            return matcher;
          }
          resumingScanAtSamePosition() {
            return this.regexIndex !== 0;
          }
          considerAll() {
            this.regexIndex = 0;
          }
          // @ts-ignore
          addRule(re, opts) {
            this.rules.push([re, opts]);
            if (opts.type === "begin")
              this.count++;
          }
          /** @param {string} s */
          exec(s) {
            const m = this.getMatcher(this.regexIndex);
            m.lastIndex = this.lastIndex;
            let result = m.exec(s);
            if (this.resumingScanAtSamePosition()) {
              if (result && result.index === this.lastIndex)
                ;
              else {
                const m2 = this.getMatcher(0);
                m2.lastIndex = this.lastIndex + 1;
                result = m2.exec(s);
              }
            }
            if (result) {
              this.regexIndex += result.position + 1;
              if (this.regexIndex === this.count) {
                this.considerAll();
              }
            }
            return result;
          }
        }
        function buildModeRegex(mode) {
          const mm = new ResumableMultiRegex();
          mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: "begin" }));
          if (mode.terminatorEnd) {
            mm.addRule(mode.terminatorEnd, { type: "end" });
          }
          if (mode.illegal) {
            mm.addRule(mode.illegal, { type: "illegal" });
          }
          return mm;
        }
        function compileMode(mode, parent) {
          const cmode = mode;
          if (mode.isCompiled)
            return cmode;
          [
            scopeClassName,
            // do this early so compiler extensions generally don't have to worry about
            // the distinction between match/begin
            compileMatch,
            MultiClass,
            beforeMatchExt
          ].forEach((ext) => ext(mode, parent));
          language.compilerExtensions.forEach((ext) => ext(mode, parent));
          mode.__beforeBegin = null;
          [
            beginKeywords,
            // do this later so compiler extensions that come earlier have access to the
            // raw array if they wanted to perhaps manipulate it, etc.
            compileIllegal,
            // default to 1 relevance if not specified
            compileRelevance
          ].forEach((ext) => ext(mode, parent));
          mode.isCompiled = true;
          let keywordPattern = null;
          if (typeof mode.keywords === "object" && mode.keywords.$pattern) {
            mode.keywords = Object.assign({}, mode.keywords);
            keywordPattern = mode.keywords.$pattern;
            delete mode.keywords.$pattern;
          }
          keywordPattern = keywordPattern || /\w+/;
          if (mode.keywords) {
            mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
          }
          cmode.keywordPatternRe = langRe(keywordPattern, true);
          if (parent) {
            if (!mode.begin)
              mode.begin = /\B|\b/;
            cmode.beginRe = langRe(cmode.begin);
            if (!mode.end && !mode.endsWithParent)
              mode.end = /\B|\b/;
            if (mode.end)
              cmode.endRe = langRe(cmode.end);
            cmode.terminatorEnd = source(cmode.end) || "";
            if (mode.endsWithParent && parent.terminatorEnd) {
              cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
            }
          }
          if (mode.illegal)
            cmode.illegalRe = langRe(mode.illegal);
          if (!mode.contains)
            mode.contains = [];
          mode.contains = [].concat(...mode.contains.map(function(c) {
            return expandOrCloneMode(c === "self" ? mode : c);
          }));
          mode.contains.forEach(function(c) {
            compileMode(c, cmode);
          });
          if (mode.starts) {
            compileMode(mode.starts, parent);
          }
          cmode.matcher = buildModeRegex(cmode);
          return cmode;
        }
        if (!language.compilerExtensions)
          language.compilerExtensions = [];
        if (language.contains && language.contains.includes("self")) {
          throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
        }
        language.classNameAliases = inherit$1(language.classNameAliases || {});
        return compileMode(language);
      }
      function dependencyOnParent(mode) {
        if (!mode)
          return false;
        return mode.endsWithParent || dependencyOnParent(mode.starts);
      }
      function expandOrCloneMode(mode) {
        if (mode.variants && !mode.cachedVariants) {
          mode.cachedVariants = mode.variants.map(function(variant) {
            return inherit$1(mode, { variants: null }, variant);
          });
        }
        if (mode.cachedVariants) {
          return mode.cachedVariants;
        }
        if (dependencyOnParent(mode)) {
          return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });
        }
        if (Object.isFrozen(mode)) {
          return inherit$1(mode);
        }
        return mode;
      }
      var version2 = "11.7.0";
      var HTMLInjectionError = class extends Error {
        constructor(reason, html) {
          super(reason);
          this.name = "HTMLInjectionError";
          this.html = html;
        }
      };
      var escape = escapeHTML;
      var inherit = inherit$1;
      var NO_MATCH = Symbol("nomatch");
      var MAX_KEYWORD_HITS = 7;
      var HLJS = function(hljs) {
        const languages = /* @__PURE__ */ Object.create(null);
        const aliases = /* @__PURE__ */ Object.create(null);
        const plugins = [];
        let SAFE_MODE = true;
        const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
        const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
        let options = {
          ignoreUnescapedHTML: false,
          throwUnescapedHTML: false,
          noHighlightRe: /^(no-?highlight)$/i,
          languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
          classPrefix: "hljs-",
          cssSelector: "pre code",
          languages: null,
          // beta configuration options, subject to change, welcome to discuss
          // https://github.com/highlightjs/highlight.js/issues/1086
          __emitter: TokenTreeEmitter
        };
        function shouldNotHighlight(languageName) {
          return options.noHighlightRe.test(languageName);
        }
        function blockLanguage(block) {
          let classes = block.className + " ";
          classes += block.parentNode ? block.parentNode.className : "";
          const match = options.languageDetectRe.exec(classes);
          if (match) {
            const language = getLanguage(match[1]);
            if (!language) {
              warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
              warn("Falling back to no-highlight mode for this block.", block);
            }
            return language ? match[1] : "no-highlight";
          }
          return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
        }
        function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {
          let code = "";
          let languageName = "";
          if (typeof optionsOrCode === "object") {
            code = codeOrLanguageName;
            ignoreIllegals = optionsOrCode.ignoreIllegals;
            languageName = optionsOrCode.language;
          } else {
            deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
            deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
            languageName = codeOrLanguageName;
            code = optionsOrCode;
          }
          if (ignoreIllegals === void 0) {
            ignoreIllegals = true;
          }
          const context = {
            code,
            language: languageName
          };
          fire("before:highlight", context);
          const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);
          result.code = context.code;
          fire("after:highlight", result);
          return result;
        }
        function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
          const keywordHits = /* @__PURE__ */ Object.create(null);
          function keywordData(mode, matchText) {
            return mode.keywords[matchText];
          }
          function processKeywords() {
            if (!top.keywords) {
              emitter.addText(modeBuffer);
              return;
            }
            let lastIndex = 0;
            top.keywordPatternRe.lastIndex = 0;
            let match = top.keywordPatternRe.exec(modeBuffer);
            let buf = "";
            while (match) {
              buf += modeBuffer.substring(lastIndex, match.index);
              const word = language.case_insensitive ? match[0].toLowerCase() : match[0];
              const data = keywordData(top, word);
              if (data) {
                const [kind, keywordRelevance] = data;
                emitter.addText(buf);
                buf = "";
                keywordHits[word] = (keywordHits[word] || 0) + 1;
                if (keywordHits[word] <= MAX_KEYWORD_HITS)
                  relevance += keywordRelevance;
                if (kind.startsWith("_")) {
                  buf += match[0];
                } else {
                  const cssClass = language.classNameAliases[kind] || kind;
                  emitter.addKeyword(match[0], cssClass);
                }
              } else {
                buf += match[0];
              }
              lastIndex = top.keywordPatternRe.lastIndex;
              match = top.keywordPatternRe.exec(modeBuffer);
            }
            buf += modeBuffer.substring(lastIndex);
            emitter.addText(buf);
          }
          function processSubLanguage() {
            if (modeBuffer === "")
              return;
            let result2 = null;
            if (typeof top.subLanguage === "string") {
              if (!languages[top.subLanguage]) {
                emitter.addText(modeBuffer);
                return;
              }
              result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
              continuations[top.subLanguage] = result2._top;
            } else {
              result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
            }
            if (top.relevance > 0) {
              relevance += result2.relevance;
            }
            emitter.addSublanguage(result2._emitter, result2.language);
          }
          function processBuffer() {
            if (top.subLanguage != null) {
              processSubLanguage();
            } else {
              processKeywords();
            }
            modeBuffer = "";
          }
          function emitMultiClass(scope, match) {
            let i = 1;
            const max = match.length - 1;
            while (i <= max) {
              if (!scope._emit[i]) {
                i++;
                continue;
              }
              const klass = language.classNameAliases[scope[i]] || scope[i];
              const text = match[i];
              if (klass) {
                emitter.addKeyword(text, klass);
              } else {
                modeBuffer = text;
                processKeywords();
                modeBuffer = "";
              }
              i++;
            }
          }
          function startNewMode(mode, match) {
            if (mode.scope && typeof mode.scope === "string") {
              emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);
            }
            if (mode.beginScope) {
              if (mode.beginScope._wrap) {
                emitter.addKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);
                modeBuffer = "";
              } else if (mode.beginScope._multi) {
                emitMultiClass(mode.beginScope, match);
                modeBuffer = "";
              }
            }
            top = Object.create(mode, { parent: { value: top } });
            return top;
          }
          function endOfMode(mode, match, matchPlusRemainder) {
            let matched = startsWith(mode.endRe, matchPlusRemainder);
            if (matched) {
              if (mode["on:end"]) {
                const resp = new Response(mode);
                mode["on:end"](match, resp);
                if (resp.isMatchIgnored)
                  matched = false;
              }
              if (matched) {
                while (mode.endsParent && mode.parent) {
                  mode = mode.parent;
                }
                return mode;
              }
            }
            if (mode.endsWithParent) {
              return endOfMode(mode.parent, match, matchPlusRemainder);
            }
          }
          function doIgnore(lexeme) {
            if (top.matcher.regexIndex === 0) {
              modeBuffer += lexeme[0];
              return 1;
            } else {
              resumeScanAtSamePosition = true;
              return 0;
            }
          }
          function doBeginMatch(match) {
            const lexeme = match[0];
            const newMode = match.rule;
            const resp = new Response(newMode);
            const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
            for (const cb of beforeCallbacks) {
              if (!cb)
                continue;
              cb(match, resp);
              if (resp.isMatchIgnored)
                return doIgnore(lexeme);
            }
            if (newMode.skip) {
              modeBuffer += lexeme;
            } else {
              if (newMode.excludeBegin) {
                modeBuffer += lexeme;
              }
              processBuffer();
              if (!newMode.returnBegin && !newMode.excludeBegin) {
                modeBuffer = lexeme;
              }
            }
            startNewMode(newMode, match);
            return newMode.returnBegin ? 0 : lexeme.length;
          }
          function doEndMatch(match) {
            const lexeme = match[0];
            const matchPlusRemainder = codeToHighlight.substring(match.index);
            const endMode = endOfMode(top, match, matchPlusRemainder);
            if (!endMode) {
              return NO_MATCH;
            }
            const origin = top;
            if (top.endScope && top.endScope._wrap) {
              processBuffer();
              emitter.addKeyword(lexeme, top.endScope._wrap);
            } else if (top.endScope && top.endScope._multi) {
              processBuffer();
              emitMultiClass(top.endScope, match);
            } else if (origin.skip) {
              modeBuffer += lexeme;
            } else {
              if (!(origin.returnEnd || origin.excludeEnd)) {
                modeBuffer += lexeme;
              }
              processBuffer();
              if (origin.excludeEnd) {
                modeBuffer = lexeme;
              }
            }
            do {
              if (top.scope) {
                emitter.closeNode();
              }
              if (!top.skip && !top.subLanguage) {
                relevance += top.relevance;
              }
              top = top.parent;
            } while (top !== endMode.parent);
            if (endMode.starts) {
              startNewMode(endMode.starts, match);
            }
            return origin.returnEnd ? 0 : lexeme.length;
          }
          function processContinuations() {
            const list = [];
            for (let current = top; current !== language; current = current.parent) {
              if (current.scope) {
                list.unshift(current.scope);
              }
            }
            list.forEach((item) => emitter.openNode(item));
          }
          let lastMatch = {};
          function processLexeme(textBeforeMatch, match) {
            const lexeme = match && match[0];
            modeBuffer += textBeforeMatch;
            if (lexeme == null) {
              processBuffer();
              return 0;
            }
            if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
              modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
              if (!SAFE_MODE) {
                const err = new Error(`0 width match regex (${languageName})`);
                err.languageName = languageName;
                err.badRule = lastMatch.rule;
                throw err;
              }
              return 1;
            }
            lastMatch = match;
            if (match.type === "begin") {
              return doBeginMatch(match);
            } else if (match.type === "illegal" && !ignoreIllegals) {
              const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.scope || "<unnamed>") + '"');
              err.mode = top;
              throw err;
            } else if (match.type === "end") {
              const processed = doEndMatch(match);
              if (processed !== NO_MATCH) {
                return processed;
              }
            }
            if (match.type === "illegal" && lexeme === "") {
              return 1;
            }
            if (iterations > 1e5 && iterations > match.index * 3) {
              const err = new Error("potential infinite loop, way more iterations than matches");
              throw err;
            }
            modeBuffer += lexeme;
            return lexeme.length;
          }
          const language = getLanguage(languageName);
          if (!language) {
            error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
            throw new Error('Unknown language: "' + languageName + '"');
          }
          const md = compileLanguage(language);
          let result = "";
          let top = continuation || md;
          const continuations = {};
          const emitter = new options.__emitter(options);
          processContinuations();
          let modeBuffer = "";
          let relevance = 0;
          let index = 0;
          let iterations = 0;
          let resumeScanAtSamePosition = false;
          try {
            top.matcher.considerAll();
            for (; ; ) {
              iterations++;
              if (resumeScanAtSamePosition) {
                resumeScanAtSamePosition = false;
              } else {
                top.matcher.considerAll();
              }
              top.matcher.lastIndex = index;
              const match = top.matcher.exec(codeToHighlight);
              if (!match)
                break;
              const beforeMatch = codeToHighlight.substring(index, match.index);
              const processedCount = processLexeme(beforeMatch, match);
              index = match.index + processedCount;
            }
            processLexeme(codeToHighlight.substring(index));
            emitter.closeAllNodes();
            emitter.finalize();
            result = emitter.toHTML();
            return {
              language: languageName,
              value: result,
              relevance,
              illegal: false,
              _emitter: emitter,
              _top: top
            };
          } catch (err) {
            if (err.message && err.message.includes("Illegal")) {
              return {
                language: languageName,
                value: escape(codeToHighlight),
                illegal: true,
                relevance: 0,
                _illegalBy: {
                  message: err.message,
                  index,
                  context: codeToHighlight.slice(index - 100, index + 100),
                  mode: err.mode,
                  resultSoFar: result
                },
                _emitter: emitter
              };
            } else if (SAFE_MODE) {
              return {
                language: languageName,
                value: escape(codeToHighlight),
                illegal: false,
                relevance: 0,
                errorRaised: err,
                _emitter: emitter,
                _top: top
              };
            } else {
              throw err;
            }
          }
        }
        function justTextHighlightResult(code) {
          const result = {
            value: escape(code),
            illegal: false,
            relevance: 0,
            _top: PLAINTEXT_LANGUAGE,
            _emitter: new options.__emitter(options)
          };
          result._emitter.addText(code);
          return result;
        }
        function highlightAuto(code, languageSubset) {
          languageSubset = languageSubset || options.languages || Object.keys(languages);
          const plaintext = justTextHighlightResult(code);
          const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
            (name) => _highlight(name, code, false)
          );
          results.unshift(plaintext);
          const sorted = results.sort((a, b) => {
            if (a.relevance !== b.relevance)
              return b.relevance - a.relevance;
            if (a.language && b.language) {
              if (getLanguage(a.language).supersetOf === b.language) {
                return 1;
              } else if (getLanguage(b.language).supersetOf === a.language) {
                return -1;
              }
            }
            return 0;
          });
          const [best, secondBest] = sorted;
          const result = best;
          result.secondBest = secondBest;
          return result;
        }
        function updateClassName(element, currentLang, resultLang) {
          const language = currentLang && aliases[currentLang] || resultLang;
          element.classList.add("hljs");
          element.classList.add(`language-${language}`);
        }
        function highlightElement(element) {
          let node = null;
          const language = blockLanguage(element);
          if (shouldNotHighlight(language))
            return;
          fire(
            "before:highlightElement",
            { el: element, language }
          );
          if (element.children.length > 0) {
            if (!options.ignoreUnescapedHTML) {
              console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk.");
              console.warn("https://github.com/highlightjs/highlight.js/wiki/security");
              console.warn("The element with unescaped HTML:");
              console.warn(element);
            }
            if (options.throwUnescapedHTML) {
              const err = new HTMLInjectionError(
                "One of your code blocks includes unescaped HTML.",
                element.innerHTML
              );
              throw err;
            }
          }
          node = element;
          const text = node.textContent;
          const result = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto(text);
          element.innerHTML = result.value;
          updateClassName(element, language, result.language);
          element.result = {
            language: result.language,
            // TODO: remove with version 11.0
            re: result.relevance,
            relevance: result.relevance
          };
          if (result.secondBest) {
            element.secondBest = {
              language: result.secondBest.language,
              relevance: result.secondBest.relevance
            };
          }
          fire("after:highlightElement", { el: element, result, text });
        }
        function configure(userOptions) {
          options = inherit(options, userOptions);
        }
        const initHighlighting = () => {
          highlightAll();
          deprecated("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
        };
        function initHighlightingOnLoad() {
          highlightAll();
          deprecated("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
        }
        let wantsHighlight = false;
        function highlightAll() {
          if (document.readyState === "loading") {
            wantsHighlight = true;
            return;
          }
          const blocks = document.querySelectorAll(options.cssSelector);
          blocks.forEach(highlightElement);
        }
        function boot() {
          if (wantsHighlight)
            highlightAll();
        }
        if (typeof window !== "undefined" && window.addEventListener) {
          window.addEventListener("DOMContentLoaded", boot, false);
        }
        function registerLanguage(languageName, languageDefinition) {
          let lang = null;
          try {
            lang = languageDefinition(hljs);
          } catch (error$1) {
            error("Language definition for '{}' could not be registered.".replace("{}", languageName));
            if (!SAFE_MODE) {
              throw error$1;
            } else {
              error(error$1);
            }
            lang = PLAINTEXT_LANGUAGE;
          }
          if (!lang.name)
            lang.name = languageName;
          languages[languageName] = lang;
          lang.rawDefinition = languageDefinition.bind(null, hljs);
          if (lang.aliases) {
            registerAliases(lang.aliases, { languageName });
          }
        }
        function unregisterLanguage(languageName) {
          delete languages[languageName];
          for (const alias of Object.keys(aliases)) {
            if (aliases[alias] === languageName) {
              delete aliases[alias];
            }
          }
        }
        function listLanguages() {
          return Object.keys(languages);
        }
        function getLanguage(name) {
          name = (name || "").toLowerCase();
          return languages[name] || languages[aliases[name]];
        }
        function registerAliases(aliasList, { languageName }) {
          if (typeof aliasList === "string") {
            aliasList = [aliasList];
          }
          aliasList.forEach((alias) => {
            aliases[alias.toLowerCase()] = languageName;
          });
        }
        function autoDetection(name) {
          const lang = getLanguage(name);
          return lang && !lang.disableAutodetect;
        }
        function upgradePluginAPI(plugin) {
          if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
            plugin["before:highlightElement"] = (data) => {
              plugin["before:highlightBlock"](
                Object.assign({ block: data.el }, data)
              );
            };
          }
          if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
            plugin["after:highlightElement"] = (data) => {
              plugin["after:highlightBlock"](
                Object.assign({ block: data.el }, data)
              );
            };
          }
        }
        function addPlugin(plugin) {
          upgradePluginAPI(plugin);
          plugins.push(plugin);
        }
        function fire(event, args) {
          const cb = event;
          plugins.forEach(function(plugin) {
            if (plugin[cb]) {
              plugin[cb](args);
            }
          });
        }
        function deprecateHighlightBlock(el) {
          deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
          deprecated("10.7.0", "Please use highlightElement now.");
          return highlightElement(el);
        }
        Object.assign(hljs, {
          highlight: highlight2,
          highlightAuto,
          highlightAll,
          highlightElement,
          // TODO: Remove with v12 API
          highlightBlock: deprecateHighlightBlock,
          configure,
          initHighlighting,
          initHighlightingOnLoad,
          registerLanguage,
          unregisterLanguage,
          listLanguages,
          getLanguage,
          registerAliases,
          autoDetection,
          inherit,
          addPlugin
        });
        hljs.debugMode = function() {
          SAFE_MODE = false;
        };
        hljs.safeMode = function() {
          SAFE_MODE = true;
        };
        hljs.versionString = version2;
        hljs.regex = {
          concat: concat2,
          lookahead,
          either,
          optional,
          anyNumberOfTimes
        };
        for (const key in MODES) {
          if (typeof MODES[key] === "object") {
            deepFreezeEs6.exports(MODES[key]);
          }
        }
        Object.assign(hljs, MODES);
        return hljs;
      };
      var highlight = HLJS({});
      module.exports = highlight;
      highlight.HighlightJS = highlight;
      highlight.default = highlight;
    }
  });

  // node_modules/highlight.js/styles/atom-one-light.css
  var require_atom_one_light = __commonJS({
    "node_modules/highlight.js/styles/atom-one-light.css"(exports, module) {
      module.exports = "pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#c18401}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}";
    }
  });

  // node_modules/highlight.js/styles/atom-one-dark.css
  var require_atom_one_dark = __commonJS({
    "node_modules/highlight.js/styles/atom-one-dark.css"(exports, module) {
      module.exports = "pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#e6c07b}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}";
    }
  });

  // src/lib/web.ts
  init_global();
  init_dirname();
  init_filename();
  init_buffer();
  init_process();

  // src/lib/contract-verifier.ts
  init_global();
  init_dirname();
  init_filename();
  init_buffer();
  init_process();
  var import_ton_core = __toESM(require_dist2());
  var import_ton = __toESM(require_dist3());
  var import_ton_access = __toESM(require_lib2());
  var import_sha256_js = __toESM(require_build2());
  var SOURCES_REGISTRY = "EQD-BJSVUJviud_Qv7Ymfd3qzXdrmV525e3YDzWQoHIAiInL";
  function toSha256Buffer(s) {
    const sha = new import_sha256_js.Sha256();
    sha.update(s);
    return Buffer2.from(sha.digestSync());
  }
  function defaultIpfsConverter(ipfs) {
    return ipfs.replace("ipfs://", "https://tonsource.infura-ipfs.io/ipfs/");
  }
  function tupleReaderSkip(t, num = 1) {
    for (let i = 0; i < num; i++) {
      t.pop();
    }
    return t;
  }
  var ContractVerifier = {
    async getSourcesJsonUrl(codeCellHash, options) {
      const tc = new import_ton.TonClient({
        endpoint: options?.httpApiEndpoint ?? await (0, import_ton_access.getHttpEndpoint)(),
        apiKey: options?.httpApiKey
      });
      const { stack: sourceItemAddressStack } = await tc.callGetMethod(
        import_ton_core.Address.parse(SOURCES_REGISTRY),
        "get_source_item_address",
        [
          {
            type: "int",
            value: BigInt(
              `0x${toSha256Buffer(options?.verifier ?? "orbs.com").toString(
                "hex"
              )}`
            )
          },
          {
            type: "int",
            value: BigInt(
              `0x${Buffer2.from(codeCellHash, "base64").toString("hex")}`
            )
          }
        ]
      );
      const sourceItemAddr = sourceItemAddressStack.readAddress();
      const isDeployed = await tc.isContractDeployed(sourceItemAddr);
      if (isDeployed) {
        const { stack: sourceItemDataStack } = await tc.callGetMethod(
          sourceItemAddr,
          "get_source_item_data"
        );
        const contentCell = tupleReaderSkip(sourceItemDataStack, 3).readCell().beginParse();
        const version2 = contentCell.loadUint(8);
        if (version2 !== 1)
          throw new Error("Unsupported version");
        const ipfsLink = contentCell.loadStringTail();
        return ipfsLink;
      }
      return null;
    },
    async getSourcesData(sourcesJsonUrl, ipfsConverter) {
      ipfsConverter = ipfsConverter ?? defaultIpfsConverter;
      const ipfsHttpLink = ipfsConverter(sourcesJsonUrl);
      const verifiedContract = await (await fetch(ipfsConverter(sourcesJsonUrl))).json();
      const files = (await Promise.all(
        verifiedContract.sources.map(
          async (source) => {
            const url = ipfsConverter(source.url);
            const content = await fetch(url).then((u) => u.text());
            return {
              name: source.filename,
              content,
              isEntrypoint: source.isEntrypoint,
              type: source.type
            };
          }
        )
      )).reverse().sort((a, b) => {
        if (a.type && b.type) {
          return Number(b.type === "code") - Number(a.type === "code");
        }
        return Number(b.isEntrypoint) - Number(a.isEntrypoint);
      });
      return {
        files,
        verificationDate: new Date(verifiedContract.verificationDate),
        compilerSettings: verifiedContract.compilerSettings,
        compiler: verifiedContract.compiler,
        ipfsHttpLink
      };
    }
  };

  // src/lib/contract-verifier-ui.ts
  init_global();
  init_dirname();
  init_filename();
  init_buffer();
  init_process();

  // node_modules/highlight.js/es/core.js
  init_global();
  init_dirname();
  init_filename();
  init_buffer();
  init_process();
  var import_core = __toESM(require_core(), 1);
  var core_default = import_core.default;

  // node_modules/highlightjs-func/src/index.js
  init_global();
  init_dirname();
  init_filename();
  init_buffer();
  init_process();

  // node_modules/highlightjs-func/src/languages/func.js
  init_global();
  init_dirname();
  init_filename();
  init_buffer();
  init_process();
  var IDENTIFIER = '(?!")(`([^`]+)`|((?=_)_|(?=\\{)\\{|(?=\\})\\}|(?![_`{}]))([^;,\\[\\]\\(\\)\\s~.]+))';
  var STRING = /\"[^\n\"]+\"[Hhcusa]?/;
  var NUMBER;
  try {
    NUMBER = /(-?(?!_)([\d_]+|0x[\d_a-fA-F]+)|0b[1_0]+)(?<!_)(?=[\s\)\],;])/;
  } catch (e) {
    NUMBER = /\d/;
  }
  function func_default(hljs) {
    return {
      "name": "FunC",
      "aliases": ["func"],
      "case_insensitive": false,
      "keywords": {
        "keyword": [
          "if",
          "ifnot",
          "else",
          "elseif",
          "elseifnot|10",
          "while",
          "do",
          "until",
          "repeat",
          "return",
          "impure",
          "method_id",
          "forall",
          "asm",
          "inline",
          "inline_ref|10",
          "const",
          "global"
        ],
        "literal": ["true", "false"],
        "type": ["var", "int", "slice", "tuple", "cell", "builder", "cont", "_"],
        "built_in": []
      },
      "contains": [
        // Comments
        { "scope": "comment", "begin": ";;", "end": /(?=\n)/ },
        {
          "scope": "comment",
          "begin": "{-",
          "end": "-}",
          "contains": ["self"]
        },
        // Directives
        {
          "scope": "meta",
          "begin": /#pragma/,
          "end": /;/,
          "contains": [
            { "scope": "keyword", "match": /version|not-version/ },
            {
              "scope": "operator",
              "match": hljs.regex.either(/>=/, /<=/, /=/, />/, /</, /\^/)
            },
            {
              "scope": "number",
              "match": /([0-9]+)(.[0-9]+)?(.[0-9]+)?/
            }
          ]
        },
        {
          "scope": "keyword",
          "begin": /#include/,
          "end": /;/,
          "contains": [
            { "scope": "string", "match": STRING }
          ]
        },
        // Primitives
        { "scope": "number", "match": NUMBER },
        { "scope": "string", "match": STRING },
        // Constans / Variables / Functions
        {
          "match": [
            /\b(const|global)\b/,
            /\s+/,
            /\w+/,
            // in real world this is just a type, but we allow any text
            /\s+/,
            IDENTIFIER
          ],
          "scope": {
            1: "keyword",
            5: "variable.constant"
          }
        },
        { "scope": "function", "match": new RegExp(IDENTIFIER + "(?=[(])") },
        // Punctuation
        {
          "scope": "operator",
          "match": hljs.regex.either(
            /<=>/,
            />=/,
            /<=/,
            /!=/,
            /==/,
            /\^>>/,
            /~>>/,
            />>/,
            /<</,
            /\/%/,
            /\^%/,
            /~%/,
            /\^\//,
            /~\//,
            /\+=/,
            /-=/,
            /\*=/,
            /\/=/,
            /~\/=/,
            /\^\/=/,
            /%=/,
            /\^%=/,
            /<<=/,
            />>=/,
            /~>>=/,
            /\^>>=/,
            /&=/,
            /\^=/,
            /\|=/,
            /\^/,
            /=/,
            /~/,
            /\//,
            /%/,
            /-/,
            /\*/,
            /\+/,
            />/,
            /</,
            /&/,
            /\|/,
            /:/,
            /\?/
          )
        },
        { "scope": "punctuation", "match": /[\.;\(\),\[\]~\{\}]/ }
      ]
    };
  }

  // node_modules/highlightjs-func/src/languages/fift.js
  init_global();
  init_dirname();
  init_filename();
  init_buffer();
  init_process();
  var IDENTIFIER2 = /[0-9A-Za-z$_-]+/;
  var WORD_DEFS = /(::_|::|:_|=:|:)/;
  function fift_default(hljs) {
    return {
      "name": "Fift",
      "aliases": ["fift"],
      "case_insensitive": false,
      "keywords": {
        "keyword": [
          // It is kinda hard to tell what is a keyword and what is an operator
          // in fift. So, we do this instead:
          // - If something contains letters / numbers / `-`,
          //   we treat it as a keywrod
          // - If something contains any other chars like `,`, `-`, `?`, `+`,
          //   then we treat it as an operator
          "-roll",
          "-rot|10",
          "-trailing",
          "-trailing0",
          "2constant|10",
          "2drop|10",
          "2dup|10",
          "2over|10",
          "2swap|10",
          "abort",
          "abs",
          "allot",
          "and",
          "anon",
          "atom",
          "bbitrefs",
          "bbits",
          "bl",
          "box",
          "brefs",
          "brembitrefs",
          "brembits",
          "bremrefs",
          "bye",
          "cadr",
          "caddr",
          "car",
          "cddr",
          "cdr",
          "char",
          "chr",
          "cmp",
          "cond",
          "cons",
          "constant",
          "count",
          "cr",
          "create",
          "drop",
          "depth",
          "dictmap",
          "dictmerge",
          "dictnew",
          "does",
          "drop",
          "dup",
          "ed25519_chksign",
          "ed25519_sign",
          "ed25519_sign_uint",
          "emit",
          "exch",
          "exch2|10",
          "execute",
          "explode",
          "find",
          "first",
          "fits",
          "forget",
          "gasrunvm",
          "gasrunvmcode",
          "gasrunvmctx",
          "gasrunvmdict",
          "halt",
          "hash",
          "hashB",
          "hashu",
          "hold",
          "hole",
          "if",
          "ifnot",
          "include",
          "list",
          "minmax",
          "max",
          "min",
          "mod",
          "negate",
          "newkeypair",
          "nil",
          "nip",
          "nop",
          "not",
          "now",
          "null",
          "or",
          "over",
          "pair",
          "pick",
          "quit",
          "remaining",
          "reverse",
          "roll",
          "rot",
          "runvm",
          "runvmcode",
          "runvmctx",
          "runvmdict",
          "sbitrefs",
          "sbits",
          "second",
          "sgn",
          "sign",
          "shash",
          "space",
          "swap",
          "single",
          "skipspc",
          "srefs",
          "ten",
          "third",
          "times",
          "triple",
          "tuck",
          "tuple",
          "type",
          "ufits",
          "uncons",
          "unpair",
          "unsingle",
          "until",
          "untriple",
          "untuple",
          "variable",
          "while",
          "word",
          "words",
          "xor"
        ],
        "literal": ["true", "false"],
        "type": [],
        "built_in": []
      },
      "contains": [
        // Comments
        {
          "scope": "comment",
          "variants": [
            hljs.C_BLOCK_COMMENT_MODE,
            hljs.C_LINE_COMMENT_MODE
          ],
          "relevance": 0
        },
        // Words, variables, and constants
        {
          "match": [
            /\s/,
            /2?constant/,
            /\s+/,
            IDENTIFIER2
          ],
          "scope": {
            2: "keyword",
            4: "variable.constant"
          }
        },
        {
          "match": [
            /\s/,
            /variable/,
            /\s+/,
            IDENTIFIER2
          ],
          "scope": {
            2: "keyword",
            4: "variable"
          }
        },
        {
          "match": [
            /}/,
            /\s+/,
            WORD_DEFS,
            /\s+/,
            IDENTIFIER2
          ],
          "scope": {
            1: "punctuation",
            3: "operator",
            5: "function"
            // this is the closest we have for "word" in fift
          }
        },
        // Operators
        {
          "scope": "operator",
          "match": hljs.regex.either(
            // Full list can be found in
            // Appendix A. List of Fift words
            // Ordered the same way source code does this.
            // Except: shorter words must follow
            // longer ones with the same base part.
            // Example: `#` comes after `#s`
            /!/,
            /#>/,
            /#s/,
            /\$#/,
            /#/,
            /\$\+/,
            /\$,/,
            /\$\d/,
            /\$=/,
            /\$(?=\()/,
            /\$>smca/,
            /\$>s/,
            /\$@\+/,
            /\$@\?\+/,
            /\$@\?/,
            /\$@/,
            /\$cmp/,
            /\$len/,
            /\$pos/,
            /\$reverse/,
            /%1<</,
            /\('\)/,
            /\(-trailing\)/,
            /\(\.\)/,
            /\(atom\)/,
            /\(b\.\)/,
            /\(compile\)/,
            /\(create\)/,
            /\(def\?\)/,
            /\(dump\)/,
            /\(execute\)/,
            /\(forget\)/,
            /\(number\)/,
            /\(x\.\)/,
            /\(\{\)/,
            /\(\}\)/,
            /\*\/cmod/,
            /\*\/c/,
            /\*\/mod/,
            /\*\/rmod/,
            /\*\/r/,
            /\*\//,
            /\*>>c/,
            /\*>>r/,
            /\*>>/,
            /\*mod/,
            /\*/,
            /\+!/,
            /\+/,
            /,/,
            /-!/,
            /-/,
            /-1<</,
            /\._/,
            /\.dump/,
            /\.l/,
            /\.sl/,
            /\.s/,
            /\.tc/,
            /\//,
            /\/\*/,
            /\/cmod/,
            /\/c/,
            /\/mod/,
            /\/rmod/,
            /\/r/,
            /0!/,
            /0<=/,
            /0<>/,
            /0</,
            /0=/,
            /0>=/,
            /0>/,
            /1\+!/,
            /1\+/,
            /1-!/,
            /1-/,
            /1<</,
            /1<<1-/,
            /2\*/,
            /2\+/,
            /2-/,
            /2\//,
            /2=:/,
            WORD_DEFS,
            /<#/,
            /<<\/c/,
            /<<\/r/,
            /<=/,
            /<>/,
            /<b/,
            /<s/,
            /<<\//,
            /<</,
            /</,
            /=/,
            />=/,
            />>c/,
            />>r/,
            />>/,
            />/,
            /\?dup/,
            /@'/,
            /@/,
            /B\+/,
            /B,/,
            /B=/,
            /B>Li@\+/,
            /B>Li@/,
            /B>Lu@\+/,
            /B>Lu@/,
            /B>boc/,
            /B>file/,
            /B>i@\+/,
            /B>i@/,
            /B>u@\+/,
            /B>u@/,
            /B@\?\+/,
            /B@\+/,
            /B@\?/,
            /B@/,
            /Bcmp/,
            /BhashB/,
            /Bhashu/,
            /Bhash/,
            /Blen/,
            /Bx\./,
            /B\|/,
            /Li>B/,
            /Lu>B/,
            /\[\]/,
            /\[compile\]/,
            /\[/,
            /\]/,
            /atom\?/,
            /b\+/,
            /b\._/,
            /b\./,
            /b>idict!\+/,
            /b>idict!/,
            /b>sdict!\+/,
            /b>sdict!/,
            /b>udict!\+/,
            /b>udict!/,
            /b>/,
            /boc+>B/,
            /boc>B/,
            /csr\./,
            /def\?/,
            /empty\?/,
            /eq\?/,
            /file-exists\?/,
            /file>B/,
            /i,/,
            /i>B/,
            /i@\+/,
            /i@/,
            /i@\?\+/,
            /i@\?/,
            /idict!\+/,
            /idict!/,
            /idict-/,
            /idict@-/,
            /idict@/,
            /null!/,
            /null\?/,
            /pfxdict!\+/,
            /pfxdict!/,
            /pfxdict@/,
            /priv>pub/,
            /ref@\+/,
            /ref@/,
            /ref@\?\+/,
            /ref@\?/,
            /s,/,
            /s>c/,
            /s>/,
            /sdict!\+/,
            /sdict!/,
            /sdict-/,
            /sdict@-/,
            /sdict@/,
            /smca>\$/,
            /sr,/,
            /tuple\?/,
            /u,/,
            /u>B/,
            /u@\+/,
            /u@\?\+/,
            /u@\?/,
            /udict!\+/,
            /udict!/,
            /udict-/,
            /udict@-/,
            /udict@/,
            /undef\?/,
            /x\._/,
            /x\./,
            /\|\+/,
            /\|/,
            /\|_/,
            // Should be the last:
            /(?<=\s)\.(?=\s)/
          )
        },
        // Primitives
        {
          "scope": "number",
          "match": hljs.regex.either(
            /(0[xX][0-9a-fA-F]+)/,
            /(0[bB][01]+)/,
            /(-?[0-9]+(\/-?[0-9]+)?)/
          )
        },
        { "scope": "string", "match": /"([^"\r\n\\]|\\.)*"/ },
        {
          // slice hex literal
          "scope": "symbol",
          "match": /[xX]\{[0-9a-fA-F_]*}/,
          "relevance": 10
        },
        {
          // byte hex literal
          "scope": "symbol",
          "match": /[bB]\{[01]*}/,
          "relevance": 10
        },
        {
          // atom
          "scope": "symbol",
          "match": /'[^\s]+/
        },
        // Punctuation
        { "scope": "punctuation", "match": /[\[\{\}\],]/ }
      ]
    };
  }

  // node_modules/highlightjs-func/src/languages/tlb.js
  init_global();
  init_dirname();
  init_filename();
  init_buffer();
  init_process();
  var IDENTIFIER3 = /[a-zA-Z_][0-9a-zA-Z_]*/;
  function tlb_default(hljs) {
    return {
      "name": "TL-B",
      "aliases": ["Tlb", "tlb", "TLB", "tl-b", "TL-b", "Tl-B", "Tl-b"],
      "case_insensitive": false,
      "keywords": {
        "keyword": [],
        "literal": ["True", "BoolTrue", "False", "BoolFalse", "Null"],
        "type": [
          // These are special cased, because they are used way too often:
          "Type",
          "Bool",
          "Unit",
          "Maybe",
          "Either",
          "Both",
          "Cell",
          // Not mentioned, but also widely used:
          "uint8",
          "uint15",
          "uint16",
          "uint32",
          "uint63",
          "uint64",
          "int8",
          "int16",
          "int32",
          "int64",
          "bits256",
          "bits512"
        ],
        "built_in": []
      },
      "contains": [
        // Comments
        {
          "scope": "comment",
          "variants": [
            hljs.C_BLOCK_COMMENT_MODE,
            hljs.C_LINE_COMMENT_MODE
          ]
        },
        // Type definitions and tags
        {
          "scope": "symbol",
          "match": hljs.regex.either(
            /#[0-9a-f]*_?/,
            /\$[01]*_?/,
            /##/,
            /#<=/,
            /#</
          )
        },
        {
          "match": [
            /=/,
            /\s+/,
            IDENTIFIER3,
            /[\s;]/
          ],
          "scope": {
            1: "operator",
            3: "type"
          }
        },
        // Variables
        { "scope": "variable", "match": IDENTIFIER3 },
        // Operators
        {
          "scope": "operator",
          "match": hljs.regex.either(
            /\+/,
            /-/,
            /\*/,
            /\//,
            /!=/,
            /==/,
            /=/,
            /\?/,
            /~/,
            /\./,
            /\^/,
            /<=/,
            />=/,
            /</,
            />/
          )
        },
        // Primitives
        { "scope": "number", "match": /[0-9]+/ },
        // Punctuation
        { "scope": "punctuation", "match": /[;\(\):\[\]\{\}]/ }
      ]
    };
  }

  // node_modules/highlightjs-func/src/index.js
  function src_default(hljs) {
    hljs.registerLanguage("fift", fift_default);
    hljs.registerLanguage("func", func_default);
    hljs.registerLanguage("tlb", tlb_default);
  }

  // src/lib/dom.ts
  init_global();
  init_dirname();
  init_filename();
  init_buffer();
  init_process();
  var div = (props, ...children) => createElement("div", props, ...children);
  var img = (props, ...children) => createElement("img", props, ...children);
  function appendChildren(parent, children) {
    for (const child of children) {
      if (!child)
        continue;
      switch (typeof child) {
        case "string":
          const el = document.createTextNode(child);
          parent.appendChild(el);
          break;
        default:
          parent.appendChild(child);
          break;
      }
    }
  }
  function setStyle(el, style) {
    if (typeof style === "string") {
      el.setAttribute("style", style);
    } else {
      Object.assign(el.style, style);
    }
  }
  function setClass(el, className) {
    className.split(/\s/).forEach((element) => {
      if (element) {
        el.classList.add(element);
      }
    });
  }
  function setProps(el, props) {
    const eventRegex = /^on([a-z]+)$/i;
    for (const propName in props) {
      if (!propName)
        continue;
      if (propName === "style") {
        setStyle(el, props[propName]);
      } else if (propName === "className") {
        setClass(el, props[propName]);
      } else if (eventRegex.test(propName)) {
        const eventToListen = propName.replace(eventRegex, "$1").toLowerCase();
        el.addEventListener(eventToListen, props[propName]);
      } else {
        el.setAttribute(propName, props[propName]);
      }
    }
  }
  function createElement(type, props, ...children) {
    if (typeof type === "function") {
      return type(props);
    } else {
      const el = document.createElement(type);
      if (props && typeof props === "object") {
        setProps(el, props);
      }
      if (children) {
        appendChildren(el, children);
      }
      return el;
    }
  }

  // src/lib/file-structure.ts
  init_global();
  init_dirname();
  init_filename();
  init_buffer();
  init_process();

  // src/lib/res/file-white.svg
  var file_white_default = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\n<g clip-path="url(#clip0_3604_24717)">\n<path d="M11 1H3C2.86739 1 2.74021 1.05268 2.64645 1.14645C2.55268 1.24021 2.5 1.36739 2.5 1.5V12.5C2.50079 13.1628 2.76444 13.7982 3.23311 14.2669C3.70178 14.7356 4.3372 14.9992 5 15H13C13.1326 15 13.2598 14.9473 13.3536 14.8536C13.4473 14.7598 13.5 14.6326 13.5 14.5V3.5C13.4992 2.8372 13.2356 2.20178 12.7669 1.73311C12.2982 1.26444 11.6628 1.00079 11 1ZM12.5 14H5C4.60218 14 4.22064 13.842 3.93934 13.5607C3.65804 13.2794 3.5 12.8978 3.5 12.5V2H11C11.3978 2 11.7794 2.15804 12.0607 2.43934C12.342 2.72064 12.5 3.10218 12.5 3.5V14Z" fill="white"/>\n<path d="M9.5 1.5V5H13M-1 1V1.5" stroke="white" stroke-linecap="round" stroke-linejoin="round"/>\n</g>\n<defs>\n<clipPath id="clip0_3604_24717">\n<rect width="16" height="16" fill="white"/>\n</clipPath>\n</defs>\n</svg>\n';

  // src/lib/res/file-black.svg
  var file_black_default = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\n<g clip-path="url(#clip0_3604_24717)">\n<path d="M11 1H3C2.86739 1 2.74021 1.05268 2.64645 1.14645C2.55268 1.24021 2.5 1.36739 2.5 1.5V12.5C2.50079 13.1628 2.76444 13.7982 3.23311 14.2669C3.70178 14.7356 4.3372 14.9992 5 15H13C13.1326 15 13.2598 14.9473 13.3536 14.8536C13.4473 14.7598 13.5 14.6326 13.5 14.5V3.5C13.4992 2.8372 13.2356 2.20178 12.7669 1.73311C12.2982 1.26444 11.6628 1.00079 11 1ZM12.5 14H5C4.60218 14 4.22064 13.842 3.93934 13.5607C3.65804 13.2794 3.5 12.8978 3.5 12.5V2H11C11.3978 2 11.7794 2.15804 12.0607 2.43934C12.342 2.72064 12.5 3.10218 12.5 3.5V14Z" fill="black"/>\n<path d="M9.5 1.5V5H13M-1 1V1.5" stroke="black" stroke-linecap="round" stroke-linejoin="round"/>\n</g>\n<defs>\n<clipPath id="clip0_3604_24717">\n<rect width="16" height="16" fill="white"/>\n</clipPath>\n</defs>\n</svg>\n';

  // src/lib/res/folder-closed-white.svg
  var folder_closed_white_default = '<svg width="16" height="13" viewBox="0 0 15 13" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path d="M13.1518 2.46462H8.40426C8.21155 2.46462 8.02331 2.38549 7.89332 2.25099L6.41199 0.690527C6.05592 0.335596 5.56874 0.150206 5.07532 0.153047H1.84816C0.829129 0.153018 0 0.982147 0 2.00115V10.9989C0 12.0179 0.829129 12.847 1.84816 12.847H13.1586H13.1603C14.1788 12.8425 15.0045 12.0094 15 10.9932V4.31276C15 3.29372 14.1708 2.46462 13.1518 2.46462ZM13.8696 10.9955C13.8713 11.3911 13.5509 11.715 13.1575 11.7167H1.84816C1.45254 11.7167 1.13039 11.3945 1.13039 10.9989V2.00115C1.13039 1.60553 1.45254 1.28338 1.84816 1.28279H5.09003C5.09624 1.28279 5.10245 1.28279 5.10869 1.28279C5.29745 1.28279 5.48059 1.35797 5.60378 1.48005L7.0772 3.03316C7.42308 3.39035 7.90689 3.59495 8.40426 3.59495H13.1518C13.5474 3.59495 13.8696 3.9171 13.8696 4.31273V10.9955H13.8696Z" fill="white"/>\n</svg>\n';

  // src/lib/res/folder-closed-black.svg
  var folder_closed_black_default = '<svg width="16" height="13" viewBox="0 0 15 13" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path d="M13.1518 2.46462H8.40426C8.21155 2.46462 8.02331 2.38549 7.89332 2.25099L6.41199 0.690527C6.05592 0.335596 5.56874 0.150206 5.07532 0.153047H1.84816C0.829129 0.153018 0 0.982147 0 2.00115V10.9989C0 12.0179 0.829129 12.847 1.84816 12.847H13.1586H13.1603C14.1788 12.8425 15.0045 12.0094 15 10.9932V4.31276C15 3.29372 14.1708 2.46462 13.1518 2.46462ZM13.8696 10.9955C13.8713 11.3911 13.5509 11.715 13.1575 11.7167H1.84816C1.45254 11.7167 1.13039 11.3945 1.13039 10.9989V2.00115C1.13039 1.60553 1.45254 1.28338 1.84816 1.28279H5.09003C5.09624 1.28279 5.10245 1.28279 5.10869 1.28279C5.29745 1.28279 5.48059 1.35797 5.60378 1.48005L7.0772 3.03316C7.42308 3.39035 7.90689 3.59495 8.40426 3.59495H13.1518C13.5474 3.59495 13.8696 3.9171 13.8696 4.31273V10.9955H13.8696Z" fill="black"/>\n</svg>\n';

  // src/lib/res/folder-open-white.svg
  var folder_open_white_default = '<svg width="16" height="14" viewBox="0 0 16 14" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path d="M15.5488 6.00997C15.3895 5.79006 15.1795 5.61182 14.9367 5.49039C14.6938 5.36896 14.4252 5.30793 14.1538 5.31247H13.9738V4.18747C13.9738 3.963 13.9291 3.74077 13.8421 3.5338C13.7552 3.32683 13.6279 3.13928 13.4676 2.98214C13.3073 2.82499 13.1173 2.7014 12.9086 2.61861C12.7 2.53581 12.4769 2.49548 12.2525 2.49997H8.6075C8.47112 2.49917 8.33875 2.45373 8.23063 2.3706L5.98063 0.615596C5.67268 0.378476 5.29492 0.249919 4.90625 0.249971H1.84625C1.62182 0.245482 1.39875 0.285814 1.1901 0.368607C0.981456 0.451399 0.791423 0.574988 0.631131 0.732136C0.47084 0.889284 0.343513 1.07683 0.256606 1.2838C0.169698 1.49077 0.124957 1.713 0.125002 1.93747V12.0625C0.124513 12.3738 0.214398 12.6787 0.383752 12.94C0.539399 13.1874 0.755121 13.3914 1.01083 13.5331C1.26655 13.6747 1.55394 13.7493 1.84625 13.75H12.5338C12.901 13.7591 13.2613 13.6482 13.5597 13.434C13.8582 13.2198 14.0786 12.914 14.1875 12.5631L15.7963 7.5006C15.8737 7.24999 15.8916 6.98479 15.8487 6.72603C15.8057 6.46728 15.703 6.22211 15.5488 6.00997ZM1.25 1.93747C1.24986 1.86067 1.26545 1.78466 1.29581 1.71412C1.32616 1.64358 1.37064 1.58 1.4265 1.5273C1.48236 1.4746 1.54842 1.4339 1.62061 1.4077C1.6928 1.3815 1.76959 1.37036 1.84625 1.37497H4.90625C5.04449 1.37496 5.1789 1.42042 5.28875 1.50435L7.53875 3.25935C7.84457 3.49643 8.22055 3.62505 8.6075 3.62497H12.2525C12.3292 3.62036 12.406 3.6315 12.4781 3.6577C12.5503 3.6839 12.6164 3.7246 12.6723 3.7773C12.7281 3.83 12.7726 3.89358 12.8029 3.96412C12.8333 4.03466 12.8489 4.11068 12.8488 4.18747V5.31247H3.84875C3.48433 5.30701 3.12794 5.41968 2.83288 5.63362C2.53782 5.84756 2.31996 6.15128 2.21188 6.49935L1.25 9.55372V1.93747ZM14.75 7.1631L13.1413 12.2256C13.1051 12.3452 13.0303 12.4493 12.9284 12.5216C12.8266 12.594 12.7035 12.6303 12.5788 12.625H1.89125C1.76439 12.6247 1.64068 12.5854 1.53688 12.5125L3.33688 6.83685C3.37299 6.71727 3.44787 6.61312 3.54972 6.54081C3.65156 6.46849 3.77458 6.43214 3.89938 6.43747H14.1538C14.2485 6.43681 14.3422 6.45835 14.4271 6.50035C14.5121 6.54235 14.5861 6.60365 14.6431 6.67935C14.6967 6.74647 14.7342 6.82497 14.7527 6.90882C14.7712 6.99267 14.7703 7.07965 14.75 7.1631Z" fill="white"/>\n</svg>\n';

  // src/lib/res/folder-open-black.svg
  var folder_open_black_default = '<svg width="16" height="14" viewBox="0 0 16 14" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path d="M15.5488 6.00997C15.3895 5.79006 15.1795 5.61182 14.9367 5.49039C14.6938 5.36896 14.4252 5.30793 14.1538 5.31247H13.9738V4.18747C13.9738 3.963 13.9291 3.74077 13.8421 3.5338C13.7552 3.32683 13.6279 3.13928 13.4676 2.98214C13.3073 2.82499 13.1173 2.7014 12.9086 2.61861C12.7 2.53581 12.4769 2.49548 12.2525 2.49997H8.6075C8.47112 2.49917 8.33875 2.45373 8.23063 2.3706L5.98063 0.615596C5.67268 0.378476 5.29492 0.249919 4.90625 0.249971H1.84625C1.62182 0.245482 1.39875 0.285814 1.1901 0.368607C0.981456 0.451399 0.791423 0.574988 0.631131 0.732136C0.47084 0.889284 0.343513 1.07683 0.256606 1.2838C0.169698 1.49077 0.124957 1.713 0.125002 1.93747V12.0625C0.124513 12.3738 0.214398 12.6787 0.383752 12.94C0.539399 13.1874 0.755121 13.3914 1.01083 13.5331C1.26655 13.6747 1.55394 13.7493 1.84625 13.75H12.5338C12.901 13.7591 13.2613 13.6482 13.5597 13.434C13.8582 13.2198 14.0786 12.914 14.1875 12.5631L15.7963 7.5006C15.8737 7.24999 15.8916 6.98479 15.8487 6.72603C15.8057 6.46728 15.703 6.22211 15.5488 6.00997ZM1.25 1.93747C1.24986 1.86067 1.26545 1.78466 1.29581 1.71412C1.32616 1.64358 1.37064 1.58 1.4265 1.5273C1.48236 1.4746 1.54842 1.4339 1.62061 1.4077C1.6928 1.3815 1.76959 1.37036 1.84625 1.37497H4.90625C5.04449 1.37496 5.1789 1.42042 5.28875 1.50435L7.53875 3.25935C7.84457 3.49643 8.22055 3.62505 8.6075 3.62497H12.2525C12.3292 3.62036 12.406 3.6315 12.4781 3.6577C12.5503 3.6839 12.6164 3.7246 12.6723 3.7773C12.7281 3.83 12.7726 3.89358 12.8029 3.96412C12.8333 4.03466 12.8489 4.11068 12.8488 4.18747V5.31247H3.84875C3.48433 5.30701 3.12794 5.41968 2.83288 5.63362C2.53782 5.84756 2.31996 6.15128 2.21188 6.49935L1.25 9.55372V1.93747ZM14.75 7.1631L13.1413 12.2256C13.1051 12.3452 13.0303 12.4493 12.9284 12.5216C12.8266 12.594 12.7035 12.6303 12.5788 12.625H1.89125C1.76439 12.6247 1.64068 12.5854 1.53688 12.5125L3.33688 6.83685C3.37299 6.71727 3.44787 6.61312 3.54972 6.54081C3.65156 6.46849 3.77458 6.43214 3.89938 6.43747H14.1538C14.2485 6.43681 14.3422 6.45835 14.4271 6.50035C14.5121 6.54235 14.5861 6.60365 14.6431 6.67935C14.6967 6.74647 14.7342 6.82497 14.7527 6.90882C14.7712 6.99267 14.7703 7.07965 14.75 7.1631Z" fill="black"/>\n</svg>\n';

  // src/lib/file-structure.ts
  var icons = {
    dark: {
      file: file_white_default,
      folder: {
        open: folder_open_white_default,
        closed: folder_closed_white_default
      }
    },
    light: {
      file: file_black_default,
      folder: {
        open: folder_open_black_default,
        closed: folder_closed_black_default
      }
    }
  };
  var svgToInline = (svg) => `data:image/svg+xml;base64,${Buffer2.from(svg, "utf8").toString("base64")}`;
  var TreeFile = ({ name }, theme) => {
    return div(
      { className: `${classNames.FILE} ${classNames.TREE_ITEM}` },
      img({
        src: svgToInline(icons[theme].file)
      }),
      div(null, name)
    );
  };
  function changeOpened(theme, event) {
    const folderHeader = event.target.classList.contains("folder-header") ? event.target : event.target.parentElement;
    const opened = folderHeader.getAttribute("opened") === "true";
    const newOpened = !opened;
    folderHeader.children[0].attributes.src.value = svgToInline(
      newOpened ? icons[theme].folder.open : icons[theme].folder.closed
    );
    try {
      const sibling = folderHeader.nextElementSibling;
      if (newOpened) {
        sibling.classList.remove("hide");
      } else {
        sibling.classList.add("hide");
      }
    } catch (e) {
      console.warn(`No sibling of elem ${folderHeader} found ...`);
    }
    folderHeader.setAttribute("opened", newOpened);
  }
  var TreeFolder = (props, theme, ...children) => {
    const opened = props.opened || false;
    const folderIcon = icons[theme].folder[opened ? "open" : "closed"];
    const folderName = props.name || "unknown";
    return div(
      { className: classNames.FOLDER_CONTAINER },
      div(
        {
          onClick: changeOpened.bind(void 0, theme),
          className: `folder-header ${classNames.FOLDER} ${classNames.TREE_ITEM}`,
          opened
        },
        img({
          src: svgToInline(folderIcon)
        }),
        div(null, folderName)
      ),
      div({ className: `${opened ? "" : "hide"} folder-content` }, ...children)
    );
  };

  // src/lib/style.css
  var style_default = ".contract-verifier-container {\n  display: flex;\n  height: 100%;\n}\n\n.contract-verifier-code {\n  text-align: left;\n  overflow: auto;\n  height: 100%;\n  width: 100%;\n}\n\n.contract-verifier-code code {\n  display: flex;\n  padding: 0.5em;\n}\n\n.contract-verifier-code code div {\n  background: transparent;\n}\n\n.contract-verifier-code code .contract-verifier-code-lines {\n  padding: 0 20px 0 0;\n  text-align: right;\n  display: none;\n}\n\n.contract-verifier-container.lineNumbers .contract-verifier-code-lines {\n  display: initial;\n}\n\n.contract-verifier-code code.dark .contract-verifier-code-lines {\n  color: #7e7e7e;\n}\n\n.contract-verifier-code code.light .contract-verifier-code-lines {\n  color: #728a96;\n}\n\n.contract-verifier-code pre {\n  margin: 0;\n}\n\n.contract-verifier-files {\n  text-align: left;\n  flex-shrink: 0;\n  display: flex;\n  flex-direction: column;\n  width: 200px;\n  overflow-y: auto;\n}\n\n.contract-verifier-files.dark {\n  background: #28292d;\n}\n\n.contract-verifier-files.light {\n  background: #fff;\n}\n\n.contract-verifier-tree-item {\n  padding: 10px 6px;\n  cursor: pointer;\n  display: flex;\n  gap: 4px;\n  user-select: none;\n}\n\n.contract-verifier-files.dark .contract-verifier-tree-item:hover {\n  filter: brightness(0.8);\n}\n\n.contract-verifier-files.light .contract-verifier-tree-item:hover {\n  background-color: #f6f6f6;\n}\n\n.contract-verifier-files.dark .contract-verifier-file.active {\n  background: #232222;\n}\n\n.contract-verifier-files.light .contract-verifier-file.active {\n  background: #f2f2f2;\n}\n\n.contract-verifier-files .hide {\n  display: none;\n}\n\n.contract-verifier-folder-container > .folder-content {\n  padding-left: 12px;\n}\n";

  // src/lib/contract-verifier-ui.ts
  src_default(core_default);
  var classNames = {
    CONTAINER: "contract-verifier-container",
    FILES: "contract-verifier-files",
    FILE: "contract-verifier-file",
    FOLDER: "contract-verifier-folder",
    TREE_ITEM: "contract-verifier-tree-item",
    FOLDER_CONTAINER: "contract-verifier-folder-container",
    CODE_CONTAINER: "contract-verifier-code",
    CODE_LINES: "contract-verifier-code-lines",
    CODE_CONTENT: "contract-verifier-code-content"
  };
  var ContractVerifierUI = {
    _stylesPopulated: {
      internal: false
    },
    _populateStyle(theme) {
      if (!this._stylesPopulated[theme]) {
        this._stylesPopulated[theme] = true;
        const styleEl = document.createElement("style");
        styleEl.innerHTML = `${theme === "light" ? require_atom_one_light().toString() : require_atom_one_dark().toString()}`;
        document.head.appendChild(styleEl);
      }
      if (!this._stylesPopulated.internal) {
        this._stylesPopulated.internal = true;
        const styleEl = document.createElement("style");
        styleEl.innerHTML = style_default;
        document.head.appendChild(styleEl);
      }
    },
    _populateCode(contentSelector, theme) {
      const codeContainer = document.querySelector(contentSelector);
      codeContainer.classList.add(classNames.CODE_CONTAINER);
      codeContainer.innerHTML = `<pre><code class="${theme}"></code></pre>`;
    },
    _setCode({ name, content }, codeWrapperEl, filesListEl, fileEl) {
      if (fileEl?.classList.contains("active"))
        return;
      codeWrapperEl.scrollTo(0, 0);
      content = content.trim();
      const codeEl = codeWrapperEl.querySelector("code");
      codeEl.innerHTML = "";
      codeEl.appendChild(
        div(
          { className: classNames.CODE_LINES },
          content.split("\n").map((_, i) => i + 1).join("\n")
        )
      );
      const contentEl = div({ className: classNames.CODE_CONTENT }, content);
      codeEl.appendChild(contentEl);
      if (name.match(/\.fif(t)?$/)) {
        contentEl.classList.add("language-fift");
      } else {
        contentEl.classList.add("language-func");
      }
      core_default.highlightElement(contentEl);
      filesListEl?.querySelector(`.${classNames.FILE}.active`)?.classList.remove("active");
      fileEl?.classList.add("active");
    },
    setCode(contentSelector, content) {
      this._setCode(
        { name: "", content },
        document.querySelector(contentSelector)
      );
    },
    _populateFiles(fileListSelector, contentSelector, files, theme) {
      const filePart = document.querySelector(fileListSelector);
      filePart.innerHTML = "";
      filePart.classList.add(theme);
      filePart.classList.add(classNames.FILES);
      const root = {
        type: "root",
        children: []
      };
      files.forEach((file) => {
        const nameParts = Array.from(
          file.name.matchAll(/(?:\/|^)([^\/\n]+)/g)
        ).map((m) => m[1]);
        const folders = nameParts.length > 1 ? nameParts.slice(0, nameParts.length - 1) : [];
        let levelToPushTo = root;
        folders.forEach((folder) => {
          let existingFolder = levelToPushTo.children.find(
            (obj) => obj.type === "folder" && obj.name === folder
          );
          if (!existingFolder) {
            const newLevel = {
              type: "folder",
              name: folder,
              children: []
            };
            levelToPushTo.children.push(newLevel);
            existingFolder = newLevel;
          }
          levelToPushTo = existingFolder;
        });
        levelToPushTo.children.push({
          type: "file",
          name: nameParts[nameParts.length - 1],
          content: file.content
        });
      });
      function processLevel(level) {
        return level.children.filter((obj) => obj.type === "file").map((child) => {
          const file = TreeFile({ name: child.name }, theme);
          file.onclick = () => {
            ContractVerifierUI._setCode(
              { name: child.name, content: child.content },
              document.querySelector(contentSelector),
              document.querySelector(fileListSelector),
              file
            );
          };
          return file;
        }).concat(
          level.children.filter((obj) => obj.type === "folder").map(
            (child) => TreeFolder(
              { name: child.name, opened: true },
              theme,
              ...processLevel(child)
            )
          )
        );
      }
      processLevel(root).forEach((el) => filePart.appendChild(el));
    },
    _populateContainer(selector, hideLineNumbers) {
      const el = document.querySelector(selector);
      el.classList.add(classNames.CONTAINER);
      if (!hideLineNumbers) {
        el.classList.add("lineNumbers");
      }
    },
    loadSourcesData(sourcesData, opts) {
      this._populateContainer(opts.containerSelector, !!opts.hideLineNumbers);
      if (opts.fileListSelector) {
        this._populateFiles(
          opts.fileListSelector,
          opts.contentSelector,
          sourcesData.files,
          opts.theme
        );
      }
      this._populateStyle(opts.theme);
      this._populateCode(opts.contentSelector, opts.theme);
      this._setCode(
        sourcesData.files[0],
        document.querySelector(opts.contentSelector),
        document.querySelector(opts.fileListSelector),
        document.querySelector(`${opts.fileListSelector} .contract-verifier-file`)
        // Get first file
      );
    }
  };

  // src/lib/web.ts
  window.ContractVerifier = ContractVerifier;
  window.ContractVerifierUI = ContractVerifierUI;
})();
/*! Bundled license information:

buffer-es6/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=index.min.js.map
